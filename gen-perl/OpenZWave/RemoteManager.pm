#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use OpenZWave::Types;

# HELPER FUNCTIONS AND STRUCTURES

package OpenZWave::RemoteManager_WriteConfig_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_WriteConfig_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_WriteConfig_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_WriteConfig_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_WriteConfig_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_WriteConfig_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_WriteConfig_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetControllerNodeId_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetControllerNodeId_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetControllerNodeId_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetControllerNodeId_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetControllerNodeId_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetControllerNodeId_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetControllerNodeId_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetControllerNodeId_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsPrimaryController_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsPrimaryController_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsPrimaryController_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsPrimaryController_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsPrimaryController_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsPrimaryController_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsPrimaryController_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsPrimaryController_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsStaticUpdateController_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsStaticUpdateController_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsStaticUpdateController_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsStaticUpdateController_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsStaticUpdateController_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsStaticUpdateController_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsStaticUpdateController_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsStaticUpdateController_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsBridgeController_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsBridgeController_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsBridgeController_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsBridgeController_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsBridgeController_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsBridgeController_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsBridgeController_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsBridgeController_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetLibraryVersion_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetLibraryVersion_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetLibraryVersion_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetLibraryVersion_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetLibraryVersion_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetLibraryVersion_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetLibraryVersion_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetLibraryVersion_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetLibraryTypeName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetLibraryTypeName_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetLibraryTypeName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetLibraryTypeName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetLibraryTypeName_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetLibraryTypeName_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetLibraryTypeName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetLibraryTypeName_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetSendQueueCount_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetSendQueueCount_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetSendQueueCount_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetSendQueueCount_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetSendQueueCount_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetSendQueueCount_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetSendQueueCount_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetSendQueueCount_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetPollInterval_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetPollInterval_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetPollInterval_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetPollInterval_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetPollInterval_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetPollInterval_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetPollInterval_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetPollInterval_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetPollInterval_args->mk_accessors( qw( _seconds ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_seconds} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_seconds}) {
      $self->{_seconds} = $vals->{_seconds};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetPollInterval_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetPollInterval_args');
  if (defined $self->{_seconds}) {
    $xfer += $output->writeFieldBegin('_seconds', TType::I32, 1);
    $xfer += $output->writeI32($self->{_seconds});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetPollInterval_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetPollInterval_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetPollInterval_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_EnablePoll_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_EnablePoll_args->mk_accessors( qw( _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_EnablePoll_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_EnablePoll_args');
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 1);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_EnablePoll_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_EnablePoll_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_EnablePoll_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_EnablePoll_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_DisablePoll_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_DisablePoll_args->mk_accessors( qw( _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_DisablePoll_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_DisablePoll_args');
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 1);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_DisablePoll_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_DisablePoll_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_DisablePoll_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_DisablePoll_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_isPolled_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_isPolled_args->mk_accessors( qw( _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_isPolled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_isPolled_args');
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 1);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_isPolled_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_isPolled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_isPolled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_isPolled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RefreshNodeInfo_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RefreshNodeInfo_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RefreshNodeInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RefreshNodeInfo_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RefreshNodeInfo_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RefreshNodeInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RefreshNodeInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RefreshNodeInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestNodeState_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RequestNodeState_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestNodeState_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestNodeState_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestNodeState_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RequestNodeState_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestNodeState_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestNodeState_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestNodeDynamic_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RequestNodeDynamic_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestNodeDynamic_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestNodeDynamic_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestNodeDynamic_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RequestNodeDynamic_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestNodeDynamic_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestNodeDynamic_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeListeningDevice_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeListeningDevice_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeListeningDevice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeListeningDevice_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeListeningDevice_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeListeningDevice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeListeningDevice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeListeningDevice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeFrequentListeningDevice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeFrequentListeningDevice_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeFrequentListeningDevice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeFrequentListeningDevice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeBeamingDevice_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeBeamingDevice_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeBeamingDevice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeBeamingDevice_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeBeamingDevice_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeBeamingDevice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeBeamingDevice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeBeamingDevice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeRoutingDevice_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeRoutingDevice_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeRoutingDevice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeRoutingDevice_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeRoutingDevice_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeRoutingDevice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeRoutingDevice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeRoutingDevice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeSecurityDevice_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeSecurityDevice_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeSecurityDevice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeSecurityDevice_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeSecurityDevice_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeSecurityDevice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeSecurityDevice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeSecurityDevice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeMaxBaudRate_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeMaxBaudRate_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeMaxBaudRate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeMaxBaudRate_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeMaxBaudRate_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeMaxBaudRate_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeMaxBaudRate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeMaxBaudRate_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeVersion_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeVersion_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeVersion_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeVersion_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeVersion_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeVersion_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeVersion_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeVersion_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeBasic_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeBasic_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeBasic_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeBasic_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeBasic_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeBasic_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeBasic_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeBasic_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeGeneric_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeGeneric_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeGeneric_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeGeneric_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeGeneric_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeGeneric_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeGeneric_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeGeneric_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeSpecific_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeSpecific_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeSpecific_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeSpecific_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeSpecific_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeSpecific_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeSpecific_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeSpecific_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeType_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeType_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeType_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeType_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeType_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeType_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeType_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeType_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeNeighbors_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeNeighbors_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeNeighbors_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeNeighbors_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeNeighbors_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeNeighbors_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeNeighbors_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::UInt32_ListByte();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeNeighbors_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeManufacturerName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeManufacturerName_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeManufacturerName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeManufacturerName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeManufacturerName_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeManufacturerName_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeManufacturerName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeManufacturerName_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeProductName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeProductName_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeProductName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeProductName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeProductName_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeProductName_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeProductName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeProductName_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeName_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeName_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeName_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeName_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeLocation_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeLocation_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeLocation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeLocation_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeLocation_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeLocation_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeLocation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeLocation_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeManufacturerId_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeManufacturerId_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeManufacturerId_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeManufacturerId_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeManufacturerId_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeManufacturerId_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeManufacturerId_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeManufacturerId_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeProductType_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeProductType_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeProductType_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeProductType_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeProductType_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeProductType_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeProductType_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeProductType_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeProductId_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeProductId_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeProductId_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeProductId_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeProductId_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeProductId_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeProductId_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeProductId_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeManufacturerName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeManufacturerName_args->mk_accessors( qw( _homeId _nodeId _manufacturerName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_manufacturerName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_manufacturerName}) {
      $self->{_manufacturerName} = $vals->{_manufacturerName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeManufacturerName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_manufacturerName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeManufacturerName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_manufacturerName}) {
    $xfer += $output->writeFieldBegin('_manufacturerName', TType::STRING, 3);
    $xfer += $output->writeString($self->{_manufacturerName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeManufacturerName_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeManufacturerName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeManufacturerName_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeProductName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeProductName_args->mk_accessors( qw( _homeId _nodeId _productName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_productName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_productName}) {
      $self->{_productName} = $vals->{_productName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeProductName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_productName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeProductName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_productName}) {
    $xfer += $output->writeFieldBegin('_productName', TType::STRING, 3);
    $xfer += $output->writeString($self->{_productName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeProductName_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeProductName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeProductName_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeName_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeName_args->mk_accessors( qw( _homeId _nodeId _nodeName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_nodeName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_nodeName}) {
      $self->{_nodeName} = $vals->{_nodeName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeName_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_nodeName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeName_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeName}) {
    $xfer += $output->writeFieldBegin('_nodeName', TType::STRING, 3);
    $xfer += $output->writeString($self->{_nodeName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeName_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeName_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeName_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeLocation_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeLocation_args->mk_accessors( qw( _homeId _nodeId _location ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_location} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_location}) {
      $self->{_location} = $vals->{_location};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeLocation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_location});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeLocation_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_location}) {
    $xfer += $output->writeFieldBegin('_location', TType::STRING, 3);
    $xfer += $output->writeString($self->{_location});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeLocation_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeLocation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeLocation_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeOn_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeOn_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeOn_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeOn_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeOn_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeOn_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeOn_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeOff_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeOff_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeOff_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeOff_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeOff_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeOff_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeOff_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeLevel_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetNodeLevel_args->mk_accessors( qw( _homeId _nodeId _level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_level} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_level}) {
      $self->{_level} = $vals->{_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeLevel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeLevel_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_level}) {
    $xfer += $output->writeFieldBegin('_level', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetNodeLevel_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetNodeLevel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetNodeLevel_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeInfoReceived_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeInfoReceived_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeInfoReceived_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeInfoReceived_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsNodeInfoReceived_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsNodeInfoReceived_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsNodeInfoReceived_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsNodeInfoReceived_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeClassInformation_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeClassInformation_args->mk_accessors( qw( _homeId _nodeId _commandClassId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_commandClassId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_commandClassId}) {
      $self->{_commandClassId} = $vals->{_commandClassId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeClassInformation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_commandClassId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeClassInformation_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_commandClassId}) {
    $xfer += $output->writeFieldBegin('_commandClassId', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_commandClassId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNodeClassInformation_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNodeClassInformation_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNodeClassInformation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_GetNodeClassInformation();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNodeClassInformation_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueLabel_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueLabel_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueLabel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueLabel_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueLabel_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueLabel_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueLabel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueLabel_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueLabel_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValueLabel_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueLabel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueLabel_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 2);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueLabel_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueLabel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueLabel_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueUnits_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueUnits_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueUnits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueUnits_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueUnits_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueUnits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueUnits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueUnits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueUnits_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValueUnits_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueUnits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueUnits_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 2);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueUnits_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueUnits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueUnits_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueHelp_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueHelp_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueHelp_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueHelp_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueHelp_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueHelp_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueHelp_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueHelp_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueHelp_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValueHelp_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueHelp_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueHelp_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 2);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueHelp_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueHelp_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueHelp_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueMin_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueMin_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueMin_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueMin_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueMin_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueMin_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueMin_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueMin_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueMax_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueMax_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueMax_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueMax_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueMax_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueMax_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueMax_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueMax_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsValueReadOnly_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsValueReadOnly_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsValueReadOnly_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsValueReadOnly_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsValueReadOnly_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsValueReadOnly_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsValueReadOnly_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsValueReadOnly_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsValueWriteOnly_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsValueWriteOnly_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsValueWriteOnly_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsValueWriteOnly_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsValueWriteOnly_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsValueWriteOnly_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsValueWriteOnly_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsValueWriteOnly_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsValueSet_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsValueSet_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsValueSet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsValueSet_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_IsValueSet_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_IsValueSet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_IsValueSet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_IsValueSet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsBool_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsBool_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsBool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsBool_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsBool_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsBool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsBool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Bool();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsBool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsByte_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsByte_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsByte_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsByte_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsByte_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsByte_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsByte_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_UInt8();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsByte_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsFloat_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsFloat_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsFloat_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsFloat_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsFloat_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsFloat_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsFloat_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Float();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsFloat_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsInt_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsInt_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsInt_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsInt_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsInt_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsInt_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsInt_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Int();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsInt_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsShort_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsShort_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsShort_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsShort_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsShort_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsShort_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsShort_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Int16();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsShort_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsString_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsString_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsString_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsString_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueAsString_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueAsString_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueAsString_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_String();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueAsString_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueListSelection_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueListSelection_String_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueListSelection_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueListSelection_String_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueListSelection_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueListSelection_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueListSelection_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_String();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueListSelection_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueListSelection_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueListSelection_Int32_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueListSelection_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueListSelection_Int32_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueListSelection_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueListSelection_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueListSelection_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Int();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueListSelection_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueListItems_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueListItems_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueListItems_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueListItems_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueListItems_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueListItems_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueListItems_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_ListString();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueListItems_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueFloatPrecision_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueFloatPrecision_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueFloatPrecision_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueFloatPrecision_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetValueFloatPrecision_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetValueFloatPrecision_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetValueFloatPrecision_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_UInt8();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetValueFloatPrecision_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Bool_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Bool_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Bool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Bool_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Bool_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Bool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Bool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Bool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_UInt8_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_UInt8_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_UInt8_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_UInt8_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_UInt8_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_UInt8_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_UInt8_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_UInt8_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Float_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Float_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Float_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Float_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Float_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Float_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Float_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Float_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Int32_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Int32_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I32, 2);
    $xfer += $output->writeI32($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Int16_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Int16_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Int16_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Int16_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I16, 2);
    $xfer += $output->writeI16($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_Int16_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_Int16_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_Int16_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_Int16_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_String_args->mk_accessors( qw( _id _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_String_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 2);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValue_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValue_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValue_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValue_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueListSelection_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValueListSelection_args->mk_accessors( qw( _id _selectedItem ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_selectedItem} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_selectedItem}) {
      $self->{_selectedItem} = $vals->{_selectedItem};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueListSelection_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_selectedItem});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueListSelection_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_selectedItem}) {
    $xfer += $output->writeFieldBegin('_selectedItem', TType::STRING, 2);
    $xfer += $output->writeString($self->{_selectedItem});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetValueListSelection_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetValueListSelection_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetValueListSelection_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetValueListSelection_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_PressButton_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_PressButton_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_PressButton_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_PressButton_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_PressButton_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_PressButton_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_PressButton_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_PressButton_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ReleaseButton_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_ReleaseButton_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ReleaseButton_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ReleaseButton_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ReleaseButton_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_ReleaseButton_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ReleaseButton_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ReleaseButton_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNumSwitchPoints_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNumSwitchPoints_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNumSwitchPoints_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNumSwitchPoints_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNumSwitchPoints_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNumSwitchPoints_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNumSwitchPoints_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNumSwitchPoints_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSwitchPoint_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSwitchPoint_args->mk_accessors( qw( _id _hours _minutes _setback ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_hours} = undef;
  $self->{_minutes} = undef;
  $self->{_setback} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_hours}) {
      $self->{_hours} = $vals->{_hours};
    }
    if (defined $vals->{_minutes}) {
      $self->{_minutes} = $vals->{_minutes};
    }
    if (defined $vals->{_setback}) {
      $self->{_setback} = $vals->{_setback};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSwitchPoint_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_hours});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_minutes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_setback});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSwitchPoint_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_hours}) {
    $xfer += $output->writeFieldBegin('_hours', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_hours});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_minutes}) {
    $xfer += $output->writeFieldBegin('_minutes', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_minutes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_setback}) {
    $xfer += $output->writeFieldBegin('_setback', TType::BYTE, 4);
    $xfer += $output->writeByte($self->{_setback});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSwitchPoint_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSwitchPoint_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSwitchPoint_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSwitchPoint_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveSwitchPoint_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveSwitchPoint_args->mk_accessors( qw( _id _hours _minutes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_hours} = undef;
  $self->{_minutes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_hours}) {
      $self->{_hours} = $vals->{_hours};
    }
    if (defined $vals->{_minutes}) {
      $self->{_minutes} = $vals->{_minutes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveSwitchPoint_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_hours});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_minutes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveSwitchPoint_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_hours}) {
    $xfer += $output->writeFieldBegin('_hours', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_hours});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_minutes}) {
    $xfer += $output->writeFieldBegin('_minutes', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_minutes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveSwitchPoint_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveSwitchPoint_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveSwitchPoint_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveSwitchPoint_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ClearSwitchPoints_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_ClearSwitchPoints_args->mk_accessors( qw( _id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ClearSwitchPoints_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ClearSwitchPoints_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ClearSwitchPoints_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ClearSwitchPoints_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ClearSwitchPoints_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetSwitchPoint_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetSwitchPoint_args->mk_accessors( qw( _id _idx ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_id} = undef;
  $self->{_idx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_id}) {
      $self->{_id} = $vals->{_id};
    }
    if (defined $vals->{_idx}) {
      $self->{_idx} = $vals->{_idx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetSwitchPoint_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_id} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_idx});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetSwitchPoint_args');
  if (defined $self->{_id}) {
    $xfer += $output->writeFieldBegin('_id', TType::STRUCT, 1);
    $xfer += $self->{_id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_idx}) {
    $xfer += $output->writeFieldBegin('_idx', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_idx});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetSwitchPoint_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetSwitchPoint_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetSwitchPoint_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::GetSwitchPointReturnStruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetSwitchPoint_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SwitchAllOn_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SwitchAllOn_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SwitchAllOn_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SwitchAllOn_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SwitchAllOn_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SwitchAllOn_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SwitchAllOn_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SwitchAllOff_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SwitchAllOff_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SwitchAllOff_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SwitchAllOff_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SwitchAllOff_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SwitchAllOff_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SwitchAllOff_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetConfigParam_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetConfigParam_args->mk_accessors( qw( _homeId _nodeId _param _value _size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_param} = undef;
  $self->{_value} = undef;
  $self->{_size} = 2;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_param}) {
      $self->{_param} = $vals->{_param};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
    if (defined $vals->{_size}) {
      $self->{_size} = $vals->{_size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetConfigParam_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_param});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetConfigParam_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_param}) {
    $xfer += $output->writeFieldBegin('_param', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_param});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I32, 4);
    $xfer += $output->writeI32($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_size}) {
    $xfer += $output->writeFieldBegin('_size', TType::BYTE, 5);
    $xfer += $output->writeByte($self->{_size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetConfigParam_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetConfigParam_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetConfigParam_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetConfigParam_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestConfigParam_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RequestConfigParam_args->mk_accessors( qw( _homeId _nodeId _param ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_param} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_param}) {
      $self->{_param} = $vals->{_param};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestConfigParam_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_param});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestConfigParam_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_param}) {
    $xfer += $output->writeFieldBegin('_param', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_param});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestConfigParam_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestConfigParam_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestConfigParam_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestAllConfigParams_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RequestAllConfigParams_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestAllConfigParams_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestAllConfigParams_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RequestAllConfigParams_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RequestAllConfigParams_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RequestAllConfigParams_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNumGroups_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNumGroups_args->mk_accessors( qw( _homeId _nodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNumGroups_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNumGroups_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNumGroups_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNumGroups_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNumGroups_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNumGroups_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetAssociations_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetAssociations_args->mk_accessors( qw( _homeId _nodeId _groupIdx ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_groupIdx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_groupIdx}) {
      $self->{_groupIdx} = $vals->{_groupIdx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetAssociations_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_groupIdx});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetAssociations_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_groupIdx}) {
    $xfer += $output->writeFieldBegin('_groupIdx', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_groupIdx});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetAssociations_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetAssociations_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetAssociations_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::GetAssociationsReturnStruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetAssociations_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetMaxAssociations_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetMaxAssociations_args->mk_accessors( qw( _homeId _nodeId _groupIdx ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_groupIdx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_groupIdx}) {
      $self->{_groupIdx} = $vals->{_groupIdx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetMaxAssociations_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_groupIdx});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetMaxAssociations_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_groupIdx}) {
    $xfer += $output->writeFieldBegin('_groupIdx', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_groupIdx});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetMaxAssociations_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetMaxAssociations_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetMaxAssociations_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetMaxAssociations_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetGroupLabel_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetGroupLabel_args->mk_accessors( qw( _homeId _nodeId _groupIdx ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_groupIdx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_groupIdx}) {
      $self->{_groupIdx} = $vals->{_groupIdx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetGroupLabel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_groupIdx});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetGroupLabel_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_groupIdx}) {
    $xfer += $output->writeFieldBegin('_groupIdx', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_groupIdx});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetGroupLabel_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetGroupLabel_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetGroupLabel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetGroupLabel_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddAssociation_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddAssociation_args->mk_accessors( qw( _homeId _nodeId _groupIdx _targetNodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_groupIdx} = undef;
  $self->{_targetNodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_groupIdx}) {
      $self->{_groupIdx} = $vals->{_groupIdx};
    }
    if (defined $vals->{_targetNodeId}) {
      $self->{_targetNodeId} = $vals->{_targetNodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddAssociation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_groupIdx});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_targetNodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddAssociation_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_groupIdx}) {
    $xfer += $output->writeFieldBegin('_groupIdx', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_groupIdx});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_targetNodeId}) {
    $xfer += $output->writeFieldBegin('_targetNodeId', TType::BYTE, 4);
    $xfer += $output->writeByte($self->{_targetNodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddAssociation_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddAssociation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddAssociation_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveAssociation_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveAssociation_args->mk_accessors( qw( _homeId _nodeId _groupIdx _targetNodeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_nodeId} = undef;
  $self->{_groupIdx} = undef;
  $self->{_targetNodeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_groupIdx}) {
      $self->{_groupIdx} = $vals->{_groupIdx};
    }
    if (defined $vals->{_targetNodeId}) {
      $self->{_targetNodeId} = $vals->{_targetNodeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveAssociation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_groupIdx});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_targetNodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveAssociation_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 2);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_groupIdx}) {
    $xfer += $output->writeFieldBegin('_groupIdx', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_groupIdx});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_targetNodeId}) {
    $xfer += $output->writeFieldBegin('_targetNodeId', TType::BYTE, 4);
    $xfer += $output->writeByte($self->{_targetNodeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveAssociation_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveAssociation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveAssociation_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ResetController_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_ResetController_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ResetController_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ResetController_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ResetController_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ResetController_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ResetController_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SoftReset_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SoftReset_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SoftReset_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SoftReset_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SoftReset_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SoftReset_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SoftReset_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_BeginControllerCommand_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_BeginControllerCommand_args->mk_accessors( qw( _homeId _command _highPower _nodeId _arg ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  $self->{_command} = undef;
  $self->{_highPower} = undef;
  $self->{_nodeId} = undef;
  $self->{_arg} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
    if (defined $vals->{_command}) {
      $self->{_command} = $vals->{_command};
    }
    if (defined $vals->{_highPower}) {
      $self->{_highPower} = $vals->{_highPower};
    }
    if (defined $vals->{_nodeId}) {
      $self->{_nodeId} = $vals->{_nodeId};
    }
    if (defined $vals->{_arg}) {
      $self->{_arg} = $vals->{_arg};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_BeginControllerCommand_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_command});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{_highPower});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_nodeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_arg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_BeginControllerCommand_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_command}) {
    $xfer += $output->writeFieldBegin('_command', TType::I32, 2);
    $xfer += $output->writeI32($self->{_command});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_highPower}) {
    $xfer += $output->writeFieldBegin('_highPower', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{_highPower});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_nodeId}) {
    $xfer += $output->writeFieldBegin('_nodeId', TType::BYTE, 4);
    $xfer += $output->writeByte($self->{_nodeId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_arg}) {
    $xfer += $output->writeFieldBegin('_arg', TType::BYTE, 5);
    $xfer += $output->writeByte($self->{_arg});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_BeginControllerCommand_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_BeginControllerCommand_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_BeginControllerCommand_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_BeginControllerCommand_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_CancelControllerCommand_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_CancelControllerCommand_args->mk_accessors( qw( _homeId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_homeId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_homeId}) {
      $self->{_homeId} = $vals->{_homeId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_CancelControllerCommand_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_homeId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_CancelControllerCommand_args');
  if (defined $self->{_homeId}) {
    $xfer += $output->writeFieldBegin('_homeId', TType::I32, 1);
    $xfer += $output->writeI32($self->{_homeId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_CancelControllerCommand_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_CancelControllerCommand_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_CancelControllerCommand_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_CancelControllerCommand_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNumScenes_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNumScenes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNumScenes_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetNumScenes_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetNumScenes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetNumScenes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetNumScenes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetAllScenes_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetAllScenes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetAllScenes_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetAllScenes_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetAllScenes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetAllScenes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::GetAllScenesReturnStruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetAllScenes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_CreateScene_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_CreateScene_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_CreateScene_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_CreateScene_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_CreateScene_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_CreateScene_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_CreateScene_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveScene_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveScene_args->mk_accessors( qw( _sceneId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveScene_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveScene_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveScene_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveScene_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveScene_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveScene_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Bool_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Bool_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Bool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Bool_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Bool_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Bool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Bool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Bool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Uint8_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Uint8_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Uint8_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Uint8_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Uint8_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Uint8_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Uint8_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Uint8_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Float_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Float_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Float_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Float_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::DOUBLE, 3);
    $xfer += $output->writeDouble($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Float_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Float_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Float_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Float_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Int32_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Int32_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I32, 3);
    $xfer += $output->writeI32($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Int16_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Int16_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Int16_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Int16_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I16, 3);
    $xfer += $output->writeI16($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_Int16_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_Int16_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_Int16_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_Int16_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_String_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_String_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 3);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValue_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValue_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValue_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValue_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValueListSelection_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValueListSelection_String_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValueListSelection_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValueListSelection_String_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 3);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValueListSelection_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValueListSelection_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValueListSelection_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValueListSelection_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValueListSelection_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValueListSelection_Int32_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I32, 3);
    $xfer += $output->writeI32($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_AddSceneValueListSelection_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_AddSceneValueListSelection_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveSceneValue_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveSceneValue_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveSceneValue_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveSceneValue_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_RemoveSceneValue_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_RemoveSceneValue_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_RemoveSceneValue_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_RemoveSceneValue_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValues_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValues_args->mk_accessors( qw( _sceneId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValues_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValues_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValues_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValues_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValues_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::SceneGetValuesReturnStruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValues_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsBool_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsBool_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsBool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsBool_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsBool_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsBool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsBool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Bool();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsBool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsByte_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsByte_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsByte_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsByte_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsByte_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsByte_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsByte_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_UInt8();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsByte_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsFloat_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsFloat_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsFloat_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsFloat_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsFloat_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsFloat_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsFloat_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Float();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsFloat_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsInt_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsInt_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsInt_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsInt_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsInt_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsInt_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsInt_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Int();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsInt_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsShort_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsShort_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsShort_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsShort_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsShort_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsShort_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsShort_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Int16();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsShort_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsString_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsString_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsString_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsString_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueAsString_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueAsString_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueAsString_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_String();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueAsString_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueListSelection_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueListSelection_String_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueListSelection_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueListSelection_String_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueListSelection_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueListSelection_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueListSelection_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_String();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueListSelection_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_args->mk_accessors( qw( _sceneId _valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueListSelection_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueListSelection_Int32_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneGetValueListSelection_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new OpenZWave::Bool_Int();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneGetValueListSelection_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Bool_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Bool_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Bool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Bool_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Bool_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Bool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Bool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Bool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Uint8_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Uint8_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Uint8_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Uint8_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Uint8_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Uint8_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Uint8_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Uint8_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Float_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Float_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Float_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Float_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::DOUBLE, 3);
    $xfer += $output->writeDouble($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Float_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Float_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Float_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Float_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Int32_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Int32_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I32, 3);
    $xfer += $output->writeI32($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Int16_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Int16_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Int16_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Int16_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I16, 3);
    $xfer += $output->writeI16($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_Int16_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_Int16_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_Int16_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_Int16_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_String_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_String_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 3);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValue_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValue_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValue_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValue_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValueListSelection_String_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValueListSelection_String_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValueListSelection_String_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValueListSelection_String_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 3);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValueListSelection_String_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValueListSelection_String_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValueListSelection_String_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValueListSelection_String_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_args->mk_accessors( qw( _sceneId _valueId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_valueId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_valueId}) {
      $self->{_valueId} = $vals->{_valueId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValueListSelection_Int32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{_valueId} = new OpenZWave::RemoteValueID();
        $xfer += $self->{_valueId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValueListSelection_Int32_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_valueId}) {
    $xfer += $output->writeFieldBegin('_valueId', TType::STRUCT, 2);
    $xfer += $self->{_valueId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::I32, 3);
    $xfer += $output->writeI32($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneValueListSelection_Int32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneValueListSelection_Int32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetSceneLabel_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetSceneLabel_args->mk_accessors( qw( _sceneId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetSceneLabel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetSceneLabel_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_GetSceneLabel_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_GetSceneLabel_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_GetSceneLabel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_GetSceneLabel_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneLabel_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SetSceneLabel_args->mk_accessors( qw( _sceneId _value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  $self->{_value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
    if (defined $vals->{_value}) {
      $self->{_value} = $vals->{_value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneLabel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{_value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneLabel_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{_value}) {
    $xfer += $output->writeFieldBegin('_value', TType::STRING, 2);
    $xfer += $output->writeString($self->{_value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SetSceneLabel_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SetSceneLabel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SetSceneLabel_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneExists_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneExists_args->mk_accessors( qw( _sceneId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneExists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneExists_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SceneExists_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_SceneExists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SceneExists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SceneExists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ActivateScene_args;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_ActivateScene_args->mk_accessors( qw( _sceneId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{_sceneId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{_sceneId}) {
      $self->{_sceneId} = $vals->{_sceneId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ActivateScene_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{_sceneId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ActivateScene_args');
  if (defined $self->{_sceneId}) {
    $xfer += $output->writeFieldBegin('_sceneId', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{_sceneId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_ActivateScene_result;
use base qw(Class::Accessor);
OpenZWave::RemoteManager_ActivateScene_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_ActivateScene_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_ActivateScene_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SendAllValues_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SendAllValues_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SendAllValues_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManager_SendAllValues_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RemoteManager_SendAllValues_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RemoteManager_SendAllValues_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OpenZWave::RemoteManagerIf;

use strict;


sub WriteConfig{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub GetControllerNodeId{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub IsPrimaryController{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub IsStaticUpdateController{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub IsBridgeController{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub GetLibraryVersion{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub GetLibraryTypeName{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub GetSendQueueCount{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub GetPollInterval{
  my $self = shift;

  die 'implement interface';
}

sub SetPollInterval{
  my $self = shift;
  my $_seconds = shift;

  die 'implement interface';
}

sub EnablePoll{
  my $self = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub DisablePoll{
  my $self = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub isPolled{
  my $self = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub RefreshNodeInfo{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub RequestNodeState{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub RequestNodeDynamic{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub IsNodeListeningDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub IsNodeFrequentListeningDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub IsNodeBeamingDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub IsNodeRoutingDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub IsNodeSecurityDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeMaxBaudRate{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeVersion{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeBasic{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeGeneric{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeSpecific{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeType{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeNeighbors{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeManufacturerName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeProductName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeLocation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeManufacturerId{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeProductType{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeProductId{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub SetNodeManufacturerName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_manufacturerName = shift;

  die 'implement interface';
}

sub SetNodeProductName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_productName = shift;

  die 'implement interface';
}

sub SetNodeName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_nodeName = shift;

  die 'implement interface';
}

sub SetNodeLocation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_location = shift;

  die 'implement interface';
}

sub SetNodeOn{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub SetNodeOff{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub SetNodeLevel{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_level = shift;

  die 'implement interface';
}

sub IsNodeInfoReceived{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNodeClassInformation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_commandClassId = shift;

  die 'implement interface';
}

sub GetValueLabel{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub SetValueLabel{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub GetValueUnits{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub SetValueUnits{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub GetValueHelp{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub SetValueHelp{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub GetValueMin{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueMax{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub IsValueReadOnly{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub IsValueWriteOnly{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub IsValueSet{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueAsBool{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueAsByte{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueAsFloat{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueAsInt{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueAsShort{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueAsString{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueListSelection_String{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueListSelection_Int32{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueListItems{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetValueFloatPrecision{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub SetValue_Bool{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetValue_UInt8{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetValue_Float{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetValue_Int32{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetValue_Int16{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetValue_String{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetValueListSelection{
  my $self = shift;
  my $_id = shift;
  my $_selectedItem = shift;

  die 'implement interface';
}

sub PressButton{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub ReleaseButton{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetNumSwitchPoints{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub SetSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_hours = shift;
  my $_minutes = shift;
  my $_setback = shift;

  die 'implement interface';
}

sub RemoveSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_hours = shift;
  my $_minutes = shift;

  die 'implement interface';
}

sub ClearSwitchPoints{
  my $self = shift;
  my $_id = shift;

  die 'implement interface';
}

sub GetSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_idx = shift;

  die 'implement interface';
}

sub SwitchAllOn{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub SwitchAllOff{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub SetConfigParam{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_param = shift;
  my $_value = shift;
  my $_size = shift;

  die 'implement interface';
}

sub RequestConfigParam{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_param = shift;

  die 'implement interface';
}

sub RequestAllConfigParams{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetNumGroups{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  die 'implement interface';
}

sub GetAssociations{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

  die 'implement interface';
}

sub GetMaxAssociations{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

  die 'implement interface';
}

sub GetGroupLabel{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

  die 'implement interface';
}

sub AddAssociation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;
  my $_targetNodeId = shift;

  die 'implement interface';
}

sub RemoveAssociation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;
  my $_targetNodeId = shift;

  die 'implement interface';
}

sub ResetController{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub SoftReset{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub BeginControllerCommand{
  my $self = shift;
  my $_homeId = shift;
  my $_command = shift;
  my $_highPower = shift;
  my $_nodeId = shift;
  my $_arg = shift;

  die 'implement interface';
}

sub CancelControllerCommand{
  my $self = shift;
  my $_homeId = shift;

  die 'implement interface';
}

sub GetNumScenes{
  my $self = shift;

  die 'implement interface';
}

sub GetAllScenes{
  my $self = shift;

  die 'implement interface';
}

sub CreateScene{
  my $self = shift;

  die 'implement interface';
}

sub RemoveScene{
  my $self = shift;
  my $_sceneId = shift;

  die 'implement interface';
}

sub AddSceneValue_Bool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValue_Uint8{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValue_Float{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValue_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValue_Int16{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValue_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub AddSceneValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub RemoveSceneValue{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValues{
  my $self = shift;
  my $_sceneId = shift;

  die 'implement interface';
}

sub SceneGetValueAsBool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueAsByte{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueAsFloat{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueAsInt{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueAsShort{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueAsString{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SceneGetValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  die 'implement interface';
}

sub SetSceneValue_Bool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValue_Uint8{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValue_Float{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValue_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValue_Int16{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValue_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SetSceneValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub GetSceneLabel{
  my $self = shift;
  my $_sceneId = shift;

  die 'implement interface';
}

sub SetSceneLabel{
  my $self = shift;
  my $_sceneId = shift;
  my $_value = shift;

  die 'implement interface';
}

sub SceneExists{
  my $self = shift;
  my $_sceneId = shift;

  die 'implement interface';
}

sub ActivateScene{
  my $self = shift;
  my $_sceneId = shift;

  die 'implement interface';
}

sub SendAllValues{
  my $self = shift;

  die 'implement interface';
}

package OpenZWave::RemoteManagerRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub WriteConfig{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->WriteConfig($_homeId);
}

sub GetControllerNodeId{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->GetControllerNodeId($_homeId);
}

sub IsPrimaryController{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->IsPrimaryController($_homeId);
}

sub IsStaticUpdateController{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->IsStaticUpdateController($_homeId);
}

sub IsBridgeController{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->IsBridgeController($_homeId);
}

sub GetLibraryVersion{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->GetLibraryVersion($_homeId);
}

sub GetLibraryTypeName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->GetLibraryTypeName($_homeId);
}

sub GetSendQueueCount{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->GetSendQueueCount($_homeId);
}

sub GetPollInterval{
  my ($self, $request) = @_;

  return $self->{impl}->GetPollInterval();
}

sub SetPollInterval{
  my ($self, $request) = @_;

  my $_seconds = ($request->{'_seconds'}) ? $request->{'_seconds'} : undef;
  return $self->{impl}->SetPollInterval($_seconds);
}

sub EnablePoll{
  my ($self, $request) = @_;

  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->EnablePoll($_valueId);
}

sub DisablePoll{
  my ($self, $request) = @_;

  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->DisablePoll($_valueId);
}

sub isPolled{
  my ($self, $request) = @_;

  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->isPolled($_valueId);
}

sub RefreshNodeInfo{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->RefreshNodeInfo($_homeId, $_nodeId);
}

sub RequestNodeState{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->RequestNodeState($_homeId, $_nodeId);
}

sub RequestNodeDynamic{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->RequestNodeDynamic($_homeId, $_nodeId);
}

sub IsNodeListeningDevice{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->IsNodeListeningDevice($_homeId, $_nodeId);
}

sub IsNodeFrequentListeningDevice{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->IsNodeFrequentListeningDevice($_homeId, $_nodeId);
}

sub IsNodeBeamingDevice{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->IsNodeBeamingDevice($_homeId, $_nodeId);
}

sub IsNodeRoutingDevice{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->IsNodeRoutingDevice($_homeId, $_nodeId);
}

sub IsNodeSecurityDevice{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->IsNodeSecurityDevice($_homeId, $_nodeId);
}

sub GetNodeMaxBaudRate{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeMaxBaudRate($_homeId, $_nodeId);
}

sub GetNodeVersion{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeVersion($_homeId, $_nodeId);
}

sub GetNodeBasic{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeBasic($_homeId, $_nodeId);
}

sub GetNodeGeneric{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeGeneric($_homeId, $_nodeId);
}

sub GetNodeSpecific{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeSpecific($_homeId, $_nodeId);
}

sub GetNodeType{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeType($_homeId, $_nodeId);
}

sub GetNodeNeighbors{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeNeighbors($_homeId, $_nodeId);
}

sub GetNodeManufacturerName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeManufacturerName($_homeId, $_nodeId);
}

sub GetNodeProductName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeProductName($_homeId, $_nodeId);
}

sub GetNodeName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeName($_homeId, $_nodeId);
}

sub GetNodeLocation{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeLocation($_homeId, $_nodeId);
}

sub GetNodeManufacturerId{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeManufacturerId($_homeId, $_nodeId);
}

sub GetNodeProductType{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeProductType($_homeId, $_nodeId);
}

sub GetNodeProductId{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNodeProductId($_homeId, $_nodeId);
}

sub SetNodeManufacturerName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_manufacturerName = ($request->{'_manufacturerName'}) ? $request->{'_manufacturerName'} : undef;
  return $self->{impl}->SetNodeManufacturerName($_homeId, $_nodeId, $_manufacturerName);
}

sub SetNodeProductName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_productName = ($request->{'_productName'}) ? $request->{'_productName'} : undef;
  return $self->{impl}->SetNodeProductName($_homeId, $_nodeId, $_productName);
}

sub SetNodeName{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_nodeName = ($request->{'_nodeName'}) ? $request->{'_nodeName'} : undef;
  return $self->{impl}->SetNodeName($_homeId, $_nodeId, $_nodeName);
}

sub SetNodeLocation{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_location = ($request->{'_location'}) ? $request->{'_location'} : undef;
  return $self->{impl}->SetNodeLocation($_homeId, $_nodeId, $_location);
}

sub SetNodeOn{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->SetNodeOn($_homeId, $_nodeId);
}

sub SetNodeOff{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->SetNodeOff($_homeId, $_nodeId);
}

sub SetNodeLevel{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_level = ($request->{'_level'}) ? $request->{'_level'} : undef;
  return $self->{impl}->SetNodeLevel($_homeId, $_nodeId, $_level);
}

sub IsNodeInfoReceived{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->IsNodeInfoReceived($_homeId, $_nodeId);
}

sub GetNodeClassInformation{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_commandClassId = ($request->{'_commandClassId'}) ? $request->{'_commandClassId'} : undef;
  return $self->{impl}->GetNodeClassInformation($_homeId, $_nodeId, $_commandClassId);
}

sub GetValueLabel{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueLabel($_id);
}

sub SetValueLabel{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValueLabel($_id, $_value);
}

sub GetValueUnits{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueUnits($_id);
}

sub SetValueUnits{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValueUnits($_id, $_value);
}

sub GetValueHelp{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueHelp($_id);
}

sub SetValueHelp{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValueHelp($_id, $_value);
}

sub GetValueMin{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueMin($_id);
}

sub GetValueMax{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueMax($_id);
}

sub IsValueReadOnly{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->IsValueReadOnly($_id);
}

sub IsValueWriteOnly{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->IsValueWriteOnly($_id);
}

sub IsValueSet{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->IsValueSet($_id);
}

sub GetValueAsBool{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueAsBool($_id);
}

sub GetValueAsByte{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueAsByte($_id);
}

sub GetValueAsFloat{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueAsFloat($_id);
}

sub GetValueAsInt{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueAsInt($_id);
}

sub GetValueAsShort{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueAsShort($_id);
}

sub GetValueAsString{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueAsString($_id);
}

sub GetValueListSelection_String{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueListSelection_String($_id);
}

sub GetValueListSelection_Int32{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueListSelection_Int32($_id);
}

sub GetValueListItems{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueListItems($_id);
}

sub GetValueFloatPrecision{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetValueFloatPrecision($_id);
}

sub SetValue_Bool{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValue_Bool($_id, $_value);
}

sub SetValue_UInt8{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValue_UInt8($_id, $_value);
}

sub SetValue_Float{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValue_Float($_id, $_value);
}

sub SetValue_Int32{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValue_Int32($_id, $_value);
}

sub SetValue_Int16{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValue_Int16($_id, $_value);
}

sub SetValue_String{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetValue_String($_id, $_value);
}

sub SetValueListSelection{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_selectedItem = ($request->{'_selectedItem'}) ? $request->{'_selectedItem'} : undef;
  return $self->{impl}->SetValueListSelection($_id, $_selectedItem);
}

sub PressButton{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->PressButton($_id);
}

sub ReleaseButton{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->ReleaseButton($_id);
}

sub GetNumSwitchPoints{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->GetNumSwitchPoints($_id);
}

sub SetSwitchPoint{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_hours = ($request->{'_hours'}) ? $request->{'_hours'} : undef;
  my $_minutes = ($request->{'_minutes'}) ? $request->{'_minutes'} : undef;
  my $_setback = ($request->{'_setback'}) ? $request->{'_setback'} : undef;
  return $self->{impl}->SetSwitchPoint($_id, $_hours, $_minutes, $_setback);
}

sub RemoveSwitchPoint{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_hours = ($request->{'_hours'}) ? $request->{'_hours'} : undef;
  my $_minutes = ($request->{'_minutes'}) ? $request->{'_minutes'} : undef;
  return $self->{impl}->RemoveSwitchPoint($_id, $_hours, $_minutes);
}

sub ClearSwitchPoints{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  return $self->{impl}->ClearSwitchPoints($_id);
}

sub GetSwitchPoint{
  my ($self, $request) = @_;

  my $_id = ($request->{'_id'}) ? $request->{'_id'} : undef;
  my $_idx = ($request->{'_idx'}) ? $request->{'_idx'} : undef;
  return $self->{impl}->GetSwitchPoint($_id, $_idx);
}

sub SwitchAllOn{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->SwitchAllOn($_homeId);
}

sub SwitchAllOff{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->SwitchAllOff($_homeId);
}

sub SetConfigParam{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_param = ($request->{'_param'}) ? $request->{'_param'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  my $_size = ($request->{'_size'}) ? $request->{'_size'} : undef;
  return $self->{impl}->SetConfigParam($_homeId, $_nodeId, $_param, $_value, $_size);
}

sub RequestConfigParam{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_param = ($request->{'_param'}) ? $request->{'_param'} : undef;
  return $self->{impl}->RequestConfigParam($_homeId, $_nodeId, $_param);
}

sub RequestAllConfigParams{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->RequestAllConfigParams($_homeId, $_nodeId);
}

sub GetNumGroups{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  return $self->{impl}->GetNumGroups($_homeId, $_nodeId);
}

sub GetAssociations{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_groupIdx = ($request->{'_groupIdx'}) ? $request->{'_groupIdx'} : undef;
  return $self->{impl}->GetAssociations($_homeId, $_nodeId, $_groupIdx);
}

sub GetMaxAssociations{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_groupIdx = ($request->{'_groupIdx'}) ? $request->{'_groupIdx'} : undef;
  return $self->{impl}->GetMaxAssociations($_homeId, $_nodeId, $_groupIdx);
}

sub GetGroupLabel{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_groupIdx = ($request->{'_groupIdx'}) ? $request->{'_groupIdx'} : undef;
  return $self->{impl}->GetGroupLabel($_homeId, $_nodeId, $_groupIdx);
}

sub AddAssociation{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_groupIdx = ($request->{'_groupIdx'}) ? $request->{'_groupIdx'} : undef;
  my $_targetNodeId = ($request->{'_targetNodeId'}) ? $request->{'_targetNodeId'} : undef;
  return $self->{impl}->AddAssociation($_homeId, $_nodeId, $_groupIdx, $_targetNodeId);
}

sub RemoveAssociation{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_groupIdx = ($request->{'_groupIdx'}) ? $request->{'_groupIdx'} : undef;
  my $_targetNodeId = ($request->{'_targetNodeId'}) ? $request->{'_targetNodeId'} : undef;
  return $self->{impl}->RemoveAssociation($_homeId, $_nodeId, $_groupIdx, $_targetNodeId);
}

sub ResetController{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->ResetController($_homeId);
}

sub SoftReset{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->SoftReset($_homeId);
}

sub BeginControllerCommand{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  my $_command = ($request->{'_command'}) ? $request->{'_command'} : undef;
  my $_highPower = ($request->{'_highPower'}) ? $request->{'_highPower'} : undef;
  my $_nodeId = ($request->{'_nodeId'}) ? $request->{'_nodeId'} : undef;
  my $_arg = ($request->{'_arg'}) ? $request->{'_arg'} : undef;
  return $self->{impl}->BeginControllerCommand($_homeId, $_command, $_highPower, $_nodeId, $_arg);
}

sub CancelControllerCommand{
  my ($self, $request) = @_;

  my $_homeId = ($request->{'_homeId'}) ? $request->{'_homeId'} : undef;
  return $self->{impl}->CancelControllerCommand($_homeId);
}

sub GetNumScenes{
  my ($self, $request) = @_;

  return $self->{impl}->GetNumScenes();
}

sub GetAllScenes{
  my ($self, $request) = @_;

  return $self->{impl}->GetAllScenes();
}

sub CreateScene{
  my ($self, $request) = @_;

  return $self->{impl}->CreateScene();
}

sub RemoveScene{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  return $self->{impl}->RemoveScene($_sceneId);
}

sub AddSceneValue_Bool{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValue_Bool($_sceneId, $_valueId, $_value);
}

sub AddSceneValue_Uint8{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValue_Uint8($_sceneId, $_valueId, $_value);
}

sub AddSceneValue_Float{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValue_Float($_sceneId, $_valueId, $_value);
}

sub AddSceneValue_Int32{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValue_Int32($_sceneId, $_valueId, $_value);
}

sub AddSceneValue_Int16{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValue_Int16($_sceneId, $_valueId, $_value);
}

sub AddSceneValue_String{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValue_String($_sceneId, $_valueId, $_value);
}

sub AddSceneValueListSelection_String{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValueListSelection_String($_sceneId, $_valueId, $_value);
}

sub AddSceneValueListSelection_Int32{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->AddSceneValueListSelection_Int32($_sceneId, $_valueId, $_value);
}

sub RemoveSceneValue{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->RemoveSceneValue($_sceneId, $_valueId);
}

sub SceneGetValues{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  return $self->{impl}->SceneGetValues($_sceneId);
}

sub SceneGetValueAsBool{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueAsBool($_sceneId, $_valueId);
}

sub SceneGetValueAsByte{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueAsByte($_sceneId, $_valueId);
}

sub SceneGetValueAsFloat{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueAsFloat($_sceneId, $_valueId);
}

sub SceneGetValueAsInt{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueAsInt($_sceneId, $_valueId);
}

sub SceneGetValueAsShort{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueAsShort($_sceneId, $_valueId);
}

sub SceneGetValueAsString{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueAsString($_sceneId, $_valueId);
}

sub SceneGetValueListSelection_String{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueListSelection_String($_sceneId, $_valueId);
}

sub SceneGetValueListSelection_Int32{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  return $self->{impl}->SceneGetValueListSelection_Int32($_sceneId, $_valueId);
}

sub SetSceneValue_Bool{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValue_Bool($_sceneId, $_valueId, $_value);
}

sub SetSceneValue_Uint8{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValue_Uint8($_sceneId, $_valueId, $_value);
}

sub SetSceneValue_Float{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValue_Float($_sceneId, $_valueId, $_value);
}

sub SetSceneValue_Int32{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValue_Int32($_sceneId, $_valueId, $_value);
}

sub SetSceneValue_Int16{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValue_Int16($_sceneId, $_valueId, $_value);
}

sub SetSceneValue_String{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValue_String($_sceneId, $_valueId, $_value);
}

sub SetSceneValueListSelection_String{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValueListSelection_String($_sceneId, $_valueId, $_value);
}

sub SetSceneValueListSelection_Int32{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_valueId = ($request->{'_valueId'}) ? $request->{'_valueId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneValueListSelection_Int32($_sceneId, $_valueId, $_value);
}

sub GetSceneLabel{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  return $self->{impl}->GetSceneLabel($_sceneId);
}

sub SetSceneLabel{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  my $_value = ($request->{'_value'}) ? $request->{'_value'} : undef;
  return $self->{impl}->SetSceneLabel($_sceneId, $_value);
}

sub SceneExists{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  return $self->{impl}->SceneExists($_sceneId);
}

sub ActivateScene{
  my ($self, $request) = @_;

  my $_sceneId = ($request->{'_sceneId'}) ? $request->{'_sceneId'} : undef;
  return $self->{impl}->ActivateScene($_sceneId);
}

sub SendAllValues{
  my ($self, $request) = @_;

  return $self->{impl}->SendAllValues();
}

package OpenZWave::RemoteManagerClient;


use base qw(OpenZWave::RemoteManagerIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub WriteConfig{
  my $self = shift;
  my $_homeId = shift;

    $self->send_WriteConfig($_homeId);
  $self->recv_WriteConfig();
}

sub send_WriteConfig{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('WriteConfig', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_WriteConfig_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_WriteConfig{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_WriteConfig_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub GetControllerNodeId{
  my $self = shift;
  my $_homeId = shift;

    $self->send_GetControllerNodeId($_homeId);
  return $self->recv_GetControllerNodeId();
}

sub send_GetControllerNodeId{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('GetControllerNodeId', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetControllerNodeId_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetControllerNodeId{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetControllerNodeId_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetControllerNodeId failed: unknown result";
}
sub IsPrimaryController{
  my $self = shift;
  my $_homeId = shift;

    $self->send_IsPrimaryController($_homeId);
  return $self->recv_IsPrimaryController();
}

sub send_IsPrimaryController{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('IsPrimaryController', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsPrimaryController_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsPrimaryController{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsPrimaryController_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsPrimaryController failed: unknown result";
}
sub IsStaticUpdateController{
  my $self = shift;
  my $_homeId = shift;

    $self->send_IsStaticUpdateController($_homeId);
  return $self->recv_IsStaticUpdateController();
}

sub send_IsStaticUpdateController{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('IsStaticUpdateController', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsStaticUpdateController_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsStaticUpdateController{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsStaticUpdateController_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsStaticUpdateController failed: unknown result";
}
sub IsBridgeController{
  my $self = shift;
  my $_homeId = shift;

    $self->send_IsBridgeController($_homeId);
  return $self->recv_IsBridgeController();
}

sub send_IsBridgeController{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('IsBridgeController', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsBridgeController_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsBridgeController{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsBridgeController_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsBridgeController failed: unknown result";
}
sub GetLibraryVersion{
  my $self = shift;
  my $_homeId = shift;

    $self->send_GetLibraryVersion($_homeId);
  return $self->recv_GetLibraryVersion();
}

sub send_GetLibraryVersion{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('GetLibraryVersion', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetLibraryVersion_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetLibraryVersion{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetLibraryVersion_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetLibraryVersion failed: unknown result";
}
sub GetLibraryTypeName{
  my $self = shift;
  my $_homeId = shift;

    $self->send_GetLibraryTypeName($_homeId);
  return $self->recv_GetLibraryTypeName();
}

sub send_GetLibraryTypeName{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('GetLibraryTypeName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetLibraryTypeName_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetLibraryTypeName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetLibraryTypeName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetLibraryTypeName failed: unknown result";
}
sub GetSendQueueCount{
  my $self = shift;
  my $_homeId = shift;

    $self->send_GetSendQueueCount($_homeId);
  return $self->recv_GetSendQueueCount();
}

sub send_GetSendQueueCount{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('GetSendQueueCount', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetSendQueueCount_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetSendQueueCount{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetSendQueueCount_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetSendQueueCount failed: unknown result";
}
sub GetPollInterval{
  my $self = shift;

    $self->send_GetPollInterval();
  return $self->recv_GetPollInterval();
}

sub send_GetPollInterval{
  my $self = shift;

  $self->{output}->writeMessageBegin('GetPollInterval', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetPollInterval_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetPollInterval{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetPollInterval_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetPollInterval failed: unknown result";
}
sub SetPollInterval{
  my $self = shift;
  my $_seconds = shift;

    $self->send_SetPollInterval($_seconds);
  $self->recv_SetPollInterval();
}

sub send_SetPollInterval{
  my $self = shift;
  my $_seconds = shift;

  $self->{output}->writeMessageBegin('SetPollInterval', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetPollInterval_args();
  $args->{_seconds} = $_seconds;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetPollInterval{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetPollInterval_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub EnablePoll{
  my $self = shift;
  my $_valueId = shift;

    $self->send_EnablePoll($_valueId);
  return $self->recv_EnablePoll();
}

sub send_EnablePoll{
  my $self = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('EnablePoll', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_EnablePoll_args();
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_EnablePoll{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_EnablePoll_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "EnablePoll failed: unknown result";
}
sub DisablePoll{
  my $self = shift;
  my $_valueId = shift;

    $self->send_DisablePoll($_valueId);
  return $self->recv_DisablePoll();
}

sub send_DisablePoll{
  my $self = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('DisablePoll', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_DisablePoll_args();
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_DisablePoll{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_DisablePoll_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "DisablePoll failed: unknown result";
}
sub isPolled{
  my $self = shift;
  my $_valueId = shift;

    $self->send_isPolled($_valueId);
  return $self->recv_isPolled();
}

sub send_isPolled{
  my $self = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('isPolled', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_isPolled_args();
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isPolled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_isPolled_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "isPolled failed: unknown result";
}
sub RefreshNodeInfo{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_RefreshNodeInfo($_homeId, $_nodeId);
  return $self->recv_RefreshNodeInfo();
}

sub send_RefreshNodeInfo{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('RefreshNodeInfo', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RefreshNodeInfo_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RefreshNodeInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RefreshNodeInfo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "RefreshNodeInfo failed: unknown result";
}
sub RequestNodeState{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_RequestNodeState($_homeId, $_nodeId);
  return $self->recv_RequestNodeState();
}

sub send_RequestNodeState{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('RequestNodeState', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RequestNodeState_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RequestNodeState{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RequestNodeState_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "RequestNodeState failed: unknown result";
}
sub RequestNodeDynamic{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_RequestNodeDynamic($_homeId, $_nodeId);
  return $self->recv_RequestNodeDynamic();
}

sub send_RequestNodeDynamic{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('RequestNodeDynamic', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RequestNodeDynamic_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RequestNodeDynamic{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RequestNodeDynamic_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "RequestNodeDynamic failed: unknown result";
}
sub IsNodeListeningDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_IsNodeListeningDevice($_homeId, $_nodeId);
  return $self->recv_IsNodeListeningDevice();
}

sub send_IsNodeListeningDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('IsNodeListeningDevice', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsNodeListeningDevice_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsNodeListeningDevice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsNodeListeningDevice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsNodeListeningDevice failed: unknown result";
}
sub IsNodeFrequentListeningDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_IsNodeFrequentListeningDevice($_homeId, $_nodeId);
  return $self->recv_IsNodeFrequentListeningDevice();
}

sub send_IsNodeFrequentListeningDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('IsNodeFrequentListeningDevice', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsNodeFrequentListeningDevice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsNodeFrequentListeningDevice failed: unknown result";
}
sub IsNodeBeamingDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_IsNodeBeamingDevice($_homeId, $_nodeId);
  return $self->recv_IsNodeBeamingDevice();
}

sub send_IsNodeBeamingDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('IsNodeBeamingDevice', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsNodeBeamingDevice_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsNodeBeamingDevice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsNodeBeamingDevice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsNodeBeamingDevice failed: unknown result";
}
sub IsNodeRoutingDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_IsNodeRoutingDevice($_homeId, $_nodeId);
  return $self->recv_IsNodeRoutingDevice();
}

sub send_IsNodeRoutingDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('IsNodeRoutingDevice', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsNodeRoutingDevice_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsNodeRoutingDevice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsNodeRoutingDevice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsNodeRoutingDevice failed: unknown result";
}
sub IsNodeSecurityDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_IsNodeSecurityDevice($_homeId, $_nodeId);
  return $self->recv_IsNodeSecurityDevice();
}

sub send_IsNodeSecurityDevice{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('IsNodeSecurityDevice', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsNodeSecurityDevice_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsNodeSecurityDevice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsNodeSecurityDevice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsNodeSecurityDevice failed: unknown result";
}
sub GetNodeMaxBaudRate{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeMaxBaudRate($_homeId, $_nodeId);
  return $self->recv_GetNodeMaxBaudRate();
}

sub send_GetNodeMaxBaudRate{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeMaxBaudRate', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeMaxBaudRate_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeMaxBaudRate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeMaxBaudRate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeMaxBaudRate failed: unknown result";
}
sub GetNodeVersion{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeVersion($_homeId, $_nodeId);
  return $self->recv_GetNodeVersion();
}

sub send_GetNodeVersion{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeVersion', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeVersion_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeVersion{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeVersion_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeVersion failed: unknown result";
}
sub GetNodeBasic{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeBasic($_homeId, $_nodeId);
  return $self->recv_GetNodeBasic();
}

sub send_GetNodeBasic{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeBasic', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeBasic_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeBasic{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeBasic_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeBasic failed: unknown result";
}
sub GetNodeGeneric{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeGeneric($_homeId, $_nodeId);
  return $self->recv_GetNodeGeneric();
}

sub send_GetNodeGeneric{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeGeneric', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeGeneric_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeGeneric{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeGeneric_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeGeneric failed: unknown result";
}
sub GetNodeSpecific{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeSpecific($_homeId, $_nodeId);
  return $self->recv_GetNodeSpecific();
}

sub send_GetNodeSpecific{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeSpecific', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeSpecific_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeSpecific{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeSpecific_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeSpecific failed: unknown result";
}
sub GetNodeType{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeType($_homeId, $_nodeId);
  return $self->recv_GetNodeType();
}

sub send_GetNodeType{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeType', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeType_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeType{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeType_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeType failed: unknown result";
}
sub GetNodeNeighbors{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeNeighbors($_homeId, $_nodeId);
  return $self->recv_GetNodeNeighbors();
}

sub send_GetNodeNeighbors{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeNeighbors', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeNeighbors_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeNeighbors{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeNeighbors_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeNeighbors failed: unknown result";
}
sub GetNodeManufacturerName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeManufacturerName($_homeId, $_nodeId);
  return $self->recv_GetNodeManufacturerName();
}

sub send_GetNodeManufacturerName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeManufacturerName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeManufacturerName_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeManufacturerName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeManufacturerName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeManufacturerName failed: unknown result";
}
sub GetNodeProductName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeProductName($_homeId, $_nodeId);
  return $self->recv_GetNodeProductName();
}

sub send_GetNodeProductName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeProductName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeProductName_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeProductName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeProductName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeProductName failed: unknown result";
}
sub GetNodeName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeName($_homeId, $_nodeId);
  return $self->recv_GetNodeName();
}

sub send_GetNodeName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeName_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeName failed: unknown result";
}
sub GetNodeLocation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeLocation($_homeId, $_nodeId);
  return $self->recv_GetNodeLocation();
}

sub send_GetNodeLocation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeLocation', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeLocation_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeLocation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeLocation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeLocation failed: unknown result";
}
sub GetNodeManufacturerId{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeManufacturerId($_homeId, $_nodeId);
  return $self->recv_GetNodeManufacturerId();
}

sub send_GetNodeManufacturerId{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeManufacturerId', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeManufacturerId_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeManufacturerId{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeManufacturerId_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeManufacturerId failed: unknown result";
}
sub GetNodeProductType{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeProductType($_homeId, $_nodeId);
  return $self->recv_GetNodeProductType();
}

sub send_GetNodeProductType{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeProductType', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeProductType_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeProductType{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeProductType_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeProductType failed: unknown result";
}
sub GetNodeProductId{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNodeProductId($_homeId, $_nodeId);
  return $self->recv_GetNodeProductId();
}

sub send_GetNodeProductId{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNodeProductId', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeProductId_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeProductId{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeProductId_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeProductId failed: unknown result";
}
sub SetNodeManufacturerName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_manufacturerName = shift;

    $self->send_SetNodeManufacturerName($_homeId, $_nodeId, $_manufacturerName);
  $self->recv_SetNodeManufacturerName();
}

sub send_SetNodeManufacturerName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_manufacturerName = shift;

  $self->{output}->writeMessageBegin('SetNodeManufacturerName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeManufacturerName_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_manufacturerName} = $_manufacturerName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeManufacturerName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeManufacturerName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetNodeProductName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_productName = shift;

    $self->send_SetNodeProductName($_homeId, $_nodeId, $_productName);
  $self->recv_SetNodeProductName();
}

sub send_SetNodeProductName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_productName = shift;

  $self->{output}->writeMessageBegin('SetNodeProductName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeProductName_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_productName} = $_productName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeProductName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeProductName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetNodeName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_nodeName = shift;

    $self->send_SetNodeName($_homeId, $_nodeId, $_nodeName);
  $self->recv_SetNodeName();
}

sub send_SetNodeName{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_nodeName = shift;

  $self->{output}->writeMessageBegin('SetNodeName', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeName_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_nodeName} = $_nodeName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeName{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeName_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetNodeLocation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_location = shift;

    $self->send_SetNodeLocation($_homeId, $_nodeId, $_location);
  $self->recv_SetNodeLocation();
}

sub send_SetNodeLocation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_location = shift;

  $self->{output}->writeMessageBegin('SetNodeLocation', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeLocation_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_location} = $_location;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeLocation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeLocation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetNodeOn{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_SetNodeOn($_homeId, $_nodeId);
  $self->recv_SetNodeOn();
}

sub send_SetNodeOn{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('SetNodeOn', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeOn_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeOn{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeOn_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetNodeOff{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_SetNodeOff($_homeId, $_nodeId);
  $self->recv_SetNodeOff();
}

sub send_SetNodeOff{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('SetNodeOff', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeOff_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeOff{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeOff_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetNodeLevel{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_level = shift;

    $self->send_SetNodeLevel($_homeId, $_nodeId, $_level);
  $self->recv_SetNodeLevel();
}

sub send_SetNodeLevel{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_level = shift;

  $self->{output}->writeMessageBegin('SetNodeLevel', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetNodeLevel_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_level} = $_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetNodeLevel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetNodeLevel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub IsNodeInfoReceived{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_IsNodeInfoReceived($_homeId, $_nodeId);
  return $self->recv_IsNodeInfoReceived();
}

sub send_IsNodeInfoReceived{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('IsNodeInfoReceived', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsNodeInfoReceived_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsNodeInfoReceived{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsNodeInfoReceived_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsNodeInfoReceived failed: unknown result";
}
sub GetNodeClassInformation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_commandClassId = shift;

    $self->send_GetNodeClassInformation($_homeId, $_nodeId, $_commandClassId);
  return $self->recv_GetNodeClassInformation();
}

sub send_GetNodeClassInformation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_commandClassId = shift;

  $self->{output}->writeMessageBegin('GetNodeClassInformation', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNodeClassInformation_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_commandClassId} = $_commandClassId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNodeClassInformation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNodeClassInformation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNodeClassInformation failed: unknown result";
}
sub GetValueLabel{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueLabel($_id);
  return $self->recv_GetValueLabel();
}

sub send_GetValueLabel{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueLabel', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueLabel_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueLabel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueLabel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueLabel failed: unknown result";
}
sub SetValueLabel{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValueLabel($_id, $_value);
  $self->recv_SetValueLabel();
}

sub send_SetValueLabel{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValueLabel', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValueLabel_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValueLabel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValueLabel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub GetValueUnits{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueUnits($_id);
  return $self->recv_GetValueUnits();
}

sub send_GetValueUnits{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueUnits', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueUnits_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueUnits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueUnits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueUnits failed: unknown result";
}
sub SetValueUnits{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValueUnits($_id, $_value);
  $self->recv_SetValueUnits();
}

sub send_SetValueUnits{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValueUnits', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValueUnits_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValueUnits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValueUnits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub GetValueHelp{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueHelp($_id);
  return $self->recv_GetValueHelp();
}

sub send_GetValueHelp{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueHelp', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueHelp_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueHelp{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueHelp_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueHelp failed: unknown result";
}
sub SetValueHelp{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValueHelp($_id, $_value);
  $self->recv_SetValueHelp();
}

sub send_SetValueHelp{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValueHelp', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValueHelp_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValueHelp{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValueHelp_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub GetValueMin{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueMin($_id);
  return $self->recv_GetValueMin();
}

sub send_GetValueMin{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueMin', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueMin_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueMin{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueMin_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueMin failed: unknown result";
}
sub GetValueMax{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueMax($_id);
  return $self->recv_GetValueMax();
}

sub send_GetValueMax{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueMax', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueMax_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueMax{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueMax_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueMax failed: unknown result";
}
sub IsValueReadOnly{
  my $self = shift;
  my $_id = shift;

    $self->send_IsValueReadOnly($_id);
  return $self->recv_IsValueReadOnly();
}

sub send_IsValueReadOnly{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('IsValueReadOnly', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsValueReadOnly_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsValueReadOnly{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsValueReadOnly_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsValueReadOnly failed: unknown result";
}
sub IsValueWriteOnly{
  my $self = shift;
  my $_id = shift;

    $self->send_IsValueWriteOnly($_id);
  return $self->recv_IsValueWriteOnly();
}

sub send_IsValueWriteOnly{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('IsValueWriteOnly', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsValueWriteOnly_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsValueWriteOnly{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsValueWriteOnly_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsValueWriteOnly failed: unknown result";
}
sub IsValueSet{
  my $self = shift;
  my $_id = shift;

    $self->send_IsValueSet($_id);
  return $self->recv_IsValueSet();
}

sub send_IsValueSet{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('IsValueSet', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_IsValueSet_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_IsValueSet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_IsValueSet_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "IsValueSet failed: unknown result";
}
sub GetValueAsBool{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueAsBool($_id);
  return $self->recv_GetValueAsBool();
}

sub send_GetValueAsBool{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueAsBool', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueAsBool_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueAsBool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueAsBool_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueAsBool failed: unknown result";
}
sub GetValueAsByte{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueAsByte($_id);
  return $self->recv_GetValueAsByte();
}

sub send_GetValueAsByte{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueAsByte', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueAsByte_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueAsByte{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueAsByte_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueAsByte failed: unknown result";
}
sub GetValueAsFloat{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueAsFloat($_id);
  return $self->recv_GetValueAsFloat();
}

sub send_GetValueAsFloat{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueAsFloat', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueAsFloat_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueAsFloat{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueAsFloat_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueAsFloat failed: unknown result";
}
sub GetValueAsInt{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueAsInt($_id);
  return $self->recv_GetValueAsInt();
}

sub send_GetValueAsInt{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueAsInt', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueAsInt_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueAsInt{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueAsInt_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueAsInt failed: unknown result";
}
sub GetValueAsShort{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueAsShort($_id);
  return $self->recv_GetValueAsShort();
}

sub send_GetValueAsShort{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueAsShort', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueAsShort_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueAsShort{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueAsShort_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueAsShort failed: unknown result";
}
sub GetValueAsString{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueAsString($_id);
  return $self->recv_GetValueAsString();
}

sub send_GetValueAsString{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueAsString', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueAsString_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueAsString{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueAsString_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueAsString failed: unknown result";
}
sub GetValueListSelection_String{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueListSelection_String($_id);
  return $self->recv_GetValueListSelection_String();
}

sub send_GetValueListSelection_String{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueListSelection_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueListSelection_String_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueListSelection_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueListSelection_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueListSelection_String failed: unknown result";
}
sub GetValueListSelection_Int32{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueListSelection_Int32($_id);
  return $self->recv_GetValueListSelection_Int32();
}

sub send_GetValueListSelection_Int32{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueListSelection_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueListSelection_Int32_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueListSelection_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueListSelection_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueListSelection_Int32 failed: unknown result";
}
sub GetValueListItems{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueListItems($_id);
  return $self->recv_GetValueListItems();
}

sub send_GetValueListItems{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueListItems', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueListItems_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueListItems{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueListItems_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueListItems failed: unknown result";
}
sub GetValueFloatPrecision{
  my $self = shift;
  my $_id = shift;

    $self->send_GetValueFloatPrecision($_id);
  return $self->recv_GetValueFloatPrecision();
}

sub send_GetValueFloatPrecision{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetValueFloatPrecision', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetValueFloatPrecision_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetValueFloatPrecision{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetValueFloatPrecision_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetValueFloatPrecision failed: unknown result";
}
sub SetValue_Bool{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValue_Bool($_id, $_value);
  return $self->recv_SetValue_Bool();
}

sub send_SetValue_Bool{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValue_Bool', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValue_Bool_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValue_Bool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValue_Bool_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValue_Bool failed: unknown result";
}
sub SetValue_UInt8{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValue_UInt8($_id, $_value);
  return $self->recv_SetValue_UInt8();
}

sub send_SetValue_UInt8{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValue_UInt8', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValue_UInt8_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValue_UInt8{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValue_UInt8_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValue_UInt8 failed: unknown result";
}
sub SetValue_Float{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValue_Float($_id, $_value);
  return $self->recv_SetValue_Float();
}

sub send_SetValue_Float{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValue_Float', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValue_Float_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValue_Float{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValue_Float_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValue_Float failed: unknown result";
}
sub SetValue_Int32{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValue_Int32($_id, $_value);
  return $self->recv_SetValue_Int32();
}

sub send_SetValue_Int32{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValue_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValue_Int32_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValue_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValue_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValue_Int32 failed: unknown result";
}
sub SetValue_Int16{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValue_Int16($_id, $_value);
  return $self->recv_SetValue_Int16();
}

sub send_SetValue_Int16{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValue_Int16', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValue_Int16_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValue_Int16{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValue_Int16_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValue_Int16 failed: unknown result";
}
sub SetValue_String{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

    $self->send_SetValue_String($_id, $_value);
  return $self->recv_SetValue_String();
}

sub send_SetValue_String{
  my $self = shift;
  my $_id = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetValue_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValue_String_args();
  $args->{_id} = $_id;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValue_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValue_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValue_String failed: unknown result";
}
sub SetValueListSelection{
  my $self = shift;
  my $_id = shift;
  my $_selectedItem = shift;

    $self->send_SetValueListSelection($_id, $_selectedItem);
  return $self->recv_SetValueListSelection();
}

sub send_SetValueListSelection{
  my $self = shift;
  my $_id = shift;
  my $_selectedItem = shift;

  $self->{output}->writeMessageBegin('SetValueListSelection', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetValueListSelection_args();
  $args->{_id} = $_id;
  $args->{_selectedItem} = $_selectedItem;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetValueListSelection{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetValueListSelection_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetValueListSelection failed: unknown result";
}
sub PressButton{
  my $self = shift;
  my $_id = shift;

    $self->send_PressButton($_id);
  return $self->recv_PressButton();
}

sub send_PressButton{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('PressButton', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_PressButton_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_PressButton{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_PressButton_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "PressButton failed: unknown result";
}
sub ReleaseButton{
  my $self = shift;
  my $_id = shift;

    $self->send_ReleaseButton($_id);
  return $self->recv_ReleaseButton();
}

sub send_ReleaseButton{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('ReleaseButton', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_ReleaseButton_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ReleaseButton{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_ReleaseButton_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "ReleaseButton failed: unknown result";
}
sub GetNumSwitchPoints{
  my $self = shift;
  my $_id = shift;

    $self->send_GetNumSwitchPoints($_id);
  return $self->recv_GetNumSwitchPoints();
}

sub send_GetNumSwitchPoints{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('GetNumSwitchPoints', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNumSwitchPoints_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNumSwitchPoints{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNumSwitchPoints_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNumSwitchPoints failed: unknown result";
}
sub SetSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_hours = shift;
  my $_minutes = shift;
  my $_setback = shift;

    $self->send_SetSwitchPoint($_id, $_hours, $_minutes, $_setback);
  return $self->recv_SetSwitchPoint();
}

sub send_SetSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_hours = shift;
  my $_minutes = shift;
  my $_setback = shift;

  $self->{output}->writeMessageBegin('SetSwitchPoint', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSwitchPoint_args();
  $args->{_id} = $_id;
  $args->{_hours} = $_hours;
  $args->{_minutes} = $_minutes;
  $args->{_setback} = $_setback;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSwitchPoint{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSwitchPoint_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSwitchPoint failed: unknown result";
}
sub RemoveSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_hours = shift;
  my $_minutes = shift;

    $self->send_RemoveSwitchPoint($_id, $_hours, $_minutes);
  return $self->recv_RemoveSwitchPoint();
}

sub send_RemoveSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_hours = shift;
  my $_minutes = shift;

  $self->{output}->writeMessageBegin('RemoveSwitchPoint', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RemoveSwitchPoint_args();
  $args->{_id} = $_id;
  $args->{_hours} = $_hours;
  $args->{_minutes} = $_minutes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RemoveSwitchPoint{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RemoveSwitchPoint_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "RemoveSwitchPoint failed: unknown result";
}
sub ClearSwitchPoints{
  my $self = shift;
  my $_id = shift;

    $self->send_ClearSwitchPoints($_id);
  $self->recv_ClearSwitchPoints();
}

sub send_ClearSwitchPoints{
  my $self = shift;
  my $_id = shift;

  $self->{output}->writeMessageBegin('ClearSwitchPoints', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_ClearSwitchPoints_args();
  $args->{_id} = $_id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ClearSwitchPoints{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_ClearSwitchPoints_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub GetSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_idx = shift;

    $self->send_GetSwitchPoint($_id, $_idx);
  return $self->recv_GetSwitchPoint();
}

sub send_GetSwitchPoint{
  my $self = shift;
  my $_id = shift;
  my $_idx = shift;

  $self->{output}->writeMessageBegin('GetSwitchPoint', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetSwitchPoint_args();
  $args->{_id} = $_id;
  $args->{_idx} = $_idx;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetSwitchPoint{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetSwitchPoint_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetSwitchPoint failed: unknown result";
}
sub SwitchAllOn{
  my $self = shift;
  my $_homeId = shift;

    $self->send_SwitchAllOn($_homeId);
  $self->recv_SwitchAllOn();
}

sub send_SwitchAllOn{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('SwitchAllOn', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SwitchAllOn_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SwitchAllOn{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SwitchAllOn_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SwitchAllOff{
  my $self = shift;
  my $_homeId = shift;

    $self->send_SwitchAllOff($_homeId);
  $self->recv_SwitchAllOff();
}

sub send_SwitchAllOff{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('SwitchAllOff', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SwitchAllOff_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SwitchAllOff{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SwitchAllOff_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SetConfigParam{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_param = shift;
  my $_value = shift;
  my $_size = shift;

    $self->send_SetConfigParam($_homeId, $_nodeId, $_param, $_value, $_size);
  return $self->recv_SetConfigParam();
}

sub send_SetConfigParam{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_param = shift;
  my $_value = shift;
  my $_size = shift;

  $self->{output}->writeMessageBegin('SetConfigParam', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetConfigParam_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_param} = $_param;
  $args->{_value} = $_value;
  $args->{_size} = $_size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetConfigParam{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetConfigParam_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetConfigParam failed: unknown result";
}
sub RequestConfigParam{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_param = shift;

    $self->send_RequestConfigParam($_homeId, $_nodeId, $_param);
  $self->recv_RequestConfigParam();
}

sub send_RequestConfigParam{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_param = shift;

  $self->{output}->writeMessageBegin('RequestConfigParam', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RequestConfigParam_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_param} = $_param;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RequestConfigParam{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RequestConfigParam_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub RequestAllConfigParams{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_RequestAllConfigParams($_homeId, $_nodeId);
  $self->recv_RequestAllConfigParams();
}

sub send_RequestAllConfigParams{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('RequestAllConfigParams', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RequestAllConfigParams_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RequestAllConfigParams{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RequestAllConfigParams_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub GetNumGroups{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

    $self->send_GetNumGroups($_homeId, $_nodeId);
  return $self->recv_GetNumGroups();
}

sub send_GetNumGroups{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;

  $self->{output}->writeMessageBegin('GetNumGroups', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNumGroups_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNumGroups{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNumGroups_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNumGroups failed: unknown result";
}
sub GetAssociations{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

    $self->send_GetAssociations($_homeId, $_nodeId, $_groupIdx);
  return $self->recv_GetAssociations();
}

sub send_GetAssociations{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

  $self->{output}->writeMessageBegin('GetAssociations', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetAssociations_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_groupIdx} = $_groupIdx;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetAssociations{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetAssociations_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetAssociations failed: unknown result";
}
sub GetMaxAssociations{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

    $self->send_GetMaxAssociations($_homeId, $_nodeId, $_groupIdx);
  return $self->recv_GetMaxAssociations();
}

sub send_GetMaxAssociations{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

  $self->{output}->writeMessageBegin('GetMaxAssociations', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetMaxAssociations_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_groupIdx} = $_groupIdx;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetMaxAssociations{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetMaxAssociations_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetMaxAssociations failed: unknown result";
}
sub GetGroupLabel{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

    $self->send_GetGroupLabel($_homeId, $_nodeId, $_groupIdx);
  return $self->recv_GetGroupLabel();
}

sub send_GetGroupLabel{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;

  $self->{output}->writeMessageBegin('GetGroupLabel', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetGroupLabel_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_groupIdx} = $_groupIdx;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetGroupLabel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetGroupLabel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetGroupLabel failed: unknown result";
}
sub AddAssociation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;
  my $_targetNodeId = shift;

    $self->send_AddAssociation($_homeId, $_nodeId, $_groupIdx, $_targetNodeId);
  $self->recv_AddAssociation();
}

sub send_AddAssociation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;
  my $_targetNodeId = shift;

  $self->{output}->writeMessageBegin('AddAssociation', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddAssociation_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_groupIdx} = $_groupIdx;
  $args->{_targetNodeId} = $_targetNodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddAssociation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddAssociation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub RemoveAssociation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;
  my $_targetNodeId = shift;

    $self->send_RemoveAssociation($_homeId, $_nodeId, $_groupIdx, $_targetNodeId);
  $self->recv_RemoveAssociation();
}

sub send_RemoveAssociation{
  my $self = shift;
  my $_homeId = shift;
  my $_nodeId = shift;
  my $_groupIdx = shift;
  my $_targetNodeId = shift;

  $self->{output}->writeMessageBegin('RemoveAssociation', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RemoveAssociation_args();
  $args->{_homeId} = $_homeId;
  $args->{_nodeId} = $_nodeId;
  $args->{_groupIdx} = $_groupIdx;
  $args->{_targetNodeId} = $_targetNodeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RemoveAssociation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RemoveAssociation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub ResetController{
  my $self = shift;
  my $_homeId = shift;

    $self->send_ResetController($_homeId);
  $self->recv_ResetController();
}

sub send_ResetController{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('ResetController', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_ResetController_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ResetController{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_ResetController_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SoftReset{
  my $self = shift;
  my $_homeId = shift;

    $self->send_SoftReset($_homeId);
  $self->recv_SoftReset();
}

sub send_SoftReset{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('SoftReset', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SoftReset_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SoftReset{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SoftReset_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub BeginControllerCommand{
  my $self = shift;
  my $_homeId = shift;
  my $_command = shift;
  my $_highPower = shift;
  my $_nodeId = shift;
  my $_arg = shift;

    $self->send_BeginControllerCommand($_homeId, $_command, $_highPower, $_nodeId, $_arg);
  return $self->recv_BeginControllerCommand();
}

sub send_BeginControllerCommand{
  my $self = shift;
  my $_homeId = shift;
  my $_command = shift;
  my $_highPower = shift;
  my $_nodeId = shift;
  my $_arg = shift;

  $self->{output}->writeMessageBegin('BeginControllerCommand', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_BeginControllerCommand_args();
  $args->{_homeId} = $_homeId;
  $args->{_command} = $_command;
  $args->{_highPower} = $_highPower;
  $args->{_nodeId} = $_nodeId;
  $args->{_arg} = $_arg;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_BeginControllerCommand{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_BeginControllerCommand_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "BeginControllerCommand failed: unknown result";
}
sub CancelControllerCommand{
  my $self = shift;
  my $_homeId = shift;

    $self->send_CancelControllerCommand($_homeId);
  return $self->recv_CancelControllerCommand();
}

sub send_CancelControllerCommand{
  my $self = shift;
  my $_homeId = shift;

  $self->{output}->writeMessageBegin('CancelControllerCommand', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_CancelControllerCommand_args();
  $args->{_homeId} = $_homeId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_CancelControllerCommand{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_CancelControllerCommand_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "CancelControllerCommand failed: unknown result";
}
sub GetNumScenes{
  my $self = shift;

    $self->send_GetNumScenes();
  return $self->recv_GetNumScenes();
}

sub send_GetNumScenes{
  my $self = shift;

  $self->{output}->writeMessageBegin('GetNumScenes', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetNumScenes_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetNumScenes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetNumScenes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetNumScenes failed: unknown result";
}
sub GetAllScenes{
  my $self = shift;

    $self->send_GetAllScenes();
  return $self->recv_GetAllScenes();
}

sub send_GetAllScenes{
  my $self = shift;

  $self->{output}->writeMessageBegin('GetAllScenes', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetAllScenes_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetAllScenes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetAllScenes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetAllScenes failed: unknown result";
}
sub CreateScene{
  my $self = shift;

    $self->send_CreateScene();
  return $self->recv_CreateScene();
}

sub send_CreateScene{
  my $self = shift;

  $self->{output}->writeMessageBegin('CreateScene', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_CreateScene_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_CreateScene{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_CreateScene_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "CreateScene failed: unknown result";
}
sub RemoveScene{
  my $self = shift;
  my $_sceneId = shift;

    $self->send_RemoveScene($_sceneId);
  return $self->recv_RemoveScene();
}

sub send_RemoveScene{
  my $self = shift;
  my $_sceneId = shift;

  $self->{output}->writeMessageBegin('RemoveScene', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RemoveScene_args();
  $args->{_sceneId} = $_sceneId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RemoveScene{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RemoveScene_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "RemoveScene failed: unknown result";
}
sub AddSceneValue_Bool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValue_Bool($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValue_Bool();
}

sub send_AddSceneValue_Bool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValue_Bool', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValue_Bool_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValue_Bool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValue_Bool_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValue_Bool failed: unknown result";
}
sub AddSceneValue_Uint8{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValue_Uint8($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValue_Uint8();
}

sub send_AddSceneValue_Uint8{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValue_Uint8', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValue_Uint8_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValue_Uint8{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValue_Uint8_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValue_Uint8 failed: unknown result";
}
sub AddSceneValue_Float{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValue_Float($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValue_Float();
}

sub send_AddSceneValue_Float{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValue_Float', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValue_Float_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValue_Float{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValue_Float_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValue_Float failed: unknown result";
}
sub AddSceneValue_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValue_Int32($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValue_Int32();
}

sub send_AddSceneValue_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValue_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValue_Int32_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValue_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValue_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValue_Int32 failed: unknown result";
}
sub AddSceneValue_Int16{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValue_Int16($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValue_Int16();
}

sub send_AddSceneValue_Int16{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValue_Int16', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValue_Int16_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValue_Int16{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValue_Int16_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValue_Int16 failed: unknown result";
}
sub AddSceneValue_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValue_String($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValue_String();
}

sub send_AddSceneValue_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValue_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValue_String_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValue_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValue_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValue_String failed: unknown result";
}
sub AddSceneValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValueListSelection_String($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValueListSelection_String();
}

sub send_AddSceneValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValueListSelection_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValueListSelection_String_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValueListSelection_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValueListSelection_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValueListSelection_String failed: unknown result";
}
sub AddSceneValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_AddSceneValueListSelection_Int32($_sceneId, $_valueId, $_value);
  return $self->recv_AddSceneValueListSelection_Int32();
}

sub send_AddSceneValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('AddSceneValueListSelection_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_AddSceneValueListSelection_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "AddSceneValueListSelection_Int32 failed: unknown result";
}
sub RemoveSceneValue{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_RemoveSceneValue($_sceneId, $_valueId);
  return $self->recv_RemoveSceneValue();
}

sub send_RemoveSceneValue{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('RemoveSceneValue', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_RemoveSceneValue_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_RemoveSceneValue{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_RemoveSceneValue_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "RemoveSceneValue failed: unknown result";
}
sub SceneGetValues{
  my $self = shift;
  my $_sceneId = shift;

    $self->send_SceneGetValues($_sceneId);
  return $self->recv_SceneGetValues();
}

sub send_SceneGetValues{
  my $self = shift;
  my $_sceneId = shift;

  $self->{output}->writeMessageBegin('SceneGetValues', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValues_args();
  $args->{_sceneId} = $_sceneId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValues{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValues_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValues failed: unknown result";
}
sub SceneGetValueAsBool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueAsBool($_sceneId, $_valueId);
  return $self->recv_SceneGetValueAsBool();
}

sub send_SceneGetValueAsBool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueAsBool', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueAsBool_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueAsBool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueAsBool_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueAsBool failed: unknown result";
}
sub SceneGetValueAsByte{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueAsByte($_sceneId, $_valueId);
  return $self->recv_SceneGetValueAsByte();
}

sub send_SceneGetValueAsByte{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueAsByte', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueAsByte_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueAsByte{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueAsByte_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueAsByte failed: unknown result";
}
sub SceneGetValueAsFloat{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueAsFloat($_sceneId, $_valueId);
  return $self->recv_SceneGetValueAsFloat();
}

sub send_SceneGetValueAsFloat{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueAsFloat', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueAsFloat_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueAsFloat{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueAsFloat_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueAsFloat failed: unknown result";
}
sub SceneGetValueAsInt{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueAsInt($_sceneId, $_valueId);
  return $self->recv_SceneGetValueAsInt();
}

sub send_SceneGetValueAsInt{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueAsInt', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueAsInt_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueAsInt{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueAsInt_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueAsInt failed: unknown result";
}
sub SceneGetValueAsShort{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueAsShort($_sceneId, $_valueId);
  return $self->recv_SceneGetValueAsShort();
}

sub send_SceneGetValueAsShort{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueAsShort', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueAsShort_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueAsShort{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueAsShort_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueAsShort failed: unknown result";
}
sub SceneGetValueAsString{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueAsString($_sceneId, $_valueId);
  return $self->recv_SceneGetValueAsString();
}

sub send_SceneGetValueAsString{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueAsString', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueAsString_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueAsString{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueAsString_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueAsString failed: unknown result";
}
sub SceneGetValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueListSelection_String($_sceneId, $_valueId);
  return $self->recv_SceneGetValueListSelection_String();
}

sub send_SceneGetValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueListSelection_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueListSelection_String_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueListSelection_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueListSelection_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueListSelection_String failed: unknown result";
}
sub SceneGetValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

    $self->send_SceneGetValueListSelection_Int32($_sceneId, $_valueId);
  return $self->recv_SceneGetValueListSelection_Int32();
}

sub send_SceneGetValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;

  $self->{output}->writeMessageBegin('SceneGetValueListSelection_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneGetValueListSelection_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneGetValueListSelection_Int32 failed: unknown result";
}
sub SetSceneValue_Bool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValue_Bool($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValue_Bool();
}

sub send_SetSceneValue_Bool{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValue_Bool', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValue_Bool_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValue_Bool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValue_Bool_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValue_Bool failed: unknown result";
}
sub SetSceneValue_Uint8{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValue_Uint8($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValue_Uint8();
}

sub send_SetSceneValue_Uint8{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValue_Uint8', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValue_Uint8_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValue_Uint8{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValue_Uint8_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValue_Uint8 failed: unknown result";
}
sub SetSceneValue_Float{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValue_Float($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValue_Float();
}

sub send_SetSceneValue_Float{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValue_Float', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValue_Float_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValue_Float{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValue_Float_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValue_Float failed: unknown result";
}
sub SetSceneValue_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValue_Int32($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValue_Int32();
}

sub send_SetSceneValue_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValue_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValue_Int32_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValue_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValue_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValue_Int32 failed: unknown result";
}
sub SetSceneValue_Int16{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValue_Int16($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValue_Int16();
}

sub send_SetSceneValue_Int16{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValue_Int16', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValue_Int16_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValue_Int16{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValue_Int16_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValue_Int16 failed: unknown result";
}
sub SetSceneValue_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValue_String($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValue_String();
}

sub send_SetSceneValue_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValue_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValue_String_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValue_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValue_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValue_String failed: unknown result";
}
sub SetSceneValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValueListSelection_String($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValueListSelection_String();
}

sub send_SetSceneValueListSelection_String{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValueListSelection_String', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValueListSelection_String_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValueListSelection_String{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValueListSelection_String_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValueListSelection_String failed: unknown result";
}
sub SetSceneValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

    $self->send_SetSceneValueListSelection_Int32($_sceneId, $_valueId, $_value);
  return $self->recv_SetSceneValueListSelection_Int32();
}

sub send_SetSceneValueListSelection_Int32{
  my $self = shift;
  my $_sceneId = shift;
  my $_valueId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneValueListSelection_Int32', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_valueId} = $_valueId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneValueListSelection_Int32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SetSceneValueListSelection_Int32 failed: unknown result";
}
sub GetSceneLabel{
  my $self = shift;
  my $_sceneId = shift;

    $self->send_GetSceneLabel($_sceneId);
  return $self->recv_GetSceneLabel();
}

sub send_GetSceneLabel{
  my $self = shift;
  my $_sceneId = shift;

  $self->{output}->writeMessageBegin('GetSceneLabel', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_GetSceneLabel_args();
  $args->{_sceneId} = $_sceneId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_GetSceneLabel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_GetSceneLabel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "GetSceneLabel failed: unknown result";
}
sub SetSceneLabel{
  my $self = shift;
  my $_sceneId = shift;
  my $_value = shift;

    $self->send_SetSceneLabel($_sceneId, $_value);
  $self->recv_SetSceneLabel();
}

sub send_SetSceneLabel{
  my $self = shift;
  my $_sceneId = shift;
  my $_value = shift;

  $self->{output}->writeMessageBegin('SetSceneLabel', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SetSceneLabel_args();
  $args->{_sceneId} = $_sceneId;
  $args->{_value} = $_value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SetSceneLabel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SetSceneLabel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub SceneExists{
  my $self = shift;
  my $_sceneId = shift;

    $self->send_SceneExists($_sceneId);
  return $self->recv_SceneExists();
}

sub send_SceneExists{
  my $self = shift;
  my $_sceneId = shift;

  $self->{output}->writeMessageBegin('SceneExists', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SceneExists_args();
  $args->{_sceneId} = $_sceneId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SceneExists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SceneExists_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "SceneExists failed: unknown result";
}
sub ActivateScene{
  my $self = shift;
  my $_sceneId = shift;

    $self->send_ActivateScene($_sceneId);
  return $self->recv_ActivateScene();
}

sub send_ActivateScene{
  my $self = shift;
  my $_sceneId = shift;

  $self->{output}->writeMessageBegin('ActivateScene', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_ActivateScene_args();
  $args->{_sceneId} = $_sceneId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ActivateScene{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_ActivateScene_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "ActivateScene failed: unknown result";
}
sub SendAllValues{
  my $self = shift;

    $self->send_SendAllValues();
  $self->recv_SendAllValues();
}

sub send_SendAllValues{
  my $self = shift;

  $self->{output}->writeMessageBegin('SendAllValues', TMessageType::CALL, $self->{seqid});
  my $args = new OpenZWave::RemoteManager_SendAllValues_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_SendAllValues{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OpenZWave::RemoteManager_SendAllValues_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
package OpenZWave::RemoteManagerProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_WriteConfig {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_WriteConfig_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_WriteConfig_result();
    $self->{handler}->WriteConfig($args->_homeId);
    $output->writeMessageBegin('WriteConfig', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetControllerNodeId {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetControllerNodeId_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetControllerNodeId_result();
    $result->{success} = $self->{handler}->GetControllerNodeId($args->_homeId);
    $output->writeMessageBegin('GetControllerNodeId', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsPrimaryController {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsPrimaryController_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsPrimaryController_result();
    $result->{success} = $self->{handler}->IsPrimaryController($args->_homeId);
    $output->writeMessageBegin('IsPrimaryController', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsStaticUpdateController {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsStaticUpdateController_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsStaticUpdateController_result();
    $result->{success} = $self->{handler}->IsStaticUpdateController($args->_homeId);
    $output->writeMessageBegin('IsStaticUpdateController', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsBridgeController {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsBridgeController_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsBridgeController_result();
    $result->{success} = $self->{handler}->IsBridgeController($args->_homeId);
    $output->writeMessageBegin('IsBridgeController', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetLibraryVersion {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetLibraryVersion_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetLibraryVersion_result();
    $result->{success} = $self->{handler}->GetLibraryVersion($args->_homeId);
    $output->writeMessageBegin('GetLibraryVersion', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetLibraryTypeName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetLibraryTypeName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetLibraryTypeName_result();
    $result->{success} = $self->{handler}->GetLibraryTypeName($args->_homeId);
    $output->writeMessageBegin('GetLibraryTypeName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetSendQueueCount {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetSendQueueCount_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetSendQueueCount_result();
    $result->{success} = $self->{handler}->GetSendQueueCount($args->_homeId);
    $output->writeMessageBegin('GetSendQueueCount', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetPollInterval {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetPollInterval_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetPollInterval_result();
    $result->{success} = $self->{handler}->GetPollInterval();
    $output->writeMessageBegin('GetPollInterval', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetPollInterval {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetPollInterval_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetPollInterval_result();
    $self->{handler}->SetPollInterval($args->_seconds);
    $output->writeMessageBegin('SetPollInterval', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_EnablePoll {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_EnablePoll_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_EnablePoll_result();
    $result->{success} = $self->{handler}->EnablePoll($args->_valueId);
    $output->writeMessageBegin('EnablePoll', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_DisablePoll {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_DisablePoll_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_DisablePoll_result();
    $result->{success} = $self->{handler}->DisablePoll($args->_valueId);
    $output->writeMessageBegin('DisablePoll', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isPolled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_isPolled_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_isPolled_result();
    $result->{success} = $self->{handler}->isPolled($args->_valueId);
    $output->writeMessageBegin('isPolled', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RefreshNodeInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RefreshNodeInfo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RefreshNodeInfo_result();
    $result->{success} = $self->{handler}->RefreshNodeInfo($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('RefreshNodeInfo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RequestNodeState {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RequestNodeState_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RequestNodeState_result();
    $result->{success} = $self->{handler}->RequestNodeState($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('RequestNodeState', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RequestNodeDynamic {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RequestNodeDynamic_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RequestNodeDynamic_result();
    $result->{success} = $self->{handler}->RequestNodeDynamic($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('RequestNodeDynamic', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsNodeListeningDevice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsNodeListeningDevice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsNodeListeningDevice_result();
    $result->{success} = $self->{handler}->IsNodeListeningDevice($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('IsNodeListeningDevice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsNodeFrequentListeningDevice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsNodeFrequentListeningDevice_result();
    $result->{success} = $self->{handler}->IsNodeFrequentListeningDevice($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('IsNodeFrequentListeningDevice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsNodeBeamingDevice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsNodeBeamingDevice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsNodeBeamingDevice_result();
    $result->{success} = $self->{handler}->IsNodeBeamingDevice($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('IsNodeBeamingDevice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsNodeRoutingDevice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsNodeRoutingDevice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsNodeRoutingDevice_result();
    $result->{success} = $self->{handler}->IsNodeRoutingDevice($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('IsNodeRoutingDevice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsNodeSecurityDevice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsNodeSecurityDevice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsNodeSecurityDevice_result();
    $result->{success} = $self->{handler}->IsNodeSecurityDevice($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('IsNodeSecurityDevice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeMaxBaudRate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeMaxBaudRate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeMaxBaudRate_result();
    $result->{success} = $self->{handler}->GetNodeMaxBaudRate($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeMaxBaudRate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeVersion {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeVersion_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeVersion_result();
    $result->{success} = $self->{handler}->GetNodeVersion($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeVersion', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeBasic {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeBasic_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeBasic_result();
    $result->{success} = $self->{handler}->GetNodeBasic($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeBasic', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeGeneric {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeGeneric_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeGeneric_result();
    $result->{success} = $self->{handler}->GetNodeGeneric($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeGeneric', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeSpecific {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeSpecific_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeSpecific_result();
    $result->{success} = $self->{handler}->GetNodeSpecific($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeSpecific', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeType {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeType_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeType_result();
    $result->{success} = $self->{handler}->GetNodeType($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeType', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeNeighbors {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeNeighbors_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeNeighbors_result();
    $result->{success} = $self->{handler}->GetNodeNeighbors($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeNeighbors', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeManufacturerName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeManufacturerName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeManufacturerName_result();
    $result->{success} = $self->{handler}->GetNodeManufacturerName($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeManufacturerName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeProductName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeProductName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeProductName_result();
    $result->{success} = $self->{handler}->GetNodeProductName($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeProductName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeName_result();
    $result->{success} = $self->{handler}->GetNodeName($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeLocation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeLocation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeLocation_result();
    $result->{success} = $self->{handler}->GetNodeLocation($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeLocation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeManufacturerId {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeManufacturerId_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeManufacturerId_result();
    $result->{success} = $self->{handler}->GetNodeManufacturerId($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeManufacturerId', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeProductType {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeProductType_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeProductType_result();
    $result->{success} = $self->{handler}->GetNodeProductType($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeProductType', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeProductId {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeProductId_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeProductId_result();
    $result->{success} = $self->{handler}->GetNodeProductId($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNodeProductId', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeManufacturerName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeManufacturerName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeManufacturerName_result();
    $self->{handler}->SetNodeManufacturerName($args->_homeId, $args->_nodeId, $args->_manufacturerName);
    $output->writeMessageBegin('SetNodeManufacturerName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeProductName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeProductName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeProductName_result();
    $self->{handler}->SetNodeProductName($args->_homeId, $args->_nodeId, $args->_productName);
    $output->writeMessageBegin('SetNodeProductName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeName {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeName_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeName_result();
    $self->{handler}->SetNodeName($args->_homeId, $args->_nodeId, $args->_nodeName);
    $output->writeMessageBegin('SetNodeName', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeLocation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeLocation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeLocation_result();
    $self->{handler}->SetNodeLocation($args->_homeId, $args->_nodeId, $args->_location);
    $output->writeMessageBegin('SetNodeLocation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeOn {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeOn_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeOn_result();
    $self->{handler}->SetNodeOn($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('SetNodeOn', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeOff {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeOff_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeOff_result();
    $self->{handler}->SetNodeOff($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('SetNodeOff', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetNodeLevel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetNodeLevel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetNodeLevel_result();
    $self->{handler}->SetNodeLevel($args->_homeId, $args->_nodeId, $args->_level);
    $output->writeMessageBegin('SetNodeLevel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsNodeInfoReceived {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsNodeInfoReceived_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsNodeInfoReceived_result();
    $result->{success} = $self->{handler}->IsNodeInfoReceived($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('IsNodeInfoReceived', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNodeClassInformation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNodeClassInformation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNodeClassInformation_result();
    $result->{success} = $self->{handler}->GetNodeClassInformation($args->_homeId, $args->_nodeId, $args->_commandClassId);
    $output->writeMessageBegin('GetNodeClassInformation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueLabel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueLabel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueLabel_result();
    $result->{success} = $self->{handler}->GetValueLabel($args->_id);
    $output->writeMessageBegin('GetValueLabel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValueLabel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValueLabel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValueLabel_result();
    $self->{handler}->SetValueLabel($args->_id, $args->_value);
    $output->writeMessageBegin('SetValueLabel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueUnits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueUnits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueUnits_result();
    $result->{success} = $self->{handler}->GetValueUnits($args->_id);
    $output->writeMessageBegin('GetValueUnits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValueUnits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValueUnits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValueUnits_result();
    $self->{handler}->SetValueUnits($args->_id, $args->_value);
    $output->writeMessageBegin('SetValueUnits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueHelp {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueHelp_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueHelp_result();
    $result->{success} = $self->{handler}->GetValueHelp($args->_id);
    $output->writeMessageBegin('GetValueHelp', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValueHelp {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValueHelp_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValueHelp_result();
    $self->{handler}->SetValueHelp($args->_id, $args->_value);
    $output->writeMessageBegin('SetValueHelp', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueMin {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueMin_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueMin_result();
    $result->{success} = $self->{handler}->GetValueMin($args->_id);
    $output->writeMessageBegin('GetValueMin', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueMax {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueMax_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueMax_result();
    $result->{success} = $self->{handler}->GetValueMax($args->_id);
    $output->writeMessageBegin('GetValueMax', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsValueReadOnly {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsValueReadOnly_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsValueReadOnly_result();
    $result->{success} = $self->{handler}->IsValueReadOnly($args->_id);
    $output->writeMessageBegin('IsValueReadOnly', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsValueWriteOnly {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsValueWriteOnly_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsValueWriteOnly_result();
    $result->{success} = $self->{handler}->IsValueWriteOnly($args->_id);
    $output->writeMessageBegin('IsValueWriteOnly', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_IsValueSet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_IsValueSet_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_IsValueSet_result();
    $result->{success} = $self->{handler}->IsValueSet($args->_id);
    $output->writeMessageBegin('IsValueSet', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueAsBool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueAsBool_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueAsBool_result();
    $result->{success} = $self->{handler}->GetValueAsBool($args->_id);
    $output->writeMessageBegin('GetValueAsBool', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueAsByte {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueAsByte_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueAsByte_result();
    $result->{success} = $self->{handler}->GetValueAsByte($args->_id);
    $output->writeMessageBegin('GetValueAsByte', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueAsFloat {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueAsFloat_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueAsFloat_result();
    $result->{success} = $self->{handler}->GetValueAsFloat($args->_id);
    $output->writeMessageBegin('GetValueAsFloat', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueAsInt {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueAsInt_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueAsInt_result();
    $result->{success} = $self->{handler}->GetValueAsInt($args->_id);
    $output->writeMessageBegin('GetValueAsInt', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueAsShort {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueAsShort_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueAsShort_result();
    $result->{success} = $self->{handler}->GetValueAsShort($args->_id);
    $output->writeMessageBegin('GetValueAsShort', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueAsString {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueAsString_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueAsString_result();
    $result->{success} = $self->{handler}->GetValueAsString($args->_id);
    $output->writeMessageBegin('GetValueAsString', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueListSelection_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueListSelection_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueListSelection_String_result();
    $result->{success} = $self->{handler}->GetValueListSelection_String($args->_id);
    $output->writeMessageBegin('GetValueListSelection_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueListSelection_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueListSelection_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueListSelection_Int32_result();
    $result->{success} = $self->{handler}->GetValueListSelection_Int32($args->_id);
    $output->writeMessageBegin('GetValueListSelection_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueListItems {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueListItems_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueListItems_result();
    $result->{success} = $self->{handler}->GetValueListItems($args->_id);
    $output->writeMessageBegin('GetValueListItems', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetValueFloatPrecision {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetValueFloatPrecision_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetValueFloatPrecision_result();
    $result->{success} = $self->{handler}->GetValueFloatPrecision($args->_id);
    $output->writeMessageBegin('GetValueFloatPrecision', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValue_Bool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValue_Bool_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValue_Bool_result();
    $result->{success} = $self->{handler}->SetValue_Bool($args->_id, $args->_value);
    $output->writeMessageBegin('SetValue_Bool', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValue_UInt8 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValue_UInt8_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValue_UInt8_result();
    $result->{success} = $self->{handler}->SetValue_UInt8($args->_id, $args->_value);
    $output->writeMessageBegin('SetValue_UInt8', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValue_Float {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValue_Float_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValue_Float_result();
    $result->{success} = $self->{handler}->SetValue_Float($args->_id, $args->_value);
    $output->writeMessageBegin('SetValue_Float', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValue_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValue_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValue_Int32_result();
    $result->{success} = $self->{handler}->SetValue_Int32($args->_id, $args->_value);
    $output->writeMessageBegin('SetValue_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValue_Int16 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValue_Int16_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValue_Int16_result();
    $result->{success} = $self->{handler}->SetValue_Int16($args->_id, $args->_value);
    $output->writeMessageBegin('SetValue_Int16', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValue_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValue_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValue_String_result();
    $result->{success} = $self->{handler}->SetValue_String($args->_id, $args->_value);
    $output->writeMessageBegin('SetValue_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetValueListSelection {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetValueListSelection_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetValueListSelection_result();
    $result->{success} = $self->{handler}->SetValueListSelection($args->_id, $args->_selectedItem);
    $output->writeMessageBegin('SetValueListSelection', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_PressButton {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_PressButton_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_PressButton_result();
    $result->{success} = $self->{handler}->PressButton($args->_id);
    $output->writeMessageBegin('PressButton', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_ReleaseButton {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_ReleaseButton_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_ReleaseButton_result();
    $result->{success} = $self->{handler}->ReleaseButton($args->_id);
    $output->writeMessageBegin('ReleaseButton', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNumSwitchPoints {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNumSwitchPoints_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNumSwitchPoints_result();
    $result->{success} = $self->{handler}->GetNumSwitchPoints($args->_id);
    $output->writeMessageBegin('GetNumSwitchPoints', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSwitchPoint {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSwitchPoint_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSwitchPoint_result();
    $result->{success} = $self->{handler}->SetSwitchPoint($args->_id, $args->_hours, $args->_minutes, $args->_setback);
    $output->writeMessageBegin('SetSwitchPoint', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RemoveSwitchPoint {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RemoveSwitchPoint_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RemoveSwitchPoint_result();
    $result->{success} = $self->{handler}->RemoveSwitchPoint($args->_id, $args->_hours, $args->_minutes);
    $output->writeMessageBegin('RemoveSwitchPoint', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_ClearSwitchPoints {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_ClearSwitchPoints_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_ClearSwitchPoints_result();
    $self->{handler}->ClearSwitchPoints($args->_id);
    $output->writeMessageBegin('ClearSwitchPoints', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetSwitchPoint {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetSwitchPoint_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetSwitchPoint_result();
    $result->{success} = $self->{handler}->GetSwitchPoint($args->_id, $args->_idx);
    $output->writeMessageBegin('GetSwitchPoint', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SwitchAllOn {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SwitchAllOn_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SwitchAllOn_result();
    $self->{handler}->SwitchAllOn($args->_homeId);
    $output->writeMessageBegin('SwitchAllOn', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SwitchAllOff {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SwitchAllOff_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SwitchAllOff_result();
    $self->{handler}->SwitchAllOff($args->_homeId);
    $output->writeMessageBegin('SwitchAllOff', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetConfigParam {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetConfigParam_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetConfigParam_result();
    $result->{success} = $self->{handler}->SetConfigParam($args->_homeId, $args->_nodeId, $args->_param, $args->_value, $args->_size);
    $output->writeMessageBegin('SetConfigParam', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RequestConfigParam {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RequestConfigParam_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RequestConfigParam_result();
    $self->{handler}->RequestConfigParam($args->_homeId, $args->_nodeId, $args->_param);
    $output->writeMessageBegin('RequestConfigParam', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RequestAllConfigParams {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RequestAllConfigParams_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RequestAllConfigParams_result();
    $self->{handler}->RequestAllConfigParams($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('RequestAllConfigParams', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNumGroups {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNumGroups_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNumGroups_result();
    $result->{success} = $self->{handler}->GetNumGroups($args->_homeId, $args->_nodeId);
    $output->writeMessageBegin('GetNumGroups', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetAssociations {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetAssociations_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetAssociations_result();
    $result->{success} = $self->{handler}->GetAssociations($args->_homeId, $args->_nodeId, $args->_groupIdx);
    $output->writeMessageBegin('GetAssociations', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetMaxAssociations {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetMaxAssociations_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetMaxAssociations_result();
    $result->{success} = $self->{handler}->GetMaxAssociations($args->_homeId, $args->_nodeId, $args->_groupIdx);
    $output->writeMessageBegin('GetMaxAssociations', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetGroupLabel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetGroupLabel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetGroupLabel_result();
    $result->{success} = $self->{handler}->GetGroupLabel($args->_homeId, $args->_nodeId, $args->_groupIdx);
    $output->writeMessageBegin('GetGroupLabel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddAssociation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddAssociation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddAssociation_result();
    $self->{handler}->AddAssociation($args->_homeId, $args->_nodeId, $args->_groupIdx, $args->_targetNodeId);
    $output->writeMessageBegin('AddAssociation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RemoveAssociation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RemoveAssociation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RemoveAssociation_result();
    $self->{handler}->RemoveAssociation($args->_homeId, $args->_nodeId, $args->_groupIdx, $args->_targetNodeId);
    $output->writeMessageBegin('RemoveAssociation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_ResetController {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_ResetController_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_ResetController_result();
    $self->{handler}->ResetController($args->_homeId);
    $output->writeMessageBegin('ResetController', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SoftReset {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SoftReset_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SoftReset_result();
    $self->{handler}->SoftReset($args->_homeId);
    $output->writeMessageBegin('SoftReset', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_BeginControllerCommand {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_BeginControllerCommand_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_BeginControllerCommand_result();
    $result->{success} = $self->{handler}->BeginControllerCommand($args->_homeId, $args->_command, $args->_highPower, $args->_nodeId, $args->_arg);
    $output->writeMessageBegin('BeginControllerCommand', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_CancelControllerCommand {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_CancelControllerCommand_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_CancelControllerCommand_result();
    $result->{success} = $self->{handler}->CancelControllerCommand($args->_homeId);
    $output->writeMessageBegin('CancelControllerCommand', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetNumScenes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetNumScenes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetNumScenes_result();
    $result->{success} = $self->{handler}->GetNumScenes();
    $output->writeMessageBegin('GetNumScenes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetAllScenes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetAllScenes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetAllScenes_result();
    $result->{success} = $self->{handler}->GetAllScenes();
    $output->writeMessageBegin('GetAllScenes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_CreateScene {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_CreateScene_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_CreateScene_result();
    $result->{success} = $self->{handler}->CreateScene();
    $output->writeMessageBegin('CreateScene', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RemoveScene {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RemoveScene_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RemoveScene_result();
    $result->{success} = $self->{handler}->RemoveScene($args->_sceneId);
    $output->writeMessageBegin('RemoveScene', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValue_Bool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValue_Bool_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValue_Bool_result();
    $result->{success} = $self->{handler}->AddSceneValue_Bool($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValue_Bool', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValue_Uint8 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValue_Uint8_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValue_Uint8_result();
    $result->{success} = $self->{handler}->AddSceneValue_Uint8($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValue_Uint8', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValue_Float {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValue_Float_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValue_Float_result();
    $result->{success} = $self->{handler}->AddSceneValue_Float($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValue_Float', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValue_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValue_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValue_Int32_result();
    $result->{success} = $self->{handler}->AddSceneValue_Int32($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValue_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValue_Int16 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValue_Int16_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValue_Int16_result();
    $result->{success} = $self->{handler}->AddSceneValue_Int16($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValue_Int16', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValue_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValue_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValue_String_result();
    $result->{success} = $self->{handler}->AddSceneValue_String($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValue_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValueListSelection_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValueListSelection_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValueListSelection_String_result();
    $result->{success} = $self->{handler}->AddSceneValueListSelection_String($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValueListSelection_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_AddSceneValueListSelection_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_AddSceneValueListSelection_Int32_result();
    $result->{success} = $self->{handler}->AddSceneValueListSelection_Int32($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('AddSceneValueListSelection_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_RemoveSceneValue {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_RemoveSceneValue_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_RemoveSceneValue_result();
    $result->{success} = $self->{handler}->RemoveSceneValue($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('RemoveSceneValue', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValues {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValues_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValues_result();
    $result->{success} = $self->{handler}->SceneGetValues($args->_sceneId);
    $output->writeMessageBegin('SceneGetValues', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueAsBool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueAsBool_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueAsBool_result();
    $result->{success} = $self->{handler}->SceneGetValueAsBool($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueAsBool', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueAsByte {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueAsByte_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueAsByte_result();
    $result->{success} = $self->{handler}->SceneGetValueAsByte($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueAsByte', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueAsFloat {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueAsFloat_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueAsFloat_result();
    $result->{success} = $self->{handler}->SceneGetValueAsFloat($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueAsFloat', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueAsInt {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueAsInt_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueAsInt_result();
    $result->{success} = $self->{handler}->SceneGetValueAsInt($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueAsInt', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueAsShort {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueAsShort_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueAsShort_result();
    $result->{success} = $self->{handler}->SceneGetValueAsShort($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueAsShort', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueAsString {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueAsString_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueAsString_result();
    $result->{success} = $self->{handler}->SceneGetValueAsString($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueAsString', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueListSelection_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueListSelection_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueListSelection_String_result();
    $result->{success} = $self->{handler}->SceneGetValueListSelection_String($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueListSelection_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneGetValueListSelection_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneGetValueListSelection_Int32_result();
    $result->{success} = $self->{handler}->SceneGetValueListSelection_Int32($args->_sceneId, $args->_valueId);
    $output->writeMessageBegin('SceneGetValueListSelection_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValue_Bool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValue_Bool_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValue_Bool_result();
    $result->{success} = $self->{handler}->SetSceneValue_Bool($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValue_Bool', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValue_Uint8 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValue_Uint8_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValue_Uint8_result();
    $result->{success} = $self->{handler}->SetSceneValue_Uint8($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValue_Uint8', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValue_Float {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValue_Float_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValue_Float_result();
    $result->{success} = $self->{handler}->SetSceneValue_Float($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValue_Float', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValue_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValue_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValue_Int32_result();
    $result->{success} = $self->{handler}->SetSceneValue_Int32($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValue_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValue_Int16 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValue_Int16_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValue_Int16_result();
    $result->{success} = $self->{handler}->SetSceneValue_Int16($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValue_Int16', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValue_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValue_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValue_String_result();
    $result->{success} = $self->{handler}->SetSceneValue_String($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValue_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValueListSelection_String {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValueListSelection_String_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValueListSelection_String_result();
    $result->{success} = $self->{handler}->SetSceneValueListSelection_String($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValueListSelection_String', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneValueListSelection_Int32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneValueListSelection_Int32_result();
    $result->{success} = $self->{handler}->SetSceneValueListSelection_Int32($args->_sceneId, $args->_valueId, $args->_value);
    $output->writeMessageBegin('SetSceneValueListSelection_Int32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_GetSceneLabel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_GetSceneLabel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_GetSceneLabel_result();
    $result->{success} = $self->{handler}->GetSceneLabel($args->_sceneId);
    $output->writeMessageBegin('GetSceneLabel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SetSceneLabel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SetSceneLabel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SetSceneLabel_result();
    $self->{handler}->SetSceneLabel($args->_sceneId, $args->_value);
    $output->writeMessageBegin('SetSceneLabel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SceneExists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SceneExists_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SceneExists_result();
    $result->{success} = $self->{handler}->SceneExists($args->_sceneId);
    $output->writeMessageBegin('SceneExists', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_ActivateScene {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_ActivateScene_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_ActivateScene_result();
    $result->{success} = $self->{handler}->ActivateScene($args->_sceneId);
    $output->writeMessageBegin('ActivateScene', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_SendAllValues {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OpenZWave::RemoteManager_SendAllValues_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OpenZWave::RemoteManager_SendAllValues_result();
    $self->{handler}->SendAllValues();
    $output->writeMessageBegin('SendAllValues', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
