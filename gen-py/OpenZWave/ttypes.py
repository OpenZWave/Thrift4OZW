#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class RemoteValueGenre:
  ValueGenre_Basic = 0
  ValueGenre_User = 1
  ValueGenre_Config = 2
  ValueGenre_System = 3
  ValueGenre_Count = 4

  _VALUES_TO_NAMES = {
    0: "ValueGenre_Basic",
    1: "ValueGenre_User",
    2: "ValueGenre_Config",
    3: "ValueGenre_System",
    4: "ValueGenre_Count",
  }

  _NAMES_TO_VALUES = {
    "ValueGenre_Basic": 0,
    "ValueGenre_User": 1,
    "ValueGenre_Config": 2,
    "ValueGenre_System": 3,
    "ValueGenre_Count": 4,
  }

class RemoteValueType:
  ValueType_Bool = 0
  ValueType_Byte = 1
  ValueType_Decimal = 2
  ValueType_Int = 3
  ValueType_List = 4
  ValueType_Schedule = 5
  ValueType_Short = 6
  ValueType_String = 7
  ValueType_Button = 8
  ValueType_Max = 8

  _VALUES_TO_NAMES = {
    0: "ValueType_Bool",
    1: "ValueType_Byte",
    2: "ValueType_Decimal",
    3: "ValueType_Int",
    4: "ValueType_List",
    5: "ValueType_Schedule",
    6: "ValueType_Short",
    7: "ValueType_String",
    8: "ValueType_Button",
    8: "ValueType_Max",
  }

  _NAMES_TO_VALUES = {
    "ValueType_Bool": 0,
    "ValueType_Byte": 1,
    "ValueType_Decimal": 2,
    "ValueType_Int": 3,
    "ValueType_List": 4,
    "ValueType_Schedule": 5,
    "ValueType_Short": 6,
    "ValueType_String": 7,
    "ValueType_Button": 8,
    "ValueType_Max": 8,
  }


class RemoteValueID:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _genre
   - _commandClassId
   - _instance
   - _valueIndex
   - _type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.I32, '_genre', None, None, ), # 3
    (4, TType.BYTE, '_commandClassId', None, None, ), # 4
    (5, TType.BYTE, '_instance', None, None, ), # 5
    (6, TType.BYTE, '_valueIndex', None, None, ), # 6
    (7, TType.I32, '_type', None, None, ), # 7
  )

  def __init__(self, _homeId=None, _nodeId=None, _genre=None, _commandClassId=None, _instance=None, _valueIndex=None, _type=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._genre = _genre
    self._commandClassId = _commandClassId
    self._instance = _instance
    self._valueIndex = _valueIndex
    self._type = _type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._genre = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._commandClassId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self._instance = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self._valueIndex = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self._type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoteValueID')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._genre is not None:
      oprot.writeFieldBegin('_genre', TType.I32, 3)
      oprot.writeI32(self._genre)
      oprot.writeFieldEnd()
    if self._commandClassId is not None:
      oprot.writeFieldBegin('_commandClassId', TType.BYTE, 4)
      oprot.writeByte(self._commandClassId)
      oprot.writeFieldEnd()
    if self._instance is not None:
      oprot.writeFieldBegin('_instance', TType.BYTE, 5)
      oprot.writeByte(self._instance)
      oprot.writeFieldEnd()
    if self._valueIndex is not None:
      oprot.writeFieldBegin('_valueIndex', TType.BYTE, 6)
      oprot.writeByte(self._valueIndex)
      oprot.writeFieldEnd()
    if self._type is not None:
      oprot.writeFieldBegin('_type', TType.I32, 7)
      oprot.writeI32(self._type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSwitchPointReturnStruct:
  """
  Attributes:
   - retval
   - o_hours
   - o_minutes
   - o_setback
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.BYTE, 'o_hours', None, None, ), # 2
    (3, TType.BYTE, 'o_minutes', None, None, ), # 3
    (4, TType.BYTE, 'o_setback', None, None, ), # 4
  )

  def __init__(self, retval=None, o_hours=None, o_minutes=None, o_setback=None,):
    self.retval = retval
    self.o_hours = o_hours
    self.o_minutes = o_minutes
    self.o_setback = o_setback

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.o_hours = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.o_minutes = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.o_setback = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSwitchPointReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_hours is not None:
      oprot.writeFieldBegin('o_hours', TType.BYTE, 2)
      oprot.writeByte(self.o_hours)
      oprot.writeFieldEnd()
    if self.o_minutes is not None:
      oprot.writeFieldBegin('o_minutes', TType.BYTE, 3)
      oprot.writeByte(self.o_minutes)
      oprot.writeFieldEnd()
    if self.o_setback is not None:
      oprot.writeFieldBegin('o_setback', TType.BYTE, 4)
      oprot.writeByte(self.o_setback)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Bool:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.BOOL, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.o_value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Bool')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.BOOL, 2)
      oprot.writeBool(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_UInt8:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.BYTE, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.o_value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_UInt8')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.BYTE, 2)
      oprot.writeByte(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Float:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.DOUBLE, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.o_value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Float')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.DOUBLE, 2)
      oprot.writeDouble(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Int:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.I32, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.o_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Int')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.I32, 2)
      oprot.writeI32(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Int16:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.I16, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.o_value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Int16')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.I16, 2)
      oprot.writeI16(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_String:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.STRING, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.o_value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_String')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.STRING, 2)
      oprot.writeString(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_ListString:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.LIST, 'o_value', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.o_value = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.o_value.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_ListString')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.o_value))
      for iter6 in self.o_value:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UInt32_ListByte:
  """
  Attributes:
   - retval
   - _nodeNeighbors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'retval', None, None, ), # 1
    (2, TType.LIST, '_nodeNeighbors', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, retval=None, _nodeNeighbors=None,):
    self.retval = retval
    self._nodeNeighbors = _nodeNeighbors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self._nodeNeighbors = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readByte();
            self._nodeNeighbors.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UInt32_ListByte')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 1)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self._nodeNeighbors is not None:
      oprot.writeFieldBegin('_nodeNeighbors', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self._nodeNeighbors))
      for iter13 in self._nodeNeighbors:
        oprot.writeByte(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_GetNodeClassInformation:
  """
  Attributes:
   - retval
   - _className
   - _classVersion
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.STRING, '_className', None, None, ), # 2
    (3, TType.BYTE, '_classVersion', None, None, ), # 3
  )

  def __init__(self, retval=None, _className=None, _classVersion=None,):
    self.retval = retval
    self._className = _className
    self._classVersion = _classVersion

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._classVersion = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_GetNodeClassInformation')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self._className is not None:
      oprot.writeFieldBegin('_className', TType.STRING, 2)
      oprot.writeString(self._className)
      oprot.writeFieldEnd()
    if self._classVersion is not None:
      oprot.writeFieldBegin('_classVersion', TType.BYTE, 3)
      oprot.writeByte(self._classVersion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAssociationsReturnStruct:
  """
  Attributes:
   - retval
   - o_associations
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'retval', None, None, ), # 1
    (2, TType.LIST, 'o_associations', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, retval=None, o_associations=None,):
    self.retval = retval
    self.o_associations = o_associations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.o_associations = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readByte();
            self.o_associations.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAssociationsReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 1)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self.o_associations is not None:
      oprot.writeFieldBegin('o_associations', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self.o_associations))
      for iter20 in self.o_associations:
        oprot.writeByte(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllScenesReturnStruct:
  """
  Attributes:
   - retval
   - _sceneIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'retval', None, None, ), # 1
    (2, TType.LIST, '_sceneIds', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, retval=None, _sceneIds=None,):
    self.retval = retval
    self._sceneIds = _sceneIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.retval = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self._sceneIds = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readByte();
            self._sceneIds.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllScenesReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BYTE, 1)
      oprot.writeByte(self.retval)
      oprot.writeFieldEnd()
    if self._sceneIds is not None:
      oprot.writeFieldBegin('_sceneIds', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self._sceneIds))
      for iter27 in self._sceneIds:
        oprot.writeByte(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValuesReturnStruct:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'retval', None, None, ), # 1
    (2, TType.LIST, 'o_value', (TType.STRUCT,(RemoteValueID, RemoteValueID.thrift_spec)), None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.o_value = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = RemoteValueID()
            _elem33.read(iprot)
            self.o_value.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValuesReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 1)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.o_value))
      for iter34 in self.o_value:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
