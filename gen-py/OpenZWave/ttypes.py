#
# Autogenerated by Thrift Compiler (0.9.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class RemoteValueGenre:
  ValueGenre_Basic = 0
  ValueGenre_User = 1
  ValueGenre_Config = 2
  ValueGenre_System = 3
  ValueGenre_Count = 4

  _VALUES_TO_NAMES = {
    0: "ValueGenre_Basic",
    1: "ValueGenre_User",
    2: "ValueGenre_Config",
    3: "ValueGenre_System",
    4: "ValueGenre_Count",
  }

  _NAMES_TO_VALUES = {
    "ValueGenre_Basic": 0,
    "ValueGenre_User": 1,
    "ValueGenre_Config": 2,
    "ValueGenre_System": 3,
    "ValueGenre_Count": 4,
  }

class RemoteValueType:
  ValueType_Bool = 0
  ValueType_Byte = 1
  ValueType_Decimal = 2
  ValueType_Int = 3
  ValueType_List = 4
  ValueType_Schedule = 5
  ValueType_Short = 6
  ValueType_String = 7
  ValueType_Button = 8
  ValueType_Max = 8

  _VALUES_TO_NAMES = {
    0: "ValueType_Bool",
    1: "ValueType_Byte",
    2: "ValueType_Decimal",
    3: "ValueType_Int",
    4: "ValueType_List",
    5: "ValueType_Schedule",
    6: "ValueType_Short",
    7: "ValueType_String",
    8: "ValueType_Button",
    8: "ValueType_Max",
  }

  _NAMES_TO_VALUES = {
    "ValueType_Bool": 0,
    "ValueType_Byte": 1,
    "ValueType_Decimal": 2,
    "ValueType_Int": 3,
    "ValueType_List": 4,
    "ValueType_Schedule": 5,
    "ValueType_Short": 6,
    "ValueType_String": 7,
    "ValueType_Button": 8,
    "ValueType_Max": 8,
  }

class DriverControllerCommand:
  ControllerCommand_None = 0
  ControllerCommand_AddController = 1
  ControllerCommand_AddDevice = 2
  ControllerCommand_CreateNewPrimary = 3
  ControllerCommand_ReceiveConfiguration = 4
  ControllerCommand_RemoveController = 5
  ControllerCommand_RemoveDevice = 6
  ControllerCommand_RemoveFailedNode = 7
  ControllerCommand_HasNodeFailed = 8
  ControllerCommand_ReplaceFailedNode = 9
  ControllerCommand_TransferPrimaryRole = 10
  ControllerCommand_RequestNetworkUpdate = 11
  ControllerCommand_RequestNodeNeighborUpdate = 12
  ControllerCommand_AssignReturnRoute = 13
  ControllerCommand_DeleteAllReturnRoutes = 14
  ControllerCommand_CreateButton = 15
  ControllerCommand_DeleteButton = 16

  _VALUES_TO_NAMES = {
    0: "ControllerCommand_None",
    1: "ControllerCommand_AddController",
    2: "ControllerCommand_AddDevice",
    3: "ControllerCommand_CreateNewPrimary",
    4: "ControllerCommand_ReceiveConfiguration",
    5: "ControllerCommand_RemoveController",
    6: "ControllerCommand_RemoveDevice",
    7: "ControllerCommand_RemoveFailedNode",
    8: "ControllerCommand_HasNodeFailed",
    9: "ControllerCommand_ReplaceFailedNode",
    10: "ControllerCommand_TransferPrimaryRole",
    11: "ControllerCommand_RequestNetworkUpdate",
    12: "ControllerCommand_RequestNodeNeighborUpdate",
    13: "ControllerCommand_AssignReturnRoute",
    14: "ControllerCommand_DeleteAllReturnRoutes",
    15: "ControllerCommand_CreateButton",
    16: "ControllerCommand_DeleteButton",
  }

  _NAMES_TO_VALUES = {
    "ControllerCommand_None": 0,
    "ControllerCommand_AddController": 1,
    "ControllerCommand_AddDevice": 2,
    "ControllerCommand_CreateNewPrimary": 3,
    "ControllerCommand_ReceiveConfiguration": 4,
    "ControllerCommand_RemoveController": 5,
    "ControllerCommand_RemoveDevice": 6,
    "ControllerCommand_RemoveFailedNode": 7,
    "ControllerCommand_HasNodeFailed": 8,
    "ControllerCommand_ReplaceFailedNode": 9,
    "ControllerCommand_TransferPrimaryRole": 10,
    "ControllerCommand_RequestNetworkUpdate": 11,
    "ControllerCommand_RequestNodeNeighborUpdate": 12,
    "ControllerCommand_AssignReturnRoute": 13,
    "ControllerCommand_DeleteAllReturnRoutes": 14,
    "ControllerCommand_CreateButton": 15,
    "ControllerCommand_DeleteButton": 16,
  }


class RemoteValueID:
  """
  Delete a handheld button id.

  Attributes:
   - _homeId
   - _nodeId
   - _genre
   - _commandClassId
   - _instance
   - _valueIndex
   - _type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.I32, '_genre', None, None, ), # 3
    (4, TType.BYTE, '_commandClassId', None, None, ), # 4
    (5, TType.BYTE, '_instance', None, None, ), # 5
    (6, TType.BYTE, '_valueIndex', None, None, ), # 6
    (7, TType.I32, '_type', None, None, ), # 7
  )

  def __init__(self, _homeId=None, _nodeId=None, _genre=None, _commandClassId=None, _instance=None, _valueIndex=None, _type=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._genre = _genre
    self._commandClassId = _commandClassId
    self._instance = _instance
    self._valueIndex = _valueIndex
    self._type = _type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._genre = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._commandClassId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self._instance = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self._valueIndex = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self._type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoteValueID')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._genre is not None:
      oprot.writeFieldBegin('_genre', TType.I32, 3)
      oprot.writeI32(self._genre)
      oprot.writeFieldEnd()
    if self._commandClassId is not None:
      oprot.writeFieldBegin('_commandClassId', TType.BYTE, 4)
      oprot.writeByte(self._commandClassId)
      oprot.writeFieldEnd()
    if self._instance is not None:
      oprot.writeFieldBegin('_instance', TType.BYTE, 5)
      oprot.writeByte(self._instance)
      oprot.writeFieldEnd()
    if self._valueIndex is not None:
      oprot.writeFieldBegin('_valueIndex', TType.BYTE, 6)
      oprot.writeByte(self._valueIndex)
      oprot.writeFieldEnd()
    if self._type is not None:
      oprot.writeFieldBegin('_type', TType.I32, 7)
      oprot.writeI32(self._type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DriverData:
  """
  Attributes:
   - s_SOFCnt
   - s_ACKWaiting
   - s_readAborts
   - s_badChecksum
   - s_readCnt
   - s_writeCnt
   - s_CANCnt
   - s_NAKCnt
   - s_ACKCnt
   - s_OOFCnt
   - s_dropped
   - s_retries
   - s_controllerReadCnt
   - s_controllerWriteCnt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 's_SOFCnt', None, None, ), # 1
    (2, TType.I32, 's_ACKWaiting', None, None, ), # 2
    (3, TType.I32, 's_readAborts', None, None, ), # 3
    (4, TType.I32, 's_badChecksum', None, None, ), # 4
    (5, TType.I32, 's_readCnt', None, None, ), # 5
    (6, TType.I32, 's_writeCnt', None, None, ), # 6
    (7, TType.I32, 's_CANCnt', None, None, ), # 7
    (8, TType.I32, 's_NAKCnt', None, None, ), # 8
    (9, TType.I32, 's_ACKCnt', None, None, ), # 9
    (10, TType.I32, 's_OOFCnt', None, None, ), # 10
    (11, TType.I32, 's_dropped', None, None, ), # 11
    (12, TType.I32, 's_retries', None, None, ), # 12
    (13, TType.I32, 's_controllerReadCnt', None, None, ), # 13
    (14, TType.I32, 's_controllerWriteCnt', None, None, ), # 14
  )

  def __init__(self, s_SOFCnt=None, s_ACKWaiting=None, s_readAborts=None, s_badChecksum=None, s_readCnt=None, s_writeCnt=None, s_CANCnt=None, s_NAKCnt=None, s_ACKCnt=None, s_OOFCnt=None, s_dropped=None, s_retries=None, s_controllerReadCnt=None, s_controllerWriteCnt=None,):
    self.s_SOFCnt = s_SOFCnt
    self.s_ACKWaiting = s_ACKWaiting
    self.s_readAborts = s_readAborts
    self.s_badChecksum = s_badChecksum
    self.s_readCnt = s_readCnt
    self.s_writeCnt = s_writeCnt
    self.s_CANCnt = s_CANCnt
    self.s_NAKCnt = s_NAKCnt
    self.s_ACKCnt = s_ACKCnt
    self.s_OOFCnt = s_OOFCnt
    self.s_dropped = s_dropped
    self.s_retries = s_retries
    self.s_controllerReadCnt = s_controllerReadCnt
    self.s_controllerWriteCnt = s_controllerWriteCnt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.s_SOFCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.s_ACKWaiting = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.s_readAborts = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.s_badChecksum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.s_readCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.s_writeCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.s_CANCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.s_NAKCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.s_ACKCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.s_OOFCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.s_dropped = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.s_retries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.s_controllerReadCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.s_controllerWriteCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DriverData')
    if self.s_SOFCnt is not None:
      oprot.writeFieldBegin('s_SOFCnt', TType.I32, 1)
      oprot.writeI32(self.s_SOFCnt)
      oprot.writeFieldEnd()
    if self.s_ACKWaiting is not None:
      oprot.writeFieldBegin('s_ACKWaiting', TType.I32, 2)
      oprot.writeI32(self.s_ACKWaiting)
      oprot.writeFieldEnd()
    if self.s_readAborts is not None:
      oprot.writeFieldBegin('s_readAborts', TType.I32, 3)
      oprot.writeI32(self.s_readAborts)
      oprot.writeFieldEnd()
    if self.s_badChecksum is not None:
      oprot.writeFieldBegin('s_badChecksum', TType.I32, 4)
      oprot.writeI32(self.s_badChecksum)
      oprot.writeFieldEnd()
    if self.s_readCnt is not None:
      oprot.writeFieldBegin('s_readCnt', TType.I32, 5)
      oprot.writeI32(self.s_readCnt)
      oprot.writeFieldEnd()
    if self.s_writeCnt is not None:
      oprot.writeFieldBegin('s_writeCnt', TType.I32, 6)
      oprot.writeI32(self.s_writeCnt)
      oprot.writeFieldEnd()
    if self.s_CANCnt is not None:
      oprot.writeFieldBegin('s_CANCnt', TType.I32, 7)
      oprot.writeI32(self.s_CANCnt)
      oprot.writeFieldEnd()
    if self.s_NAKCnt is not None:
      oprot.writeFieldBegin('s_NAKCnt', TType.I32, 8)
      oprot.writeI32(self.s_NAKCnt)
      oprot.writeFieldEnd()
    if self.s_ACKCnt is not None:
      oprot.writeFieldBegin('s_ACKCnt', TType.I32, 9)
      oprot.writeI32(self.s_ACKCnt)
      oprot.writeFieldEnd()
    if self.s_OOFCnt is not None:
      oprot.writeFieldBegin('s_OOFCnt', TType.I32, 10)
      oprot.writeI32(self.s_OOFCnt)
      oprot.writeFieldEnd()
    if self.s_dropped is not None:
      oprot.writeFieldBegin('s_dropped', TType.I32, 11)
      oprot.writeI32(self.s_dropped)
      oprot.writeFieldEnd()
    if self.s_retries is not None:
      oprot.writeFieldBegin('s_retries', TType.I32, 12)
      oprot.writeI32(self.s_retries)
      oprot.writeFieldEnd()
    if self.s_controllerReadCnt is not None:
      oprot.writeFieldBegin('s_controllerReadCnt', TType.I32, 13)
      oprot.writeI32(self.s_controllerReadCnt)
      oprot.writeFieldEnd()
    if self.s_controllerWriteCnt is not None:
      oprot.writeFieldBegin('s_controllerWriteCnt', TType.I32, 14)
      oprot.writeI32(self.s_controllerWriteCnt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDriverStatisticsReturnStruct:
  """
  Attributes:
   - _data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_data', (DriverData, DriverData.thrift_spec), None, ), # 1
  )

  def __init__(self, _data=None,):
    self._data = _data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._data = DriverData()
          self._data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDriverStatisticsReturnStruct')
    if self._data is not None:
      oprot.writeFieldBegin('_data', TType.STRUCT, 1)
      self._data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommandClassData:
  """
  Attributes:
   - m_commandClassId
   - m_sentCnt
   - m_receivedCnt
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'm_commandClassId', None, None, ), # 1
    (2, TType.I32, 'm_sentCnt', None, None, ), # 2
    (3, TType.I32, 'm_receivedCnt', None, None, ), # 3
  )

  def __init__(self, m_commandClassId=None, m_sentCnt=None, m_receivedCnt=None,):
    self.m_commandClassId = m_commandClassId
    self.m_sentCnt = m_sentCnt
    self.m_receivedCnt = m_receivedCnt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.m_commandClassId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.m_sentCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.m_receivedCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommandClassData')
    if self.m_commandClassId is not None:
      oprot.writeFieldBegin('m_commandClassId', TType.BYTE, 1)
      oprot.writeByte(self.m_commandClassId)
      oprot.writeFieldEnd()
    if self.m_sentCnt is not None:
      oprot.writeFieldBegin('m_sentCnt', TType.I32, 2)
      oprot.writeI32(self.m_sentCnt)
      oprot.writeFieldEnd()
    if self.m_receivedCnt is not None:
      oprot.writeFieldBegin('m_receivedCnt', TType.I32, 3)
      oprot.writeI32(self.m_receivedCnt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NodeData:
  """
  Attributes:
   - m_sentCnt
   - m_sentFailed
   - m_retries
   - m_receivedCnt
   - m_receivedDups
   - m_rtt
   - m_sentTS
   - m_receivedTS
   - m_lastRTT
   - m_averageRTT
   - m_quality
   - m_lastReceivedMessage
   - m_ccData
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'm_sentCnt', None, None, ), # 1
    (2, TType.I32, 'm_sentFailed', None, None, ), # 2
    (3, TType.I32, 'm_retries', None, None, ), # 3
    (4, TType.I32, 'm_receivedCnt', None, None, ), # 4
    (5, TType.I32, 'm_receivedDups', None, None, ), # 5
    (6, TType.I32, 'm_rtt', None, None, ), # 6
    (7, TType.STRING, 'm_sentTS', None, None, ), # 7
    (8, TType.STRING, 'm_receivedTS', None, None, ), # 8
    (9, TType.I32, 'm_lastRTT', None, None, ), # 9
    (10, TType.I32, 'm_averageRTT', None, None, ), # 10
    (11, TType.BYTE, 'm_quality', None, None, ), # 11
    (12, TType.LIST, 'm_lastReceivedMessage', (TType.BYTE,None), None, ), # 12
    (13, TType.LIST, 'm_ccData', (TType.STRUCT,(CommandClassData, CommandClassData.thrift_spec)), None, ), # 13
  )

  def __init__(self, m_sentCnt=None, m_sentFailed=None, m_retries=None, m_receivedCnt=None, m_receivedDups=None, m_rtt=None, m_sentTS=None, m_receivedTS=None, m_lastRTT=None, m_averageRTT=None, m_quality=None, m_lastReceivedMessage=None, m_ccData=None,):
    self.m_sentCnt = m_sentCnt
    self.m_sentFailed = m_sentFailed
    self.m_retries = m_retries
    self.m_receivedCnt = m_receivedCnt
    self.m_receivedDups = m_receivedDups
    self.m_rtt = m_rtt
    self.m_sentTS = m_sentTS
    self.m_receivedTS = m_receivedTS
    self.m_lastRTT = m_lastRTT
    self.m_averageRTT = m_averageRTT
    self.m_quality = m_quality
    self.m_lastReceivedMessage = m_lastReceivedMessage
    self.m_ccData = m_ccData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.m_sentCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.m_sentFailed = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.m_retries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.m_receivedCnt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.m_receivedDups = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.m_rtt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.m_sentTS = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.m_receivedTS = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.m_lastRTT = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.m_averageRTT = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BYTE:
          self.m_quality = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.m_lastReceivedMessage = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readByte();
            self.m_lastReceivedMessage.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.m_ccData = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = CommandClassData()
            _elem11.read(iprot)
            self.m_ccData.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NodeData')
    if self.m_sentCnt is not None:
      oprot.writeFieldBegin('m_sentCnt', TType.I32, 1)
      oprot.writeI32(self.m_sentCnt)
      oprot.writeFieldEnd()
    if self.m_sentFailed is not None:
      oprot.writeFieldBegin('m_sentFailed', TType.I32, 2)
      oprot.writeI32(self.m_sentFailed)
      oprot.writeFieldEnd()
    if self.m_retries is not None:
      oprot.writeFieldBegin('m_retries', TType.I32, 3)
      oprot.writeI32(self.m_retries)
      oprot.writeFieldEnd()
    if self.m_receivedCnt is not None:
      oprot.writeFieldBegin('m_receivedCnt', TType.I32, 4)
      oprot.writeI32(self.m_receivedCnt)
      oprot.writeFieldEnd()
    if self.m_receivedDups is not None:
      oprot.writeFieldBegin('m_receivedDups', TType.I32, 5)
      oprot.writeI32(self.m_receivedDups)
      oprot.writeFieldEnd()
    if self.m_rtt is not None:
      oprot.writeFieldBegin('m_rtt', TType.I32, 6)
      oprot.writeI32(self.m_rtt)
      oprot.writeFieldEnd()
    if self.m_sentTS is not None:
      oprot.writeFieldBegin('m_sentTS', TType.STRING, 7)
      oprot.writeString(self.m_sentTS)
      oprot.writeFieldEnd()
    if self.m_receivedTS is not None:
      oprot.writeFieldBegin('m_receivedTS', TType.STRING, 8)
      oprot.writeString(self.m_receivedTS)
      oprot.writeFieldEnd()
    if self.m_lastRTT is not None:
      oprot.writeFieldBegin('m_lastRTT', TType.I32, 9)
      oprot.writeI32(self.m_lastRTT)
      oprot.writeFieldEnd()
    if self.m_averageRTT is not None:
      oprot.writeFieldBegin('m_averageRTT', TType.I32, 10)
      oprot.writeI32(self.m_averageRTT)
      oprot.writeFieldEnd()
    if self.m_quality is not None:
      oprot.writeFieldBegin('m_quality', TType.BYTE, 11)
      oprot.writeByte(self.m_quality)
      oprot.writeFieldEnd()
    if self.m_lastReceivedMessage is not None:
      oprot.writeFieldBegin('m_lastReceivedMessage', TType.LIST, 12)
      oprot.writeListBegin(TType.BYTE, len(self.m_lastReceivedMessage))
      for iter12 in self.m_lastReceivedMessage:
        oprot.writeByte(iter12)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.m_ccData is not None:
      oprot.writeFieldBegin('m_ccData', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.m_ccData))
      for iter13 in self.m_ccData:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeStatisticsReturnStruct:
  """
  Attributes:
   - _data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_data', (NodeData, NodeData.thrift_spec), None, ), # 1
  )

  def __init__(self, _data=None,):
    self._data = _data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._data = NodeData()
          self._data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeStatisticsReturnStruct')
    if self._data is not None:
      oprot.writeFieldBegin('_data', TType.STRUCT, 1)
      self._data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSwitchPointReturnStruct:
  """
  Attributes:
   - retval
   - o_hours
   - o_minutes
   - o_setback
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.BYTE, 'o_hours', None, None, ), # 2
    (3, TType.BYTE, 'o_minutes', None, None, ), # 3
    (4, TType.BYTE, 'o_setback', None, None, ), # 4
  )

  def __init__(self, retval=None, o_hours=None, o_minutes=None, o_setback=None,):
    self.retval = retval
    self.o_hours = o_hours
    self.o_minutes = o_minutes
    self.o_setback = o_setback

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.o_hours = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.o_minutes = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.o_setback = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSwitchPointReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_hours is not None:
      oprot.writeFieldBegin('o_hours', TType.BYTE, 2)
      oprot.writeByte(self.o_hours)
      oprot.writeFieldEnd()
    if self.o_minutes is not None:
      oprot.writeFieldBegin('o_minutes', TType.BYTE, 3)
      oprot.writeByte(self.o_minutes)
      oprot.writeFieldEnd()
    if self.o_setback is not None:
      oprot.writeFieldBegin('o_setback', TType.BYTE, 4)
      oprot.writeByte(self.o_setback)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Bool:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.BOOL, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.o_value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Bool')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.BOOL, 2)
      oprot.writeBool(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_UInt8:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.BYTE, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.o_value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_UInt8')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.BYTE, 2)
      oprot.writeByte(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Float:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.DOUBLE, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.o_value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Float')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.DOUBLE, 2)
      oprot.writeDouble(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Int:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.I32, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.o_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Int')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.I32, 2)
      oprot.writeI32(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_Int16:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.I16, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.o_value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_Int16')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.I16, 2)
      oprot.writeI16(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_String:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.STRING, 'o_value', None, None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.o_value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_String')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.STRING, 2)
      oprot.writeString(self.o_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_ListString:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.LIST, 'o_value', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.o_value = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.o_value.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_ListString')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.o_value))
      for iter20 in self.o_value:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UInt32_ListByte:
  """
  Attributes:
   - retval
   - _nodeNeighbors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'retval', None, None, ), # 1
    (2, TType.LIST, '_nodeNeighbors', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, retval=None, _nodeNeighbors=None,):
    self.retval = retval
    self._nodeNeighbors = _nodeNeighbors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self._nodeNeighbors = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readByte();
            self._nodeNeighbors.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UInt32_ListByte')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 1)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self._nodeNeighbors is not None:
      oprot.writeFieldBegin('_nodeNeighbors', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self._nodeNeighbors))
      for iter27 in self._nodeNeighbors:
        oprot.writeByte(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bool_GetNodeClassInformation:
  """
  Attributes:
   - retval
   - _className
   - _classVersion
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'retval', None, None, ), # 1
    (2, TType.STRING, '_className', None, None, ), # 2
    (3, TType.BYTE, '_classVersion', None, None, ), # 3
  )

  def __init__(self, retval=None, _className=None, _classVersion=None,):
    self.retval = retval
    self._className = _className
    self._classVersion = _classVersion

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.retval = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._classVersion = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bool_GetNodeClassInformation')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BOOL, 1)
      oprot.writeBool(self.retval)
      oprot.writeFieldEnd()
    if self._className is not None:
      oprot.writeFieldBegin('_className', TType.STRING, 2)
      oprot.writeString(self._className)
      oprot.writeFieldEnd()
    if self._classVersion is not None:
      oprot.writeFieldBegin('_classVersion', TType.BYTE, 3)
      oprot.writeByte(self._classVersion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAssociationsReturnStruct:
  """
  Attributes:
   - retval
   - o_associations
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'retval', None, None, ), # 1
    (2, TType.LIST, 'o_associations', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, retval=None, o_associations=None,):
    self.retval = retval
    self.o_associations = o_associations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.o_associations = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readByte();
            self.o_associations.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAssociationsReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 1)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self.o_associations is not None:
      oprot.writeFieldBegin('o_associations', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self.o_associations))
      for iter34 in self.o_associations:
        oprot.writeByte(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllScenesReturnStruct:
  """
  Attributes:
   - retval
   - _sceneIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'retval', None, None, ), # 1
    (2, TType.LIST, '_sceneIds', (TType.BYTE,None), None, ), # 2
  )

  def __init__(self, retval=None, _sceneIds=None,):
    self.retval = retval
    self._sceneIds = _sceneIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.retval = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self._sceneIds = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readByte();
            self._sceneIds.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllScenesReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.BYTE, 1)
      oprot.writeByte(self.retval)
      oprot.writeFieldEnd()
    if self._sceneIds is not None:
      oprot.writeFieldBegin('_sceneIds', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self._sceneIds))
      for iter41 in self._sceneIds:
        oprot.writeByte(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValuesReturnStruct:
  """
  Attributes:
   - retval
   - o_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'retval', None, None, ), # 1
    (2, TType.LIST, 'o_value', (TType.STRUCT,(RemoteValueID, RemoteValueID.thrift_spec)), None, ), # 2
  )

  def __init__(self, retval=None, o_value=None,):
    self.retval = retval
    self.o_value = o_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.o_value = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = RemoteValueID()
            _elem47.read(iprot)
            self.o_value.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValuesReturnStruct')
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 1)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self.o_value is not None:
      oprot.writeFieldBegin('o_value', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.o_value))
      for iter48 in self.o_value:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
