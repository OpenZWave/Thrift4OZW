#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def WriteConfig(self, _homeId):
    """
    \name Configuration
    For saving the Z-Wave network configuration so that the entire network does not need to be
    polled every time the application starts.

    Parameters:
     - _homeId
    """
    pass

  def GetControllerNodeId(self, _homeId):
    """
    \name Drivers
    Methods for adding and removing drivers and obtaining basic controller information.

    Parameters:
     - _homeId
    """
    pass

  def GetSUCNodeId(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def IsPrimaryController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def IsStaticUpdateController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def IsBridgeController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def GetLibraryVersion(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def GetLibraryTypeName(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def GetSendQueueCount(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def LogDriverStatistics(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def GetControllerPath(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def GetPollInterval(self, ):
    pass

  def SetPollInterval(self, _milliseconds, _bIntervalBetweenPolls):
    """
    Parameters:
     - _milliseconds
     - _bIntervalBetweenPolls
    """
    pass

  def EnablePoll(self, _valueId, _intensity):
    """
    Parameters:
     - _valueId
     - _intensity
    """
    pass

  def DisablePoll(self, _valueId):
    """
    Parameters:
     - _valueId
    """
    pass

  def isPolled(self, _valueId):
    """
    Parameters:
     - _valueId
    """
    pass

  def SetPollIntensity(self, _valueId, _intensity):
    """
    Parameters:
     - _valueId
     - _intensity
    """
    pass

  def RefreshNodeInfo(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def RequestNodeState(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def RequestNodeDynamic(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeListeningDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeFrequentListeningDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeBeamingDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeRoutingDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeSecurityDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeMaxBaudRate(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeVersion(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeSecurity(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeBasic(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeGeneric(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeSpecific(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeType(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeNeighbors(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeManufacturerName(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeProductName(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeName(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeLocation(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeManufacturerId(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeProductType(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeProductId(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SetNodeManufacturerName(self, _homeId, _nodeId, _manufacturerName):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _manufacturerName
    """
    pass

  def SetNodeProductName(self, _homeId, _nodeId, _productName):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _productName
    """
    pass

  def SetNodeName(self, _homeId, _nodeId, _nodeName):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _nodeName
    """
    pass

  def SetNodeLocation(self, _homeId, _nodeId, _location):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _location
    """
    pass

  def SetNodeOn(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SetNodeOff(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SetNodeLevel(self, _homeId, _nodeId, _level):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _level
    """
    pass

  def IsNodeInfoReceived(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeClassInformation(self, _homeId, _nodeId, _commandClassId):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _commandClassId
    """
    pass

  def IsNodeAwake(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeFailed(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeQueryStage(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetValueLabel(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def SetValueLabel(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def GetValueUnits(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def SetValueUnits(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def GetValueHelp(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def SetValueHelp(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def GetValueMin(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueMax(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def IsValueReadOnly(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def IsValueWriteOnly(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def IsValueSet(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def IsValuePolled(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueAsBool(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueAsByte(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueAsFloat(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueAsInt(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueAsShort(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueAsString(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueListSelection_String(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueListSelection_Int32(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueListItems(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetValueFloatPrecision(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def SetValue_Bool(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_UInt8(self, _id, _value, _length):
    """
    Parameters:
     - _id
     - _value
     - _length
    """
    pass

  def SetValue_Float(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_Int32(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_Int16(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_String(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    pass

  def SetValueListSelection(self, _id, _selectedItem):
    """
    Parameters:
     - _id
     - _selectedItem
    """
    pass

  def RefreshValue(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def SetChangeVerified(self, _id, _verify):
    """
    Parameters:
     - _id
     - _verify
    """
    pass

  def PressButton(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def ReleaseButton(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetNumSwitchPoints(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def SetSwitchPoint(self, _id, _hours, _minutes, _setback):
    """
    Parameters:
     - _id
     - _hours
     - _minutes
     - _setback
    """
    pass

  def RemoveSwitchPoint(self, _id, _hours, _minutes):
    """
    Parameters:
     - _id
     - _hours
     - _minutes
    """
    pass

  def ClearSwitchPoints(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def GetSwitchPoint(self, _id, _idx):
    """
    Parameters:
     - _id
     - _idx
    """
    pass

  def SwitchAllOn(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def SwitchAllOff(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def SetConfigParam(self, _homeId, _nodeId, _param, _value, _size):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _param
     - _value
     - _size
    """
    pass

  def RequestConfigParam(self, _homeId, _nodeId, _param):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _param
    """
    pass

  def RequestAllConfigParams(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNumGroups(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    pass

  def GetMaxAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    pass

  def GetGroupLabel(self, _homeId, _nodeId, _groupIdx):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    pass

  def AddAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    pass

  def RemoveAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    pass

  def ResetController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def SoftReset(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def BeginControllerCommand(self, _homeId, _command, _highPower, _nodeId, _arg):
    """
    Parameters:
     - _homeId
     - _command
     - _highPower
     - _nodeId
     - _arg
    """
    pass

  def CancelControllerCommand(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def TestNetworkNode(self, _homeId, _nodeId, _count):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _count
    """
    pass

  def TestNetwork(self, _homeId, _count):
    """
    Parameters:
     - _homeId
     - _count
    """
    pass

  def HealNetworkNode(self, _homeId, _nodeId, _doRR):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _doRR
    """
    pass

  def HealNetwork(self, _homeId, _doRR):
    """
    Parameters:
     - _homeId
     - _doRR
    """
    pass

  def GetNumScenes(self, ):
    pass

  def GetAllScenes(self, ):
    pass

  def RemoveAllScenes(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def CreateScene(self, ):
    pass

  def RemoveScene(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    pass

  def AddSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def RemoveSceneValue(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValues(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    pass

  def SceneGetValueAsBool(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsByte(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsFloat(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsInt(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsShort(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsString(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueListSelection_String(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueListSelection_Int32(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SetSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def GetSceneLabel(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    pass

  def SetSceneLabel(self, _sceneId, _value):
    """
    Parameters:
     - _sceneId
     - _value
    """
    pass

  def SceneExists(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    pass

  def ActivateScene(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    pass

  def GetDriverStatistics(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def GetNodeStatistics(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SendAllValues(self, ):
    pass

  def ping(self, ):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def WriteConfig(self, _homeId):
    """
    \name Configuration
    For saving the Z-Wave network configuration so that the entire network does not need to be
    polled every time the application starts.

    Parameters:
     - _homeId
    """
    self.send_WriteConfig(_homeId)
    self.recv_WriteConfig()

  def send_WriteConfig(self, _homeId):
    self._oprot.writeMessageBegin('WriteConfig', TMessageType.CALL, self._seqid)
    args = WriteConfig_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_WriteConfig(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = WriteConfig_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetControllerNodeId(self, _homeId):
    """
    \name Drivers
    Methods for adding and removing drivers and obtaining basic controller information.

    Parameters:
     - _homeId
    """
    self.send_GetControllerNodeId(_homeId)
    return self.recv_GetControllerNodeId()

  def send_GetControllerNodeId(self, _homeId):
    self._oprot.writeMessageBegin('GetControllerNodeId', TMessageType.CALL, self._seqid)
    args = GetControllerNodeId_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetControllerNodeId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetControllerNodeId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetControllerNodeId failed: unknown result");

  def GetSUCNodeId(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_GetSUCNodeId(_homeId)
    return self.recv_GetSUCNodeId()

  def send_GetSUCNodeId(self, _homeId):
    self._oprot.writeMessageBegin('GetSUCNodeId', TMessageType.CALL, self._seqid)
    args = GetSUCNodeId_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSUCNodeId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSUCNodeId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSUCNodeId failed: unknown result");

  def IsPrimaryController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_IsPrimaryController(_homeId)
    return self.recv_IsPrimaryController()

  def send_IsPrimaryController(self, _homeId):
    self._oprot.writeMessageBegin('IsPrimaryController', TMessageType.CALL, self._seqid)
    args = IsPrimaryController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsPrimaryController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsPrimaryController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsPrimaryController failed: unknown result");

  def IsStaticUpdateController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_IsStaticUpdateController(_homeId)
    return self.recv_IsStaticUpdateController()

  def send_IsStaticUpdateController(self, _homeId):
    self._oprot.writeMessageBegin('IsStaticUpdateController', TMessageType.CALL, self._seqid)
    args = IsStaticUpdateController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsStaticUpdateController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsStaticUpdateController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsStaticUpdateController failed: unknown result");

  def IsBridgeController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_IsBridgeController(_homeId)
    return self.recv_IsBridgeController()

  def send_IsBridgeController(self, _homeId):
    self._oprot.writeMessageBegin('IsBridgeController', TMessageType.CALL, self._seqid)
    args = IsBridgeController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsBridgeController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsBridgeController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsBridgeController failed: unknown result");

  def GetLibraryVersion(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_GetLibraryVersion(_homeId)
    return self.recv_GetLibraryVersion()

  def send_GetLibraryVersion(self, _homeId):
    self._oprot.writeMessageBegin('GetLibraryVersion', TMessageType.CALL, self._seqid)
    args = GetLibraryVersion_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLibraryVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetLibraryVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLibraryVersion failed: unknown result");

  def GetLibraryTypeName(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_GetLibraryTypeName(_homeId)
    return self.recv_GetLibraryTypeName()

  def send_GetLibraryTypeName(self, _homeId):
    self._oprot.writeMessageBegin('GetLibraryTypeName', TMessageType.CALL, self._seqid)
    args = GetLibraryTypeName_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLibraryTypeName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetLibraryTypeName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLibraryTypeName failed: unknown result");

  def GetSendQueueCount(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_GetSendQueueCount(_homeId)
    return self.recv_GetSendQueueCount()

  def send_GetSendQueueCount(self, _homeId):
    self._oprot.writeMessageBegin('GetSendQueueCount', TMessageType.CALL, self._seqid)
    args = GetSendQueueCount_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSendQueueCount(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSendQueueCount_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSendQueueCount failed: unknown result");

  def LogDriverStatistics(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_LogDriverStatistics(_homeId)
    self.recv_LogDriverStatistics()

  def send_LogDriverStatistics(self, _homeId):
    self._oprot.writeMessageBegin('LogDriverStatistics', TMessageType.CALL, self._seqid)
    args = LogDriverStatistics_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LogDriverStatistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = LogDriverStatistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetControllerPath(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_GetControllerPath(_homeId)
    return self.recv_GetControllerPath()

  def send_GetControllerPath(self, _homeId):
    self._oprot.writeMessageBegin('GetControllerPath', TMessageType.CALL, self._seqid)
    args = GetControllerPath_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetControllerPath(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetControllerPath_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetControllerPath failed: unknown result");

  def GetPollInterval(self, ):
    self.send_GetPollInterval()
    return self.recv_GetPollInterval()

  def send_GetPollInterval(self, ):
    self._oprot.writeMessageBegin('GetPollInterval', TMessageType.CALL, self._seqid)
    args = GetPollInterval_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetPollInterval(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetPollInterval_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPollInterval failed: unknown result");

  def SetPollInterval(self, _milliseconds, _bIntervalBetweenPolls):
    """
    Parameters:
     - _milliseconds
     - _bIntervalBetweenPolls
    """
    self.send_SetPollInterval(_milliseconds, _bIntervalBetweenPolls)
    self.recv_SetPollInterval()

  def send_SetPollInterval(self, _milliseconds, _bIntervalBetweenPolls):
    self._oprot.writeMessageBegin('SetPollInterval', TMessageType.CALL, self._seqid)
    args = SetPollInterval_args()
    args._milliseconds = _milliseconds
    args._bIntervalBetweenPolls = _bIntervalBetweenPolls
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetPollInterval(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetPollInterval_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def EnablePoll(self, _valueId, _intensity):
    """
    Parameters:
     - _valueId
     - _intensity
    """
    self.send_EnablePoll(_valueId, _intensity)
    return self.recv_EnablePoll()

  def send_EnablePoll(self, _valueId, _intensity):
    self._oprot.writeMessageBegin('EnablePoll', TMessageType.CALL, self._seqid)
    args = EnablePoll_args()
    args._valueId = _valueId
    args._intensity = _intensity
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_EnablePoll(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = EnablePoll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "EnablePoll failed: unknown result");

  def DisablePoll(self, _valueId):
    """
    Parameters:
     - _valueId
    """
    self.send_DisablePoll(_valueId)
    return self.recv_DisablePoll()

  def send_DisablePoll(self, _valueId):
    self._oprot.writeMessageBegin('DisablePoll', TMessageType.CALL, self._seqid)
    args = DisablePoll_args()
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DisablePoll(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = DisablePoll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "DisablePoll failed: unknown result");

  def isPolled(self, _valueId):
    """
    Parameters:
     - _valueId
    """
    self.send_isPolled(_valueId)
    return self.recv_isPolled()

  def send_isPolled(self, _valueId):
    self._oprot.writeMessageBegin('isPolled', TMessageType.CALL, self._seqid)
    args = isPolled_args()
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPolled(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isPolled_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPolled failed: unknown result");

  def SetPollIntensity(self, _valueId, _intensity):
    """
    Parameters:
     - _valueId
     - _intensity
    """
    self.send_SetPollIntensity(_valueId, _intensity)
    self.recv_SetPollIntensity()

  def send_SetPollIntensity(self, _valueId, _intensity):
    self._oprot.writeMessageBegin('SetPollIntensity', TMessageType.CALL, self._seqid)
    args = SetPollIntensity_args()
    args._valueId = _valueId
    args._intensity = _intensity
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetPollIntensity(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetPollIntensity_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RefreshNodeInfo(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RefreshNodeInfo(_homeId, _nodeId)
    return self.recv_RefreshNodeInfo()

  def send_RefreshNodeInfo(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RefreshNodeInfo', TMessageType.CALL, self._seqid)
    args = RefreshNodeInfo_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RefreshNodeInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RefreshNodeInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RefreshNodeInfo failed: unknown result");

  def RequestNodeState(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RequestNodeState(_homeId, _nodeId)
    return self.recv_RequestNodeState()

  def send_RequestNodeState(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RequestNodeState', TMessageType.CALL, self._seqid)
    args = RequestNodeState_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestNodeState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestNodeState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RequestNodeState failed: unknown result");

  def RequestNodeDynamic(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RequestNodeDynamic(_homeId, _nodeId)
    return self.recv_RequestNodeDynamic()

  def send_RequestNodeDynamic(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RequestNodeDynamic', TMessageType.CALL, self._seqid)
    args = RequestNodeDynamic_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestNodeDynamic(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestNodeDynamic_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RequestNodeDynamic failed: unknown result");

  def IsNodeListeningDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeListeningDevice(_homeId, _nodeId)
    return self.recv_IsNodeListeningDevice()

  def send_IsNodeListeningDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeListeningDevice', TMessageType.CALL, self._seqid)
    args = IsNodeListeningDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeListeningDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeListeningDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeListeningDevice failed: unknown result");

  def IsNodeFrequentListeningDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeFrequentListeningDevice(_homeId, _nodeId)
    return self.recv_IsNodeFrequentListeningDevice()

  def send_IsNodeFrequentListeningDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeFrequentListeningDevice', TMessageType.CALL, self._seqid)
    args = IsNodeFrequentListeningDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeFrequentListeningDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeFrequentListeningDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeFrequentListeningDevice failed: unknown result");

  def IsNodeBeamingDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeBeamingDevice(_homeId, _nodeId)
    return self.recv_IsNodeBeamingDevice()

  def send_IsNodeBeamingDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeBeamingDevice', TMessageType.CALL, self._seqid)
    args = IsNodeBeamingDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeBeamingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeBeamingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeBeamingDevice failed: unknown result");

  def IsNodeRoutingDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeRoutingDevice(_homeId, _nodeId)
    return self.recv_IsNodeRoutingDevice()

  def send_IsNodeRoutingDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeRoutingDevice', TMessageType.CALL, self._seqid)
    args = IsNodeRoutingDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeRoutingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeRoutingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeRoutingDevice failed: unknown result");

  def IsNodeSecurityDevice(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeSecurityDevice(_homeId, _nodeId)
    return self.recv_IsNodeSecurityDevice()

  def send_IsNodeSecurityDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeSecurityDevice', TMessageType.CALL, self._seqid)
    args = IsNodeSecurityDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeSecurityDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeSecurityDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeSecurityDevice failed: unknown result");

  def GetNodeMaxBaudRate(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeMaxBaudRate(_homeId, _nodeId)
    return self.recv_GetNodeMaxBaudRate()

  def send_GetNodeMaxBaudRate(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeMaxBaudRate', TMessageType.CALL, self._seqid)
    args = GetNodeMaxBaudRate_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeMaxBaudRate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeMaxBaudRate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeMaxBaudRate failed: unknown result");

  def GetNodeVersion(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeVersion(_homeId, _nodeId)
    return self.recv_GetNodeVersion()

  def send_GetNodeVersion(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeVersion', TMessageType.CALL, self._seqid)
    args = GetNodeVersion_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeVersion failed: unknown result");

  def GetNodeSecurity(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeSecurity(_homeId, _nodeId)
    return self.recv_GetNodeSecurity()

  def send_GetNodeSecurity(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeSecurity', TMessageType.CALL, self._seqid)
    args = GetNodeSecurity_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeSecurity(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeSecurity_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeSecurity failed: unknown result");

  def GetNodeBasic(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeBasic(_homeId, _nodeId)
    return self.recv_GetNodeBasic()

  def send_GetNodeBasic(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeBasic', TMessageType.CALL, self._seqid)
    args = GetNodeBasic_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeBasic(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeBasic_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeBasic failed: unknown result");

  def GetNodeGeneric(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeGeneric(_homeId, _nodeId)
    return self.recv_GetNodeGeneric()

  def send_GetNodeGeneric(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeGeneric', TMessageType.CALL, self._seqid)
    args = GetNodeGeneric_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeGeneric(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeGeneric_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeGeneric failed: unknown result");

  def GetNodeSpecific(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeSpecific(_homeId, _nodeId)
    return self.recv_GetNodeSpecific()

  def send_GetNodeSpecific(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeSpecific', TMessageType.CALL, self._seqid)
    args = GetNodeSpecific_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeSpecific(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeSpecific_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeSpecific failed: unknown result");

  def GetNodeType(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeType(_homeId, _nodeId)
    return self.recv_GetNodeType()

  def send_GetNodeType(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeType', TMessageType.CALL, self._seqid)
    args = GetNodeType_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeType(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeType_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeType failed: unknown result");

  def GetNodeNeighbors(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeNeighbors(_homeId, _nodeId)
    return self.recv_GetNodeNeighbors()

  def send_GetNodeNeighbors(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeNeighbors', TMessageType.CALL, self._seqid)
    args = GetNodeNeighbors_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeNeighbors(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeNeighbors_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeNeighbors failed: unknown result");

  def GetNodeManufacturerName(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeManufacturerName(_homeId, _nodeId)
    return self.recv_GetNodeManufacturerName()

  def send_GetNodeManufacturerName(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeManufacturerName', TMessageType.CALL, self._seqid)
    args = GetNodeManufacturerName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeManufacturerName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeManufacturerName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeManufacturerName failed: unknown result");

  def GetNodeProductName(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeProductName(_homeId, _nodeId)
    return self.recv_GetNodeProductName()

  def send_GetNodeProductName(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeProductName', TMessageType.CALL, self._seqid)
    args = GetNodeProductName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeProductName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeProductName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeProductName failed: unknown result");

  def GetNodeName(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeName(_homeId, _nodeId)
    return self.recv_GetNodeName()

  def send_GetNodeName(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeName', TMessageType.CALL, self._seqid)
    args = GetNodeName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeName failed: unknown result");

  def GetNodeLocation(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeLocation(_homeId, _nodeId)
    return self.recv_GetNodeLocation()

  def send_GetNodeLocation(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeLocation', TMessageType.CALL, self._seqid)
    args = GetNodeLocation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeLocation failed: unknown result");

  def GetNodeManufacturerId(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeManufacturerId(_homeId, _nodeId)
    return self.recv_GetNodeManufacturerId()

  def send_GetNodeManufacturerId(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeManufacturerId', TMessageType.CALL, self._seqid)
    args = GetNodeManufacturerId_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeManufacturerId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeManufacturerId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeManufacturerId failed: unknown result");

  def GetNodeProductType(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeProductType(_homeId, _nodeId)
    return self.recv_GetNodeProductType()

  def send_GetNodeProductType(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeProductType', TMessageType.CALL, self._seqid)
    args = GetNodeProductType_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeProductType(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeProductType_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeProductType failed: unknown result");

  def GetNodeProductId(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeProductId(_homeId, _nodeId)
    return self.recv_GetNodeProductId()

  def send_GetNodeProductId(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeProductId', TMessageType.CALL, self._seqid)
    args = GetNodeProductId_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeProductId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeProductId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeProductId failed: unknown result");

  def SetNodeManufacturerName(self, _homeId, _nodeId, _manufacturerName):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _manufacturerName
    """
    self.send_SetNodeManufacturerName(_homeId, _nodeId, _manufacturerName)
    self.recv_SetNodeManufacturerName()

  def send_SetNodeManufacturerName(self, _homeId, _nodeId, _manufacturerName):
    self._oprot.writeMessageBegin('SetNodeManufacturerName', TMessageType.CALL, self._seqid)
    args = SetNodeManufacturerName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._manufacturerName = _manufacturerName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeManufacturerName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeManufacturerName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeProductName(self, _homeId, _nodeId, _productName):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _productName
    """
    self.send_SetNodeProductName(_homeId, _nodeId, _productName)
    self.recv_SetNodeProductName()

  def send_SetNodeProductName(self, _homeId, _nodeId, _productName):
    self._oprot.writeMessageBegin('SetNodeProductName', TMessageType.CALL, self._seqid)
    args = SetNodeProductName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._productName = _productName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeProductName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeProductName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeName(self, _homeId, _nodeId, _nodeName):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _nodeName
    """
    self.send_SetNodeName(_homeId, _nodeId, _nodeName)
    self.recv_SetNodeName()

  def send_SetNodeName(self, _homeId, _nodeId, _nodeName):
    self._oprot.writeMessageBegin('SetNodeName', TMessageType.CALL, self._seqid)
    args = SetNodeName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._nodeName = _nodeName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeLocation(self, _homeId, _nodeId, _location):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _location
    """
    self.send_SetNodeLocation(_homeId, _nodeId, _location)
    self.recv_SetNodeLocation()

  def send_SetNodeLocation(self, _homeId, _nodeId, _location):
    self._oprot.writeMessageBegin('SetNodeLocation', TMessageType.CALL, self._seqid)
    args = SetNodeLocation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._location = _location
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeOn(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_SetNodeOn(_homeId, _nodeId)
    self.recv_SetNodeOn()

  def send_SetNodeOn(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('SetNodeOn', TMessageType.CALL, self._seqid)
    args = SetNodeOn_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeOn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeOn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeOff(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_SetNodeOff(_homeId, _nodeId)
    self.recv_SetNodeOff()

  def send_SetNodeOff(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('SetNodeOff', TMessageType.CALL, self._seqid)
    args = SetNodeOff_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeOff(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeOff_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeLevel(self, _homeId, _nodeId, _level):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _level
    """
    self.send_SetNodeLevel(_homeId, _nodeId, _level)
    self.recv_SetNodeLevel()

  def send_SetNodeLevel(self, _homeId, _nodeId, _level):
    self._oprot.writeMessageBegin('SetNodeLevel', TMessageType.CALL, self._seqid)
    args = SetNodeLevel_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._level = _level
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeLevel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeLevel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def IsNodeInfoReceived(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeInfoReceived(_homeId, _nodeId)
    return self.recv_IsNodeInfoReceived()

  def send_IsNodeInfoReceived(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeInfoReceived', TMessageType.CALL, self._seqid)
    args = IsNodeInfoReceived_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeInfoReceived(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeInfoReceived_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeInfoReceived failed: unknown result");

  def GetNodeClassInformation(self, _homeId, _nodeId, _commandClassId):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _commandClassId
    """
    self.send_GetNodeClassInformation(_homeId, _nodeId, _commandClassId)
    return self.recv_GetNodeClassInformation()

  def send_GetNodeClassInformation(self, _homeId, _nodeId, _commandClassId):
    self._oprot.writeMessageBegin('GetNodeClassInformation', TMessageType.CALL, self._seqid)
    args = GetNodeClassInformation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._commandClassId = _commandClassId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeClassInformation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeClassInformation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeClassInformation failed: unknown result");

  def IsNodeAwake(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeAwake(_homeId, _nodeId)
    return self.recv_IsNodeAwake()

  def send_IsNodeAwake(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeAwake', TMessageType.CALL, self._seqid)
    args = IsNodeAwake_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeAwake(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeAwake_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeAwake failed: unknown result");

  def IsNodeFailed(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeFailed(_homeId, _nodeId)
    return self.recv_IsNodeFailed()

  def send_IsNodeFailed(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeFailed', TMessageType.CALL, self._seqid)
    args = IsNodeFailed_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeFailed(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeFailed_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeFailed failed: unknown result");

  def GetNodeQueryStage(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeQueryStage(_homeId, _nodeId)
    return self.recv_GetNodeQueryStage()

  def send_GetNodeQueryStage(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeQueryStage', TMessageType.CALL, self._seqid)
    args = GetNodeQueryStage_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeQueryStage(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeQueryStage_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeQueryStage failed: unknown result");

  def GetValueLabel(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueLabel(_id)
    return self.recv_GetValueLabel()

  def send_GetValueLabel(self, _id):
    self._oprot.writeMessageBegin('GetValueLabel', TMessageType.CALL, self._seqid)
    args = GetValueLabel_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueLabel failed: unknown result");

  def SetValueLabel(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValueLabel(_id, _value)
    self.recv_SetValueLabel()

  def send_SetValueLabel(self, _id, _value):
    self._oprot.writeMessageBegin('SetValueLabel', TMessageType.CALL, self._seqid)
    args = SetValueLabel_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetValueUnits(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueUnits(_id)
    return self.recv_GetValueUnits()

  def send_GetValueUnits(self, _id):
    self._oprot.writeMessageBegin('GetValueUnits', TMessageType.CALL, self._seqid)
    args = GetValueUnits_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueUnits(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueUnits_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueUnits failed: unknown result");

  def SetValueUnits(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValueUnits(_id, _value)
    self.recv_SetValueUnits()

  def send_SetValueUnits(self, _id, _value):
    self._oprot.writeMessageBegin('SetValueUnits', TMessageType.CALL, self._seqid)
    args = SetValueUnits_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueUnits(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueUnits_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetValueHelp(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueHelp(_id)
    return self.recv_GetValueHelp()

  def send_GetValueHelp(self, _id):
    self._oprot.writeMessageBegin('GetValueHelp', TMessageType.CALL, self._seqid)
    args = GetValueHelp_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueHelp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueHelp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueHelp failed: unknown result");

  def SetValueHelp(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValueHelp(_id, _value)
    self.recv_SetValueHelp()

  def send_SetValueHelp(self, _id, _value):
    self._oprot.writeMessageBegin('SetValueHelp', TMessageType.CALL, self._seqid)
    args = SetValueHelp_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueHelp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueHelp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetValueMin(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueMin(_id)
    return self.recv_GetValueMin()

  def send_GetValueMin(self, _id):
    self._oprot.writeMessageBegin('GetValueMin', TMessageType.CALL, self._seqid)
    args = GetValueMin_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueMin(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueMin_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueMin failed: unknown result");

  def GetValueMax(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueMax(_id)
    return self.recv_GetValueMax()

  def send_GetValueMax(self, _id):
    self._oprot.writeMessageBegin('GetValueMax', TMessageType.CALL, self._seqid)
    args = GetValueMax_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueMax(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueMax_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueMax failed: unknown result");

  def IsValueReadOnly(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_IsValueReadOnly(_id)
    return self.recv_IsValueReadOnly()

  def send_IsValueReadOnly(self, _id):
    self._oprot.writeMessageBegin('IsValueReadOnly', TMessageType.CALL, self._seqid)
    args = IsValueReadOnly_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValueReadOnly(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValueReadOnly_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValueReadOnly failed: unknown result");

  def IsValueWriteOnly(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_IsValueWriteOnly(_id)
    return self.recv_IsValueWriteOnly()

  def send_IsValueWriteOnly(self, _id):
    self._oprot.writeMessageBegin('IsValueWriteOnly', TMessageType.CALL, self._seqid)
    args = IsValueWriteOnly_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValueWriteOnly(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValueWriteOnly_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValueWriteOnly failed: unknown result");

  def IsValueSet(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_IsValueSet(_id)
    return self.recv_IsValueSet()

  def send_IsValueSet(self, _id):
    self._oprot.writeMessageBegin('IsValueSet', TMessageType.CALL, self._seqid)
    args = IsValueSet_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValueSet(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValueSet_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValueSet failed: unknown result");

  def IsValuePolled(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_IsValuePolled(_id)
    return self.recv_IsValuePolled()

  def send_IsValuePolled(self, _id):
    self._oprot.writeMessageBegin('IsValuePolled', TMessageType.CALL, self._seqid)
    args = IsValuePolled_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValuePolled(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValuePolled_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValuePolled failed: unknown result");

  def GetValueAsBool(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueAsBool(_id)
    return self.recv_GetValueAsBool()

  def send_GetValueAsBool(self, _id):
    self._oprot.writeMessageBegin('GetValueAsBool', TMessageType.CALL, self._seqid)
    args = GetValueAsBool_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsBool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsBool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsBool failed: unknown result");

  def GetValueAsByte(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueAsByte(_id)
    return self.recv_GetValueAsByte()

  def send_GetValueAsByte(self, _id):
    self._oprot.writeMessageBegin('GetValueAsByte', TMessageType.CALL, self._seqid)
    args = GetValueAsByte_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsByte(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsByte_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsByte failed: unknown result");

  def GetValueAsFloat(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueAsFloat(_id)
    return self.recv_GetValueAsFloat()

  def send_GetValueAsFloat(self, _id):
    self._oprot.writeMessageBegin('GetValueAsFloat', TMessageType.CALL, self._seqid)
    args = GetValueAsFloat_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsFloat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsFloat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsFloat failed: unknown result");

  def GetValueAsInt(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueAsInt(_id)
    return self.recv_GetValueAsInt()

  def send_GetValueAsInt(self, _id):
    self._oprot.writeMessageBegin('GetValueAsInt', TMessageType.CALL, self._seqid)
    args = GetValueAsInt_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsInt(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsInt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsInt failed: unknown result");

  def GetValueAsShort(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueAsShort(_id)
    return self.recv_GetValueAsShort()

  def send_GetValueAsShort(self, _id):
    self._oprot.writeMessageBegin('GetValueAsShort', TMessageType.CALL, self._seqid)
    args = GetValueAsShort_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsShort(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsShort_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsShort failed: unknown result");

  def GetValueAsString(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueAsString(_id)
    return self.recv_GetValueAsString()

  def send_GetValueAsString(self, _id):
    self._oprot.writeMessageBegin('GetValueAsString', TMessageType.CALL, self._seqid)
    args = GetValueAsString_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsString(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsString_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsString failed: unknown result");

  def GetValueListSelection_String(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueListSelection_String(_id)
    return self.recv_GetValueListSelection_String()

  def send_GetValueListSelection_String(self, _id):
    self._oprot.writeMessageBegin('GetValueListSelection_String', TMessageType.CALL, self._seqid)
    args = GetValueListSelection_String_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueListSelection_String failed: unknown result");

  def GetValueListSelection_Int32(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueListSelection_Int32(_id)
    return self.recv_GetValueListSelection_Int32()

  def send_GetValueListSelection_Int32(self, _id):
    self._oprot.writeMessageBegin('GetValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = GetValueListSelection_Int32_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueListSelection_Int32 failed: unknown result");

  def GetValueListItems(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueListItems(_id)
    return self.recv_GetValueListItems()

  def send_GetValueListItems(self, _id):
    self._oprot.writeMessageBegin('GetValueListItems', TMessageType.CALL, self._seqid)
    args = GetValueListItems_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueListItems(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueListItems_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueListItems failed: unknown result");

  def GetValueFloatPrecision(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetValueFloatPrecision(_id)
    return self.recv_GetValueFloatPrecision()

  def send_GetValueFloatPrecision(self, _id):
    self._oprot.writeMessageBegin('GetValueFloatPrecision', TMessageType.CALL, self._seqid)
    args = GetValueFloatPrecision_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueFloatPrecision(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueFloatPrecision_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueFloatPrecision failed: unknown result");

  def SetValue_Bool(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Bool(_id, _value)
    return self.recv_SetValue_Bool()

  def send_SetValue_Bool(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Bool', TMessageType.CALL, self._seqid)
    args = SetValue_Bool_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Bool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Bool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Bool failed: unknown result");

  def SetValue_UInt8(self, _id, _value, _length):
    """
    Parameters:
     - _id
     - _value
     - _length
    """
    self.send_SetValue_UInt8(_id, _value, _length)
    return self.recv_SetValue_UInt8()

  def send_SetValue_UInt8(self, _id, _value, _length):
    self._oprot.writeMessageBegin('SetValue_UInt8', TMessageType.CALL, self._seqid)
    args = SetValue_UInt8_args()
    args._id = _id
    args._value = _value
    args._length = _length
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_UInt8(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_UInt8_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_UInt8 failed: unknown result");

  def SetValue_Float(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Float(_id, _value)
    return self.recv_SetValue_Float()

  def send_SetValue_Float(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Float', TMessageType.CALL, self._seqid)
    args = SetValue_Float_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Float(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Float_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Float failed: unknown result");

  def SetValue_Int32(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Int32(_id, _value)
    return self.recv_SetValue_Int32()

  def send_SetValue_Int32(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Int32', TMessageType.CALL, self._seqid)
    args = SetValue_Int32_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Int32 failed: unknown result");

  def SetValue_Int16(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Int16(_id, _value)
    return self.recv_SetValue_Int16()

  def send_SetValue_Int16(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Int16', TMessageType.CALL, self._seqid)
    args = SetValue_Int16_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Int16(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Int16_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Int16 failed: unknown result");

  def SetValue_String(self, _id, _value):
    """
    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_String(_id, _value)
    return self.recv_SetValue_String()

  def send_SetValue_String(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_String', TMessageType.CALL, self._seqid)
    args = SetValue_String_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_String failed: unknown result");

  def SetValueListSelection(self, _id, _selectedItem):
    """
    Parameters:
     - _id
     - _selectedItem
    """
    self.send_SetValueListSelection(_id, _selectedItem)
    return self.recv_SetValueListSelection()

  def send_SetValueListSelection(self, _id, _selectedItem):
    self._oprot.writeMessageBegin('SetValueListSelection', TMessageType.CALL, self._seqid)
    args = SetValueListSelection_args()
    args._id = _id
    args._selectedItem = _selectedItem
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueListSelection(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueListSelection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValueListSelection failed: unknown result");

  def RefreshValue(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_RefreshValue(_id)
    return self.recv_RefreshValue()

  def send_RefreshValue(self, _id):
    self._oprot.writeMessageBegin('RefreshValue', TMessageType.CALL, self._seqid)
    args = RefreshValue_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RefreshValue(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RefreshValue_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RefreshValue failed: unknown result");

  def SetChangeVerified(self, _id, _verify):
    """
    Parameters:
     - _id
     - _verify
    """
    self.send_SetChangeVerified(_id, _verify)
    self.recv_SetChangeVerified()

  def send_SetChangeVerified(self, _id, _verify):
    self._oprot.writeMessageBegin('SetChangeVerified', TMessageType.CALL, self._seqid)
    args = SetChangeVerified_args()
    args._id = _id
    args._verify = _verify
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetChangeVerified(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetChangeVerified_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def PressButton(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_PressButton(_id)
    return self.recv_PressButton()

  def send_PressButton(self, _id):
    self._oprot.writeMessageBegin('PressButton', TMessageType.CALL, self._seqid)
    args = PressButton_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_PressButton(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = PressButton_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "PressButton failed: unknown result");

  def ReleaseButton(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_ReleaseButton(_id)
    return self.recv_ReleaseButton()

  def send_ReleaseButton(self, _id):
    self._oprot.writeMessageBegin('ReleaseButton', TMessageType.CALL, self._seqid)
    args = ReleaseButton_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ReleaseButton(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ReleaseButton_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ReleaseButton failed: unknown result");

  def GetNumSwitchPoints(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_GetNumSwitchPoints(_id)
    return self.recv_GetNumSwitchPoints()

  def send_GetNumSwitchPoints(self, _id):
    self._oprot.writeMessageBegin('GetNumSwitchPoints', TMessageType.CALL, self._seqid)
    args = GetNumSwitchPoints_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNumSwitchPoints(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNumSwitchPoints_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumSwitchPoints failed: unknown result");

  def SetSwitchPoint(self, _id, _hours, _minutes, _setback):
    """
    Parameters:
     - _id
     - _hours
     - _minutes
     - _setback
    """
    self.send_SetSwitchPoint(_id, _hours, _minutes, _setback)
    return self.recv_SetSwitchPoint()

  def send_SetSwitchPoint(self, _id, _hours, _minutes, _setback):
    self._oprot.writeMessageBegin('SetSwitchPoint', TMessageType.CALL, self._seqid)
    args = SetSwitchPoint_args()
    args._id = _id
    args._hours = _hours
    args._minutes = _minutes
    args._setback = _setback
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSwitchPoint(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSwitchPoint_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSwitchPoint failed: unknown result");

  def RemoveSwitchPoint(self, _id, _hours, _minutes):
    """
    Parameters:
     - _id
     - _hours
     - _minutes
    """
    self.send_RemoveSwitchPoint(_id, _hours, _minutes)
    return self.recv_RemoveSwitchPoint()

  def send_RemoveSwitchPoint(self, _id, _hours, _minutes):
    self._oprot.writeMessageBegin('RemoveSwitchPoint', TMessageType.CALL, self._seqid)
    args = RemoveSwitchPoint_args()
    args._id = _id
    args._hours = _hours
    args._minutes = _minutes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveSwitchPoint(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveSwitchPoint_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveSwitchPoint failed: unknown result");

  def ClearSwitchPoints(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_ClearSwitchPoints(_id)
    self.recv_ClearSwitchPoints()

  def send_ClearSwitchPoints(self, _id):
    self._oprot.writeMessageBegin('ClearSwitchPoints', TMessageType.CALL, self._seqid)
    args = ClearSwitchPoints_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ClearSwitchPoints(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ClearSwitchPoints_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetSwitchPoint(self, _id, _idx):
    """
    Parameters:
     - _id
     - _idx
    """
    self.send_GetSwitchPoint(_id, _idx)
    return self.recv_GetSwitchPoint()

  def send_GetSwitchPoint(self, _id, _idx):
    self._oprot.writeMessageBegin('GetSwitchPoint', TMessageType.CALL, self._seqid)
    args = GetSwitchPoint_args()
    args._id = _id
    args._idx = _idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSwitchPoint(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSwitchPoint_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSwitchPoint failed: unknown result");

  def SwitchAllOn(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_SwitchAllOn(_homeId)
    self.recv_SwitchAllOn()

  def send_SwitchAllOn(self, _homeId):
    self._oprot.writeMessageBegin('SwitchAllOn', TMessageType.CALL, self._seqid)
    args = SwitchAllOn_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SwitchAllOn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SwitchAllOn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SwitchAllOff(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_SwitchAllOff(_homeId)
    self.recv_SwitchAllOff()

  def send_SwitchAllOff(self, _homeId):
    self._oprot.writeMessageBegin('SwitchAllOff', TMessageType.CALL, self._seqid)
    args = SwitchAllOff_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SwitchAllOff(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SwitchAllOff_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetConfigParam(self, _homeId, _nodeId, _param, _value, _size):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _param
     - _value
     - _size
    """
    self.send_SetConfigParam(_homeId, _nodeId, _param, _value, _size)
    return self.recv_SetConfigParam()

  def send_SetConfigParam(self, _homeId, _nodeId, _param, _value, _size):
    self._oprot.writeMessageBegin('SetConfigParam', TMessageType.CALL, self._seqid)
    args = SetConfigParam_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._param = _param
    args._value = _value
    args._size = _size
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetConfigParam(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetConfigParam_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetConfigParam failed: unknown result");

  def RequestConfigParam(self, _homeId, _nodeId, _param):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _param
    """
    self.send_RequestConfigParam(_homeId, _nodeId, _param)
    self.recv_RequestConfigParam()

  def send_RequestConfigParam(self, _homeId, _nodeId, _param):
    self._oprot.writeMessageBegin('RequestConfigParam', TMessageType.CALL, self._seqid)
    args = RequestConfigParam_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._param = _param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestConfigParam(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestConfigParam_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RequestAllConfigParams(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RequestAllConfigParams(_homeId, _nodeId)
    self.recv_RequestAllConfigParams()

  def send_RequestAllConfigParams(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RequestAllConfigParams', TMessageType.CALL, self._seqid)
    args = RequestAllConfigParams_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestAllConfigParams(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestAllConfigParams_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetNumGroups(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNumGroups(_homeId, _nodeId)
    return self.recv_GetNumGroups()

  def send_GetNumGroups(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNumGroups', TMessageType.CALL, self._seqid)
    args = GetNumGroups_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNumGroups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNumGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumGroups failed: unknown result");

  def GetAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    self.send_GetAssociations(_homeId, _nodeId, _groupIdx)
    return self.recv_GetAssociations()

  def send_GetAssociations(self, _homeId, _nodeId, _groupIdx):
    self._oprot.writeMessageBegin('GetAssociations', TMessageType.CALL, self._seqid)
    args = GetAssociations_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAssociations(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetAssociations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAssociations failed: unknown result");

  def GetMaxAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    self.send_GetMaxAssociations(_homeId, _nodeId, _groupIdx)
    return self.recv_GetMaxAssociations()

  def send_GetMaxAssociations(self, _homeId, _nodeId, _groupIdx):
    self._oprot.writeMessageBegin('GetMaxAssociations', TMessageType.CALL, self._seqid)
    args = GetMaxAssociations_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetMaxAssociations(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetMaxAssociations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMaxAssociations failed: unknown result");

  def GetGroupLabel(self, _homeId, _nodeId, _groupIdx):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    self.send_GetGroupLabel(_homeId, _nodeId, _groupIdx)
    return self.recv_GetGroupLabel()

  def send_GetGroupLabel(self, _homeId, _nodeId, _groupIdx):
    self._oprot.writeMessageBegin('GetGroupLabel', TMessageType.CALL, self._seqid)
    args = GetGroupLabel_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetGroupLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetGroupLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupLabel failed: unknown result");

  def AddAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    self.send_AddAssociation(_homeId, _nodeId, _groupIdx, _targetNodeId)
    self.recv_AddAssociation()

  def send_AddAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    self._oprot.writeMessageBegin('AddAssociation', TMessageType.CALL, self._seqid)
    args = AddAssociation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args._targetNodeId = _targetNodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddAssociation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddAssociation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RemoveAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    self.send_RemoveAssociation(_homeId, _nodeId, _groupIdx, _targetNodeId)
    self.recv_RemoveAssociation()

  def send_RemoveAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    self._oprot.writeMessageBegin('RemoveAssociation', TMessageType.CALL, self._seqid)
    args = RemoveAssociation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args._targetNodeId = _targetNodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveAssociation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveAssociation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def ResetController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_ResetController(_homeId)
    self.recv_ResetController()

  def send_ResetController(self, _homeId):
    self._oprot.writeMessageBegin('ResetController', TMessageType.CALL, self._seqid)
    args = ResetController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ResetController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ResetController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SoftReset(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_SoftReset(_homeId)
    self.recv_SoftReset()

  def send_SoftReset(self, _homeId):
    self._oprot.writeMessageBegin('SoftReset', TMessageType.CALL, self._seqid)
    args = SoftReset_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SoftReset(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SoftReset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def BeginControllerCommand(self, _homeId, _command, _highPower, _nodeId, _arg):
    """
    Parameters:
     - _homeId
     - _command
     - _highPower
     - _nodeId
     - _arg
    """
    self.send_BeginControllerCommand(_homeId, _command, _highPower, _nodeId, _arg)
    return self.recv_BeginControllerCommand()

  def send_BeginControllerCommand(self, _homeId, _command, _highPower, _nodeId, _arg):
    self._oprot.writeMessageBegin('BeginControllerCommand', TMessageType.CALL, self._seqid)
    args = BeginControllerCommand_args()
    args._homeId = _homeId
    args._command = _command
    args._highPower = _highPower
    args._nodeId = _nodeId
    args._arg = _arg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_BeginControllerCommand(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = BeginControllerCommand_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "BeginControllerCommand failed: unknown result");

  def CancelControllerCommand(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_CancelControllerCommand(_homeId)
    return self.recv_CancelControllerCommand()

  def send_CancelControllerCommand(self, _homeId):
    self._oprot.writeMessageBegin('CancelControllerCommand', TMessageType.CALL, self._seqid)
    args = CancelControllerCommand_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CancelControllerCommand(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = CancelControllerCommand_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CancelControllerCommand failed: unknown result");

  def TestNetworkNode(self, _homeId, _nodeId, _count):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _count
    """
    self.send_TestNetworkNode(_homeId, _nodeId, _count)
    self.recv_TestNetworkNode()

  def send_TestNetworkNode(self, _homeId, _nodeId, _count):
    self._oprot.writeMessageBegin('TestNetworkNode', TMessageType.CALL, self._seqid)
    args = TestNetworkNode_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._count = _count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_TestNetworkNode(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = TestNetworkNode_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def TestNetwork(self, _homeId, _count):
    """
    Parameters:
     - _homeId
     - _count
    """
    self.send_TestNetwork(_homeId, _count)
    self.recv_TestNetwork()

  def send_TestNetwork(self, _homeId, _count):
    self._oprot.writeMessageBegin('TestNetwork', TMessageType.CALL, self._seqid)
    args = TestNetwork_args()
    args._homeId = _homeId
    args._count = _count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_TestNetwork(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = TestNetwork_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def HealNetworkNode(self, _homeId, _nodeId, _doRR):
    """
    Parameters:
     - _homeId
     - _nodeId
     - _doRR
    """
    self.send_HealNetworkNode(_homeId, _nodeId, _doRR)
    self.recv_HealNetworkNode()

  def send_HealNetworkNode(self, _homeId, _nodeId, _doRR):
    self._oprot.writeMessageBegin('HealNetworkNode', TMessageType.CALL, self._seqid)
    args = HealNetworkNode_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._doRR = _doRR
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_HealNetworkNode(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = HealNetworkNode_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def HealNetwork(self, _homeId, _doRR):
    """
    Parameters:
     - _homeId
     - _doRR
    """
    self.send_HealNetwork(_homeId, _doRR)
    self.recv_HealNetwork()

  def send_HealNetwork(self, _homeId, _doRR):
    self._oprot.writeMessageBegin('HealNetwork', TMessageType.CALL, self._seqid)
    args = HealNetwork_args()
    args._homeId = _homeId
    args._doRR = _doRR
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_HealNetwork(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = HealNetwork_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetNumScenes(self, ):
    self.send_GetNumScenes()
    return self.recv_GetNumScenes()

  def send_GetNumScenes(self, ):
    self._oprot.writeMessageBegin('GetNumScenes', TMessageType.CALL, self._seqid)
    args = GetNumScenes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNumScenes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNumScenes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumScenes failed: unknown result");

  def GetAllScenes(self, ):
    self.send_GetAllScenes()
    return self.recv_GetAllScenes()

  def send_GetAllScenes(self, ):
    self._oprot.writeMessageBegin('GetAllScenes', TMessageType.CALL, self._seqid)
    args = GetAllScenes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAllScenes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetAllScenes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAllScenes failed: unknown result");

  def RemoveAllScenes(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_RemoveAllScenes(_homeId)
    self.recv_RemoveAllScenes()

  def send_RemoveAllScenes(self, _homeId):
    self._oprot.writeMessageBegin('RemoveAllScenes', TMessageType.CALL, self._seqid)
    args = RemoveAllScenes_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveAllScenes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveAllScenes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def CreateScene(self, ):
    self.send_CreateScene()
    return self.recv_CreateScene()

  def send_CreateScene(self, ):
    self._oprot.writeMessageBegin('CreateScene', TMessageType.CALL, self._seqid)
    args = CreateScene_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CreateScene(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = CreateScene_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateScene failed: unknown result");

  def RemoveScene(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    self.send_RemoveScene(_sceneId)
    return self.recv_RemoveScene()

  def send_RemoveScene(self, _sceneId):
    self._oprot.writeMessageBegin('RemoveScene', TMessageType.CALL, self._seqid)
    args = RemoveScene_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveScene(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveScene_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveScene failed: unknown result");

  def AddSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Bool(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Bool()

  def send_AddSceneValue_Bool(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Bool', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Bool_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Bool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Bool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Bool failed: unknown result");

  def AddSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Uint8(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Uint8()

  def send_AddSceneValue_Uint8(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Uint8', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Uint8_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Uint8(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Uint8_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Uint8 failed: unknown result");

  def AddSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Float(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Float()

  def send_AddSceneValue_Float(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Float', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Float_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Float(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Float_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Float failed: unknown result");

  def AddSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Int32(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Int32()

  def send_AddSceneValue_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Int32', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Int32 failed: unknown result");

  def AddSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Int16(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Int16()

  def send_AddSceneValue_Int16(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Int16', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Int16_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Int16(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Int16_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Int16 failed: unknown result");

  def AddSceneValue_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_String(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_String()

  def send_AddSceneValue_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_String', TMessageType.CALL, self._seqid)
    args = AddSceneValue_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_String failed: unknown result");

  def AddSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValueListSelection_String(_sceneId, _valueId, _value)
    return self.recv_AddSceneValueListSelection_String()

  def send_AddSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValueListSelection_String', TMessageType.CALL, self._seqid)
    args = AddSceneValueListSelection_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValueListSelection_String failed: unknown result");

  def AddSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValueListSelection_Int32(_sceneId, _valueId, _value)
    return self.recv_AddSceneValueListSelection_Int32()

  def send_AddSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = AddSceneValueListSelection_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValueListSelection_Int32 failed: unknown result");

  def RemoveSceneValue(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_RemoveSceneValue(_sceneId, _valueId)
    return self.recv_RemoveSceneValue()

  def send_RemoveSceneValue(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('RemoveSceneValue', TMessageType.CALL, self._seqid)
    args = RemoveSceneValue_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveSceneValue(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveSceneValue_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveSceneValue failed: unknown result");

  def SceneGetValues(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    self.send_SceneGetValues(_sceneId)
    return self.recv_SceneGetValues()

  def send_SceneGetValues(self, _sceneId):
    self._oprot.writeMessageBegin('SceneGetValues', TMessageType.CALL, self._seqid)
    args = SceneGetValues_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValues(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValues_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValues failed: unknown result");

  def SceneGetValueAsBool(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsBool(_sceneId, _valueId)
    return self.recv_SceneGetValueAsBool()

  def send_SceneGetValueAsBool(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsBool', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsBool_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsBool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsBool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsBool failed: unknown result");

  def SceneGetValueAsByte(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsByte(_sceneId, _valueId)
    return self.recv_SceneGetValueAsByte()

  def send_SceneGetValueAsByte(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsByte', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsByte_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsByte(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsByte_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsByte failed: unknown result");

  def SceneGetValueAsFloat(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsFloat(_sceneId, _valueId)
    return self.recv_SceneGetValueAsFloat()

  def send_SceneGetValueAsFloat(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsFloat', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsFloat_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsFloat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsFloat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsFloat failed: unknown result");

  def SceneGetValueAsInt(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsInt(_sceneId, _valueId)
    return self.recv_SceneGetValueAsInt()

  def send_SceneGetValueAsInt(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsInt', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsInt_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsInt(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsInt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsInt failed: unknown result");

  def SceneGetValueAsShort(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsShort(_sceneId, _valueId)
    return self.recv_SceneGetValueAsShort()

  def send_SceneGetValueAsShort(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsShort', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsShort_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsShort(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsShort_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsShort failed: unknown result");

  def SceneGetValueAsString(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsString(_sceneId, _valueId)
    return self.recv_SceneGetValueAsString()

  def send_SceneGetValueAsString(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsString', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsString_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsString(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsString_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsString failed: unknown result");

  def SceneGetValueListSelection_String(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueListSelection_String(_sceneId, _valueId)
    return self.recv_SceneGetValueListSelection_String()

  def send_SceneGetValueListSelection_String(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueListSelection_String', TMessageType.CALL, self._seqid)
    args = SceneGetValueListSelection_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueListSelection_String failed: unknown result");

  def SceneGetValueListSelection_Int32(self, _sceneId, _valueId):
    """
    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueListSelection_Int32(_sceneId, _valueId)
    return self.recv_SceneGetValueListSelection_Int32()

  def send_SceneGetValueListSelection_Int32(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = SceneGetValueListSelection_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueListSelection_Int32 failed: unknown result");

  def SetSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Bool(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Bool()

  def send_SetSceneValue_Bool(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Bool', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Bool_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Bool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Bool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Bool failed: unknown result");

  def SetSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Uint8(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Uint8()

  def send_SetSceneValue_Uint8(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Uint8', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Uint8_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Uint8(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Uint8_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Uint8 failed: unknown result");

  def SetSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Float(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Float()

  def send_SetSceneValue_Float(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Float', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Float_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Float(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Float_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Float failed: unknown result");

  def SetSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Int32(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Int32()

  def send_SetSceneValue_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Int32', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Int32 failed: unknown result");

  def SetSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Int16(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Int16()

  def send_SetSceneValue_Int16(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Int16', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Int16_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Int16(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Int16_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Int16 failed: unknown result");

  def SetSceneValue_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_String(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_String()

  def send_SetSceneValue_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_String', TMessageType.CALL, self._seqid)
    args = SetSceneValue_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_String failed: unknown result");

  def SetSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValueListSelection_String(_sceneId, _valueId, _value)
    return self.recv_SetSceneValueListSelection_String()

  def send_SetSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValueListSelection_String', TMessageType.CALL, self._seqid)
    args = SetSceneValueListSelection_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValueListSelection_String failed: unknown result");

  def SetSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValueListSelection_Int32(_sceneId, _valueId, _value)
    return self.recv_SetSceneValueListSelection_Int32()

  def send_SetSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = SetSceneValueListSelection_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValueListSelection_Int32 failed: unknown result");

  def GetSceneLabel(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    self.send_GetSceneLabel(_sceneId)
    return self.recv_GetSceneLabel()

  def send_GetSceneLabel(self, _sceneId):
    self._oprot.writeMessageBegin('GetSceneLabel', TMessageType.CALL, self._seqid)
    args = GetSceneLabel_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSceneLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSceneLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSceneLabel failed: unknown result");

  def SetSceneLabel(self, _sceneId, _value):
    """
    Parameters:
     - _sceneId
     - _value
    """
    self.send_SetSceneLabel(_sceneId, _value)
    self.recv_SetSceneLabel()

  def send_SetSceneLabel(self, _sceneId, _value):
    self._oprot.writeMessageBegin('SetSceneLabel', TMessageType.CALL, self._seqid)
    args = SetSceneLabel_args()
    args._sceneId = _sceneId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SceneExists(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    self.send_SceneExists(_sceneId)
    return self.recv_SceneExists()

  def send_SceneExists(self, _sceneId):
    self._oprot.writeMessageBegin('SceneExists', TMessageType.CALL, self._seqid)
    args = SceneExists_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneExists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneExists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneExists failed: unknown result");

  def ActivateScene(self, _sceneId):
    """
    Parameters:
     - _sceneId
    """
    self.send_ActivateScene(_sceneId)
    return self.recv_ActivateScene()

  def send_ActivateScene(self, _sceneId):
    self._oprot.writeMessageBegin('ActivateScene', TMessageType.CALL, self._seqid)
    args = ActivateScene_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ActivateScene(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ActivateScene_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ActivateScene failed: unknown result");

  def GetDriverStatistics(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_GetDriverStatistics(_homeId)
    return self.recv_GetDriverStatistics()

  def send_GetDriverStatistics(self, _homeId):
    self._oprot.writeMessageBegin('GetDriverStatistics', TMessageType.CALL, self._seqid)
    args = GetDriverStatistics_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDriverStatistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetDriverStatistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDriverStatistics failed: unknown result");

  def GetNodeStatistics(self, _homeId, _nodeId):
    """
    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeStatistics(_homeId, _nodeId)
    return self.recv_GetNodeStatistics()

  def send_GetNodeStatistics(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeStatistics', TMessageType.CALL, self._seqid)
    args = GetNodeStatistics_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeStatistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeStatistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeStatistics failed: unknown result");

  def SendAllValues(self, ):
    self.send_SendAllValues()
    self.recv_SendAllValues()

  def send_SendAllValues(self, ):
    self._oprot.writeMessageBegin('SendAllValues', TMessageType.CALL, self._seqid)
    args = SendAllValues_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SendAllValues(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SendAllValues_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def ping(self, ):
    self.send_ping()
    self.recv_ping()

  def send_ping(self, ):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["WriteConfig"] = Processor.process_WriteConfig
    self._processMap["GetControllerNodeId"] = Processor.process_GetControllerNodeId
    self._processMap["GetSUCNodeId"] = Processor.process_GetSUCNodeId
    self._processMap["IsPrimaryController"] = Processor.process_IsPrimaryController
    self._processMap["IsStaticUpdateController"] = Processor.process_IsStaticUpdateController
    self._processMap["IsBridgeController"] = Processor.process_IsBridgeController
    self._processMap["GetLibraryVersion"] = Processor.process_GetLibraryVersion
    self._processMap["GetLibraryTypeName"] = Processor.process_GetLibraryTypeName
    self._processMap["GetSendQueueCount"] = Processor.process_GetSendQueueCount
    self._processMap["LogDriverStatistics"] = Processor.process_LogDriverStatistics
    self._processMap["GetControllerPath"] = Processor.process_GetControllerPath
    self._processMap["GetPollInterval"] = Processor.process_GetPollInterval
    self._processMap["SetPollInterval"] = Processor.process_SetPollInterval
    self._processMap["EnablePoll"] = Processor.process_EnablePoll
    self._processMap["DisablePoll"] = Processor.process_DisablePoll
    self._processMap["isPolled"] = Processor.process_isPolled
    self._processMap["SetPollIntensity"] = Processor.process_SetPollIntensity
    self._processMap["RefreshNodeInfo"] = Processor.process_RefreshNodeInfo
    self._processMap["RequestNodeState"] = Processor.process_RequestNodeState
    self._processMap["RequestNodeDynamic"] = Processor.process_RequestNodeDynamic
    self._processMap["IsNodeListeningDevice"] = Processor.process_IsNodeListeningDevice
    self._processMap["IsNodeFrequentListeningDevice"] = Processor.process_IsNodeFrequentListeningDevice
    self._processMap["IsNodeBeamingDevice"] = Processor.process_IsNodeBeamingDevice
    self._processMap["IsNodeRoutingDevice"] = Processor.process_IsNodeRoutingDevice
    self._processMap["IsNodeSecurityDevice"] = Processor.process_IsNodeSecurityDevice
    self._processMap["GetNodeMaxBaudRate"] = Processor.process_GetNodeMaxBaudRate
    self._processMap["GetNodeVersion"] = Processor.process_GetNodeVersion
    self._processMap["GetNodeSecurity"] = Processor.process_GetNodeSecurity
    self._processMap["GetNodeBasic"] = Processor.process_GetNodeBasic
    self._processMap["GetNodeGeneric"] = Processor.process_GetNodeGeneric
    self._processMap["GetNodeSpecific"] = Processor.process_GetNodeSpecific
    self._processMap["GetNodeType"] = Processor.process_GetNodeType
    self._processMap["GetNodeNeighbors"] = Processor.process_GetNodeNeighbors
    self._processMap["GetNodeManufacturerName"] = Processor.process_GetNodeManufacturerName
    self._processMap["GetNodeProductName"] = Processor.process_GetNodeProductName
    self._processMap["GetNodeName"] = Processor.process_GetNodeName
    self._processMap["GetNodeLocation"] = Processor.process_GetNodeLocation
    self._processMap["GetNodeManufacturerId"] = Processor.process_GetNodeManufacturerId
    self._processMap["GetNodeProductType"] = Processor.process_GetNodeProductType
    self._processMap["GetNodeProductId"] = Processor.process_GetNodeProductId
    self._processMap["SetNodeManufacturerName"] = Processor.process_SetNodeManufacturerName
    self._processMap["SetNodeProductName"] = Processor.process_SetNodeProductName
    self._processMap["SetNodeName"] = Processor.process_SetNodeName
    self._processMap["SetNodeLocation"] = Processor.process_SetNodeLocation
    self._processMap["SetNodeOn"] = Processor.process_SetNodeOn
    self._processMap["SetNodeOff"] = Processor.process_SetNodeOff
    self._processMap["SetNodeLevel"] = Processor.process_SetNodeLevel
    self._processMap["IsNodeInfoReceived"] = Processor.process_IsNodeInfoReceived
    self._processMap["GetNodeClassInformation"] = Processor.process_GetNodeClassInformation
    self._processMap["IsNodeAwake"] = Processor.process_IsNodeAwake
    self._processMap["IsNodeFailed"] = Processor.process_IsNodeFailed
    self._processMap["GetNodeQueryStage"] = Processor.process_GetNodeQueryStage
    self._processMap["GetValueLabel"] = Processor.process_GetValueLabel
    self._processMap["SetValueLabel"] = Processor.process_SetValueLabel
    self._processMap["GetValueUnits"] = Processor.process_GetValueUnits
    self._processMap["SetValueUnits"] = Processor.process_SetValueUnits
    self._processMap["GetValueHelp"] = Processor.process_GetValueHelp
    self._processMap["SetValueHelp"] = Processor.process_SetValueHelp
    self._processMap["GetValueMin"] = Processor.process_GetValueMin
    self._processMap["GetValueMax"] = Processor.process_GetValueMax
    self._processMap["IsValueReadOnly"] = Processor.process_IsValueReadOnly
    self._processMap["IsValueWriteOnly"] = Processor.process_IsValueWriteOnly
    self._processMap["IsValueSet"] = Processor.process_IsValueSet
    self._processMap["IsValuePolled"] = Processor.process_IsValuePolled
    self._processMap["GetValueAsBool"] = Processor.process_GetValueAsBool
    self._processMap["GetValueAsByte"] = Processor.process_GetValueAsByte
    self._processMap["GetValueAsFloat"] = Processor.process_GetValueAsFloat
    self._processMap["GetValueAsInt"] = Processor.process_GetValueAsInt
    self._processMap["GetValueAsShort"] = Processor.process_GetValueAsShort
    self._processMap["GetValueAsString"] = Processor.process_GetValueAsString
    self._processMap["GetValueListSelection_String"] = Processor.process_GetValueListSelection_String
    self._processMap["GetValueListSelection_Int32"] = Processor.process_GetValueListSelection_Int32
    self._processMap["GetValueListItems"] = Processor.process_GetValueListItems
    self._processMap["GetValueFloatPrecision"] = Processor.process_GetValueFloatPrecision
    self._processMap["SetValue_Bool"] = Processor.process_SetValue_Bool
    self._processMap["SetValue_UInt8"] = Processor.process_SetValue_UInt8
    self._processMap["SetValue_Float"] = Processor.process_SetValue_Float
    self._processMap["SetValue_Int32"] = Processor.process_SetValue_Int32
    self._processMap["SetValue_Int16"] = Processor.process_SetValue_Int16
    self._processMap["SetValue_String"] = Processor.process_SetValue_String
    self._processMap["SetValueListSelection"] = Processor.process_SetValueListSelection
    self._processMap["RefreshValue"] = Processor.process_RefreshValue
    self._processMap["SetChangeVerified"] = Processor.process_SetChangeVerified
    self._processMap["PressButton"] = Processor.process_PressButton
    self._processMap["ReleaseButton"] = Processor.process_ReleaseButton
    self._processMap["GetNumSwitchPoints"] = Processor.process_GetNumSwitchPoints
    self._processMap["SetSwitchPoint"] = Processor.process_SetSwitchPoint
    self._processMap["RemoveSwitchPoint"] = Processor.process_RemoveSwitchPoint
    self._processMap["ClearSwitchPoints"] = Processor.process_ClearSwitchPoints
    self._processMap["GetSwitchPoint"] = Processor.process_GetSwitchPoint
    self._processMap["SwitchAllOn"] = Processor.process_SwitchAllOn
    self._processMap["SwitchAllOff"] = Processor.process_SwitchAllOff
    self._processMap["SetConfigParam"] = Processor.process_SetConfigParam
    self._processMap["RequestConfigParam"] = Processor.process_RequestConfigParam
    self._processMap["RequestAllConfigParams"] = Processor.process_RequestAllConfigParams
    self._processMap["GetNumGroups"] = Processor.process_GetNumGroups
    self._processMap["GetAssociations"] = Processor.process_GetAssociations
    self._processMap["GetMaxAssociations"] = Processor.process_GetMaxAssociations
    self._processMap["GetGroupLabel"] = Processor.process_GetGroupLabel
    self._processMap["AddAssociation"] = Processor.process_AddAssociation
    self._processMap["RemoveAssociation"] = Processor.process_RemoveAssociation
    self._processMap["ResetController"] = Processor.process_ResetController
    self._processMap["SoftReset"] = Processor.process_SoftReset
    self._processMap["BeginControllerCommand"] = Processor.process_BeginControllerCommand
    self._processMap["CancelControllerCommand"] = Processor.process_CancelControllerCommand
    self._processMap["TestNetworkNode"] = Processor.process_TestNetworkNode
    self._processMap["TestNetwork"] = Processor.process_TestNetwork
    self._processMap["HealNetworkNode"] = Processor.process_HealNetworkNode
    self._processMap["HealNetwork"] = Processor.process_HealNetwork
    self._processMap["GetNumScenes"] = Processor.process_GetNumScenes
    self._processMap["GetAllScenes"] = Processor.process_GetAllScenes
    self._processMap["RemoveAllScenes"] = Processor.process_RemoveAllScenes
    self._processMap["CreateScene"] = Processor.process_CreateScene
    self._processMap["RemoveScene"] = Processor.process_RemoveScene
    self._processMap["AddSceneValue_Bool"] = Processor.process_AddSceneValue_Bool
    self._processMap["AddSceneValue_Uint8"] = Processor.process_AddSceneValue_Uint8
    self._processMap["AddSceneValue_Float"] = Processor.process_AddSceneValue_Float
    self._processMap["AddSceneValue_Int32"] = Processor.process_AddSceneValue_Int32
    self._processMap["AddSceneValue_Int16"] = Processor.process_AddSceneValue_Int16
    self._processMap["AddSceneValue_String"] = Processor.process_AddSceneValue_String
    self._processMap["AddSceneValueListSelection_String"] = Processor.process_AddSceneValueListSelection_String
    self._processMap["AddSceneValueListSelection_Int32"] = Processor.process_AddSceneValueListSelection_Int32
    self._processMap["RemoveSceneValue"] = Processor.process_RemoveSceneValue
    self._processMap["SceneGetValues"] = Processor.process_SceneGetValues
    self._processMap["SceneGetValueAsBool"] = Processor.process_SceneGetValueAsBool
    self._processMap["SceneGetValueAsByte"] = Processor.process_SceneGetValueAsByte
    self._processMap["SceneGetValueAsFloat"] = Processor.process_SceneGetValueAsFloat
    self._processMap["SceneGetValueAsInt"] = Processor.process_SceneGetValueAsInt
    self._processMap["SceneGetValueAsShort"] = Processor.process_SceneGetValueAsShort
    self._processMap["SceneGetValueAsString"] = Processor.process_SceneGetValueAsString
    self._processMap["SceneGetValueListSelection_String"] = Processor.process_SceneGetValueListSelection_String
    self._processMap["SceneGetValueListSelection_Int32"] = Processor.process_SceneGetValueListSelection_Int32
    self._processMap["SetSceneValue_Bool"] = Processor.process_SetSceneValue_Bool
    self._processMap["SetSceneValue_Uint8"] = Processor.process_SetSceneValue_Uint8
    self._processMap["SetSceneValue_Float"] = Processor.process_SetSceneValue_Float
    self._processMap["SetSceneValue_Int32"] = Processor.process_SetSceneValue_Int32
    self._processMap["SetSceneValue_Int16"] = Processor.process_SetSceneValue_Int16
    self._processMap["SetSceneValue_String"] = Processor.process_SetSceneValue_String
    self._processMap["SetSceneValueListSelection_String"] = Processor.process_SetSceneValueListSelection_String
    self._processMap["SetSceneValueListSelection_Int32"] = Processor.process_SetSceneValueListSelection_Int32
    self._processMap["GetSceneLabel"] = Processor.process_GetSceneLabel
    self._processMap["SetSceneLabel"] = Processor.process_SetSceneLabel
    self._processMap["SceneExists"] = Processor.process_SceneExists
    self._processMap["ActivateScene"] = Processor.process_ActivateScene
    self._processMap["GetDriverStatistics"] = Processor.process_GetDriverStatistics
    self._processMap["GetNodeStatistics"] = Processor.process_GetNodeStatistics
    self._processMap["SendAllValues"] = Processor.process_SendAllValues
    self._processMap["ping"] = Processor.process_ping

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_WriteConfig(self, seqid, iprot, oprot):
    args = WriteConfig_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = WriteConfig_result()
    self._handler.WriteConfig(args._homeId)
    oprot.writeMessageBegin("WriteConfig", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetControllerNodeId(self, seqid, iprot, oprot):
    args = GetControllerNodeId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetControllerNodeId_result()
    result.success = self._handler.GetControllerNodeId(args._homeId)
    oprot.writeMessageBegin("GetControllerNodeId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSUCNodeId(self, seqid, iprot, oprot):
    args = GetSUCNodeId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSUCNodeId_result()
    result.success = self._handler.GetSUCNodeId(args._homeId)
    oprot.writeMessageBegin("GetSUCNodeId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsPrimaryController(self, seqid, iprot, oprot):
    args = IsPrimaryController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsPrimaryController_result()
    result.success = self._handler.IsPrimaryController(args._homeId)
    oprot.writeMessageBegin("IsPrimaryController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsStaticUpdateController(self, seqid, iprot, oprot):
    args = IsStaticUpdateController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsStaticUpdateController_result()
    result.success = self._handler.IsStaticUpdateController(args._homeId)
    oprot.writeMessageBegin("IsStaticUpdateController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsBridgeController(self, seqid, iprot, oprot):
    args = IsBridgeController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsBridgeController_result()
    result.success = self._handler.IsBridgeController(args._homeId)
    oprot.writeMessageBegin("IsBridgeController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLibraryVersion(self, seqid, iprot, oprot):
    args = GetLibraryVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLibraryVersion_result()
    result.success = self._handler.GetLibraryVersion(args._homeId)
    oprot.writeMessageBegin("GetLibraryVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLibraryTypeName(self, seqid, iprot, oprot):
    args = GetLibraryTypeName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLibraryTypeName_result()
    result.success = self._handler.GetLibraryTypeName(args._homeId)
    oprot.writeMessageBegin("GetLibraryTypeName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSendQueueCount(self, seqid, iprot, oprot):
    args = GetSendQueueCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSendQueueCount_result()
    result.success = self._handler.GetSendQueueCount(args._homeId)
    oprot.writeMessageBegin("GetSendQueueCount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LogDriverStatistics(self, seqid, iprot, oprot):
    args = LogDriverStatistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LogDriverStatistics_result()
    self._handler.LogDriverStatistics(args._homeId)
    oprot.writeMessageBegin("LogDriverStatistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetControllerPath(self, seqid, iprot, oprot):
    args = GetControllerPath_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetControllerPath_result()
    result.success = self._handler.GetControllerPath(args._homeId)
    oprot.writeMessageBegin("GetControllerPath", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetPollInterval(self, seqid, iprot, oprot):
    args = GetPollInterval_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetPollInterval_result()
    result.success = self._handler.GetPollInterval()
    oprot.writeMessageBegin("GetPollInterval", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetPollInterval(self, seqid, iprot, oprot):
    args = SetPollInterval_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetPollInterval_result()
    self._handler.SetPollInterval(args._milliseconds, args._bIntervalBetweenPolls)
    oprot.writeMessageBegin("SetPollInterval", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_EnablePoll(self, seqid, iprot, oprot):
    args = EnablePoll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = EnablePoll_result()
    result.success = self._handler.EnablePoll(args._valueId, args._intensity)
    oprot.writeMessageBegin("EnablePoll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DisablePoll(self, seqid, iprot, oprot):
    args = DisablePoll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DisablePoll_result()
    result.success = self._handler.DisablePoll(args._valueId)
    oprot.writeMessageBegin("DisablePoll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPolled(self, seqid, iprot, oprot):
    args = isPolled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPolled_result()
    result.success = self._handler.isPolled(args._valueId)
    oprot.writeMessageBegin("isPolled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetPollIntensity(self, seqid, iprot, oprot):
    args = SetPollIntensity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetPollIntensity_result()
    self._handler.SetPollIntensity(args._valueId, args._intensity)
    oprot.writeMessageBegin("SetPollIntensity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RefreshNodeInfo(self, seqid, iprot, oprot):
    args = RefreshNodeInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RefreshNodeInfo_result()
    result.success = self._handler.RefreshNodeInfo(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RefreshNodeInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestNodeState(self, seqid, iprot, oprot):
    args = RequestNodeState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestNodeState_result()
    result.success = self._handler.RequestNodeState(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RequestNodeState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestNodeDynamic(self, seqid, iprot, oprot):
    args = RequestNodeDynamic_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestNodeDynamic_result()
    result.success = self._handler.RequestNodeDynamic(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RequestNodeDynamic", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeListeningDevice(self, seqid, iprot, oprot):
    args = IsNodeListeningDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeListeningDevice_result()
    result.success = self._handler.IsNodeListeningDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeListeningDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeFrequentListeningDevice(self, seqid, iprot, oprot):
    args = IsNodeFrequentListeningDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeFrequentListeningDevice_result()
    result.success = self._handler.IsNodeFrequentListeningDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeFrequentListeningDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeBeamingDevice(self, seqid, iprot, oprot):
    args = IsNodeBeamingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeBeamingDevice_result()
    result.success = self._handler.IsNodeBeamingDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeBeamingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeRoutingDevice(self, seqid, iprot, oprot):
    args = IsNodeRoutingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeRoutingDevice_result()
    result.success = self._handler.IsNodeRoutingDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeRoutingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeSecurityDevice(self, seqid, iprot, oprot):
    args = IsNodeSecurityDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeSecurityDevice_result()
    result.success = self._handler.IsNodeSecurityDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeSecurityDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeMaxBaudRate(self, seqid, iprot, oprot):
    args = GetNodeMaxBaudRate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeMaxBaudRate_result()
    result.success = self._handler.GetNodeMaxBaudRate(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeMaxBaudRate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeVersion(self, seqid, iprot, oprot):
    args = GetNodeVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeVersion_result()
    result.success = self._handler.GetNodeVersion(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeSecurity(self, seqid, iprot, oprot):
    args = GetNodeSecurity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeSecurity_result()
    result.success = self._handler.GetNodeSecurity(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeSecurity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeBasic(self, seqid, iprot, oprot):
    args = GetNodeBasic_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeBasic_result()
    result.success = self._handler.GetNodeBasic(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeBasic", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeGeneric(self, seqid, iprot, oprot):
    args = GetNodeGeneric_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeGeneric_result()
    result.success = self._handler.GetNodeGeneric(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeGeneric", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeSpecific(self, seqid, iprot, oprot):
    args = GetNodeSpecific_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeSpecific_result()
    result.success = self._handler.GetNodeSpecific(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeSpecific", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeType(self, seqid, iprot, oprot):
    args = GetNodeType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeType_result()
    result.success = self._handler.GetNodeType(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeType", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeNeighbors(self, seqid, iprot, oprot):
    args = GetNodeNeighbors_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeNeighbors_result()
    result.success = self._handler.GetNodeNeighbors(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeNeighbors", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeManufacturerName(self, seqid, iprot, oprot):
    args = GetNodeManufacturerName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeManufacturerName_result()
    result.success = self._handler.GetNodeManufacturerName(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeManufacturerName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeProductName(self, seqid, iprot, oprot):
    args = GetNodeProductName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeProductName_result()
    result.success = self._handler.GetNodeProductName(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeProductName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeName(self, seqid, iprot, oprot):
    args = GetNodeName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeName_result()
    result.success = self._handler.GetNodeName(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeLocation(self, seqid, iprot, oprot):
    args = GetNodeLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeLocation_result()
    result.success = self._handler.GetNodeLocation(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeManufacturerId(self, seqid, iprot, oprot):
    args = GetNodeManufacturerId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeManufacturerId_result()
    result.success = self._handler.GetNodeManufacturerId(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeManufacturerId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeProductType(self, seqid, iprot, oprot):
    args = GetNodeProductType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeProductType_result()
    result.success = self._handler.GetNodeProductType(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeProductType", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeProductId(self, seqid, iprot, oprot):
    args = GetNodeProductId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeProductId_result()
    result.success = self._handler.GetNodeProductId(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeProductId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeManufacturerName(self, seqid, iprot, oprot):
    args = SetNodeManufacturerName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeManufacturerName_result()
    self._handler.SetNodeManufacturerName(args._homeId, args._nodeId, args._manufacturerName)
    oprot.writeMessageBegin("SetNodeManufacturerName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeProductName(self, seqid, iprot, oprot):
    args = SetNodeProductName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeProductName_result()
    self._handler.SetNodeProductName(args._homeId, args._nodeId, args._productName)
    oprot.writeMessageBegin("SetNodeProductName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeName(self, seqid, iprot, oprot):
    args = SetNodeName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeName_result()
    self._handler.SetNodeName(args._homeId, args._nodeId, args._nodeName)
    oprot.writeMessageBegin("SetNodeName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeLocation(self, seqid, iprot, oprot):
    args = SetNodeLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeLocation_result()
    self._handler.SetNodeLocation(args._homeId, args._nodeId, args._location)
    oprot.writeMessageBegin("SetNodeLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeOn(self, seqid, iprot, oprot):
    args = SetNodeOn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeOn_result()
    self._handler.SetNodeOn(args._homeId, args._nodeId)
    oprot.writeMessageBegin("SetNodeOn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeOff(self, seqid, iprot, oprot):
    args = SetNodeOff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeOff_result()
    self._handler.SetNodeOff(args._homeId, args._nodeId)
    oprot.writeMessageBegin("SetNodeOff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeLevel(self, seqid, iprot, oprot):
    args = SetNodeLevel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeLevel_result()
    self._handler.SetNodeLevel(args._homeId, args._nodeId, args._level)
    oprot.writeMessageBegin("SetNodeLevel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeInfoReceived(self, seqid, iprot, oprot):
    args = IsNodeInfoReceived_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeInfoReceived_result()
    result.success = self._handler.IsNodeInfoReceived(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeInfoReceived", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeClassInformation(self, seqid, iprot, oprot):
    args = GetNodeClassInformation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeClassInformation_result()
    result.success = self._handler.GetNodeClassInformation(args._homeId, args._nodeId, args._commandClassId)
    oprot.writeMessageBegin("GetNodeClassInformation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeAwake(self, seqid, iprot, oprot):
    args = IsNodeAwake_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeAwake_result()
    result.success = self._handler.IsNodeAwake(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeAwake", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeFailed(self, seqid, iprot, oprot):
    args = IsNodeFailed_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeFailed_result()
    result.success = self._handler.IsNodeFailed(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeFailed", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeQueryStage(self, seqid, iprot, oprot):
    args = GetNodeQueryStage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeQueryStage_result()
    result.success = self._handler.GetNodeQueryStage(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeQueryStage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueLabel(self, seqid, iprot, oprot):
    args = GetValueLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueLabel_result()
    result.success = self._handler.GetValueLabel(args._id)
    oprot.writeMessageBegin("GetValueLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueLabel(self, seqid, iprot, oprot):
    args = SetValueLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueLabel_result()
    self._handler.SetValueLabel(args._id, args._value)
    oprot.writeMessageBegin("SetValueLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueUnits(self, seqid, iprot, oprot):
    args = GetValueUnits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueUnits_result()
    result.success = self._handler.GetValueUnits(args._id)
    oprot.writeMessageBegin("GetValueUnits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueUnits(self, seqid, iprot, oprot):
    args = SetValueUnits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueUnits_result()
    self._handler.SetValueUnits(args._id, args._value)
    oprot.writeMessageBegin("SetValueUnits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueHelp(self, seqid, iprot, oprot):
    args = GetValueHelp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueHelp_result()
    result.success = self._handler.GetValueHelp(args._id)
    oprot.writeMessageBegin("GetValueHelp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueHelp(self, seqid, iprot, oprot):
    args = SetValueHelp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueHelp_result()
    self._handler.SetValueHelp(args._id, args._value)
    oprot.writeMessageBegin("SetValueHelp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueMin(self, seqid, iprot, oprot):
    args = GetValueMin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueMin_result()
    result.success = self._handler.GetValueMin(args._id)
    oprot.writeMessageBegin("GetValueMin", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueMax(self, seqid, iprot, oprot):
    args = GetValueMax_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueMax_result()
    result.success = self._handler.GetValueMax(args._id)
    oprot.writeMessageBegin("GetValueMax", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValueReadOnly(self, seqid, iprot, oprot):
    args = IsValueReadOnly_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValueReadOnly_result()
    result.success = self._handler.IsValueReadOnly(args._id)
    oprot.writeMessageBegin("IsValueReadOnly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValueWriteOnly(self, seqid, iprot, oprot):
    args = IsValueWriteOnly_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValueWriteOnly_result()
    result.success = self._handler.IsValueWriteOnly(args._id)
    oprot.writeMessageBegin("IsValueWriteOnly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValueSet(self, seqid, iprot, oprot):
    args = IsValueSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValueSet_result()
    result.success = self._handler.IsValueSet(args._id)
    oprot.writeMessageBegin("IsValueSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValuePolled(self, seqid, iprot, oprot):
    args = IsValuePolled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValuePolled_result()
    result.success = self._handler.IsValuePolled(args._id)
    oprot.writeMessageBegin("IsValuePolled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsBool(self, seqid, iprot, oprot):
    args = GetValueAsBool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsBool_result()
    result.success = self._handler.GetValueAsBool(args._id)
    oprot.writeMessageBegin("GetValueAsBool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsByte(self, seqid, iprot, oprot):
    args = GetValueAsByte_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsByte_result()
    result.success = self._handler.GetValueAsByte(args._id)
    oprot.writeMessageBegin("GetValueAsByte", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsFloat(self, seqid, iprot, oprot):
    args = GetValueAsFloat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsFloat_result()
    result.success = self._handler.GetValueAsFloat(args._id)
    oprot.writeMessageBegin("GetValueAsFloat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsInt(self, seqid, iprot, oprot):
    args = GetValueAsInt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsInt_result()
    result.success = self._handler.GetValueAsInt(args._id)
    oprot.writeMessageBegin("GetValueAsInt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsShort(self, seqid, iprot, oprot):
    args = GetValueAsShort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsShort_result()
    result.success = self._handler.GetValueAsShort(args._id)
    oprot.writeMessageBegin("GetValueAsShort", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsString(self, seqid, iprot, oprot):
    args = GetValueAsString_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsString_result()
    result.success = self._handler.GetValueAsString(args._id)
    oprot.writeMessageBegin("GetValueAsString", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueListSelection_String(self, seqid, iprot, oprot):
    args = GetValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueListSelection_String_result()
    result.success = self._handler.GetValueListSelection_String(args._id)
    oprot.writeMessageBegin("GetValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueListSelection_Int32(self, seqid, iprot, oprot):
    args = GetValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueListSelection_Int32_result()
    result.success = self._handler.GetValueListSelection_Int32(args._id)
    oprot.writeMessageBegin("GetValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueListItems(self, seqid, iprot, oprot):
    args = GetValueListItems_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueListItems_result()
    result.success = self._handler.GetValueListItems(args._id)
    oprot.writeMessageBegin("GetValueListItems", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueFloatPrecision(self, seqid, iprot, oprot):
    args = GetValueFloatPrecision_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueFloatPrecision_result()
    result.success = self._handler.GetValueFloatPrecision(args._id)
    oprot.writeMessageBegin("GetValueFloatPrecision", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Bool(self, seqid, iprot, oprot):
    args = SetValue_Bool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Bool_result()
    result.success = self._handler.SetValue_Bool(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Bool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_UInt8(self, seqid, iprot, oprot):
    args = SetValue_UInt8_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_UInt8_result()
    result.success = self._handler.SetValue_UInt8(args._id, args._value, args._length)
    oprot.writeMessageBegin("SetValue_UInt8", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Float(self, seqid, iprot, oprot):
    args = SetValue_Float_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Float_result()
    result.success = self._handler.SetValue_Float(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Float", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Int32(self, seqid, iprot, oprot):
    args = SetValue_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Int32_result()
    result.success = self._handler.SetValue_Int32(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Int16(self, seqid, iprot, oprot):
    args = SetValue_Int16_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Int16_result()
    result.success = self._handler.SetValue_Int16(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Int16", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_String(self, seqid, iprot, oprot):
    args = SetValue_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_String_result()
    result.success = self._handler.SetValue_String(args._id, args._value)
    oprot.writeMessageBegin("SetValue_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueListSelection(self, seqid, iprot, oprot):
    args = SetValueListSelection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueListSelection_result()
    result.success = self._handler.SetValueListSelection(args._id, args._selectedItem)
    oprot.writeMessageBegin("SetValueListSelection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RefreshValue(self, seqid, iprot, oprot):
    args = RefreshValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RefreshValue_result()
    result.success = self._handler.RefreshValue(args._id)
    oprot.writeMessageBegin("RefreshValue", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetChangeVerified(self, seqid, iprot, oprot):
    args = SetChangeVerified_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetChangeVerified_result()
    self._handler.SetChangeVerified(args._id, args._verify)
    oprot.writeMessageBegin("SetChangeVerified", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PressButton(self, seqid, iprot, oprot):
    args = PressButton_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PressButton_result()
    result.success = self._handler.PressButton(args._id)
    oprot.writeMessageBegin("PressButton", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ReleaseButton(self, seqid, iprot, oprot):
    args = ReleaseButton_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ReleaseButton_result()
    result.success = self._handler.ReleaseButton(args._id)
    oprot.writeMessageBegin("ReleaseButton", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNumSwitchPoints(self, seqid, iprot, oprot):
    args = GetNumSwitchPoints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNumSwitchPoints_result()
    result.success = self._handler.GetNumSwitchPoints(args._id)
    oprot.writeMessageBegin("GetNumSwitchPoints", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSwitchPoint(self, seqid, iprot, oprot):
    args = SetSwitchPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSwitchPoint_result()
    result.success = self._handler.SetSwitchPoint(args._id, args._hours, args._minutes, args._setback)
    oprot.writeMessageBegin("SetSwitchPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveSwitchPoint(self, seqid, iprot, oprot):
    args = RemoveSwitchPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveSwitchPoint_result()
    result.success = self._handler.RemoveSwitchPoint(args._id, args._hours, args._minutes)
    oprot.writeMessageBegin("RemoveSwitchPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ClearSwitchPoints(self, seqid, iprot, oprot):
    args = ClearSwitchPoints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ClearSwitchPoints_result()
    self._handler.ClearSwitchPoints(args._id)
    oprot.writeMessageBegin("ClearSwitchPoints", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSwitchPoint(self, seqid, iprot, oprot):
    args = GetSwitchPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSwitchPoint_result()
    result.success = self._handler.GetSwitchPoint(args._id, args._idx)
    oprot.writeMessageBegin("GetSwitchPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SwitchAllOn(self, seqid, iprot, oprot):
    args = SwitchAllOn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SwitchAllOn_result()
    self._handler.SwitchAllOn(args._homeId)
    oprot.writeMessageBegin("SwitchAllOn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SwitchAllOff(self, seqid, iprot, oprot):
    args = SwitchAllOff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SwitchAllOff_result()
    self._handler.SwitchAllOff(args._homeId)
    oprot.writeMessageBegin("SwitchAllOff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetConfigParam(self, seqid, iprot, oprot):
    args = SetConfigParam_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetConfigParam_result()
    result.success = self._handler.SetConfigParam(args._homeId, args._nodeId, args._param, args._value, args._size)
    oprot.writeMessageBegin("SetConfigParam", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestConfigParam(self, seqid, iprot, oprot):
    args = RequestConfigParam_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestConfigParam_result()
    self._handler.RequestConfigParam(args._homeId, args._nodeId, args._param)
    oprot.writeMessageBegin("RequestConfigParam", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestAllConfigParams(self, seqid, iprot, oprot):
    args = RequestAllConfigParams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestAllConfigParams_result()
    self._handler.RequestAllConfigParams(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RequestAllConfigParams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNumGroups(self, seqid, iprot, oprot):
    args = GetNumGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNumGroups_result()
    result.success = self._handler.GetNumGroups(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNumGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAssociations(self, seqid, iprot, oprot):
    args = GetAssociations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAssociations_result()
    result.success = self._handler.GetAssociations(args._homeId, args._nodeId, args._groupIdx)
    oprot.writeMessageBegin("GetAssociations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetMaxAssociations(self, seqid, iprot, oprot):
    args = GetMaxAssociations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetMaxAssociations_result()
    result.success = self._handler.GetMaxAssociations(args._homeId, args._nodeId, args._groupIdx)
    oprot.writeMessageBegin("GetMaxAssociations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetGroupLabel(self, seqid, iprot, oprot):
    args = GetGroupLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetGroupLabel_result()
    result.success = self._handler.GetGroupLabel(args._homeId, args._nodeId, args._groupIdx)
    oprot.writeMessageBegin("GetGroupLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddAssociation(self, seqid, iprot, oprot):
    args = AddAssociation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddAssociation_result()
    self._handler.AddAssociation(args._homeId, args._nodeId, args._groupIdx, args._targetNodeId)
    oprot.writeMessageBegin("AddAssociation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveAssociation(self, seqid, iprot, oprot):
    args = RemoveAssociation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveAssociation_result()
    self._handler.RemoveAssociation(args._homeId, args._nodeId, args._groupIdx, args._targetNodeId)
    oprot.writeMessageBegin("RemoveAssociation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ResetController(self, seqid, iprot, oprot):
    args = ResetController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ResetController_result()
    self._handler.ResetController(args._homeId)
    oprot.writeMessageBegin("ResetController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SoftReset(self, seqid, iprot, oprot):
    args = SoftReset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SoftReset_result()
    self._handler.SoftReset(args._homeId)
    oprot.writeMessageBegin("SoftReset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_BeginControllerCommand(self, seqid, iprot, oprot):
    args = BeginControllerCommand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = BeginControllerCommand_result()
    result.success = self._handler.BeginControllerCommand(args._homeId, args._command, args._highPower, args._nodeId, args._arg)
    oprot.writeMessageBegin("BeginControllerCommand", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CancelControllerCommand(self, seqid, iprot, oprot):
    args = CancelControllerCommand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CancelControllerCommand_result()
    result.success = self._handler.CancelControllerCommand(args._homeId)
    oprot.writeMessageBegin("CancelControllerCommand", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_TestNetworkNode(self, seqid, iprot, oprot):
    args = TestNetworkNode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = TestNetworkNode_result()
    self._handler.TestNetworkNode(args._homeId, args._nodeId, args._count)
    oprot.writeMessageBegin("TestNetworkNode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_TestNetwork(self, seqid, iprot, oprot):
    args = TestNetwork_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = TestNetwork_result()
    self._handler.TestNetwork(args._homeId, args._count)
    oprot.writeMessageBegin("TestNetwork", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_HealNetworkNode(self, seqid, iprot, oprot):
    args = HealNetworkNode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = HealNetworkNode_result()
    self._handler.HealNetworkNode(args._homeId, args._nodeId, args._doRR)
    oprot.writeMessageBegin("HealNetworkNode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_HealNetwork(self, seqid, iprot, oprot):
    args = HealNetwork_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = HealNetwork_result()
    self._handler.HealNetwork(args._homeId, args._doRR)
    oprot.writeMessageBegin("HealNetwork", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNumScenes(self, seqid, iprot, oprot):
    args = GetNumScenes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNumScenes_result()
    result.success = self._handler.GetNumScenes()
    oprot.writeMessageBegin("GetNumScenes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAllScenes(self, seqid, iprot, oprot):
    args = GetAllScenes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAllScenes_result()
    result.success = self._handler.GetAllScenes()
    oprot.writeMessageBegin("GetAllScenes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveAllScenes(self, seqid, iprot, oprot):
    args = RemoveAllScenes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveAllScenes_result()
    self._handler.RemoveAllScenes(args._homeId)
    oprot.writeMessageBegin("RemoveAllScenes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CreateScene(self, seqid, iprot, oprot):
    args = CreateScene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateScene_result()
    result.success = self._handler.CreateScene()
    oprot.writeMessageBegin("CreateScene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveScene(self, seqid, iprot, oprot):
    args = RemoveScene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveScene_result()
    result.success = self._handler.RemoveScene(args._sceneId)
    oprot.writeMessageBegin("RemoveScene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Bool(self, seqid, iprot, oprot):
    args = AddSceneValue_Bool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Bool_result()
    result.success = self._handler.AddSceneValue_Bool(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Bool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Uint8(self, seqid, iprot, oprot):
    args = AddSceneValue_Uint8_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Uint8_result()
    result.success = self._handler.AddSceneValue_Uint8(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Uint8", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Float(self, seqid, iprot, oprot):
    args = AddSceneValue_Float_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Float_result()
    result.success = self._handler.AddSceneValue_Float(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Float", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Int32(self, seqid, iprot, oprot):
    args = AddSceneValue_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Int32_result()
    result.success = self._handler.AddSceneValue_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Int16(self, seqid, iprot, oprot):
    args = AddSceneValue_Int16_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Int16_result()
    result.success = self._handler.AddSceneValue_Int16(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Int16", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_String(self, seqid, iprot, oprot):
    args = AddSceneValue_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_String_result()
    result.success = self._handler.AddSceneValue_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValueListSelection_String(self, seqid, iprot, oprot):
    args = AddSceneValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValueListSelection_String_result()
    result.success = self._handler.AddSceneValueListSelection_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValueListSelection_Int32(self, seqid, iprot, oprot):
    args = AddSceneValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValueListSelection_Int32_result()
    result.success = self._handler.AddSceneValueListSelection_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveSceneValue(self, seqid, iprot, oprot):
    args = RemoveSceneValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveSceneValue_result()
    result.success = self._handler.RemoveSceneValue(args._sceneId, args._valueId)
    oprot.writeMessageBegin("RemoveSceneValue", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValues(self, seqid, iprot, oprot):
    args = SceneGetValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValues_result()
    result.success = self._handler.SceneGetValues(args._sceneId)
    oprot.writeMessageBegin("SceneGetValues", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsBool(self, seqid, iprot, oprot):
    args = SceneGetValueAsBool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsBool_result()
    result.success = self._handler.SceneGetValueAsBool(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsBool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsByte(self, seqid, iprot, oprot):
    args = SceneGetValueAsByte_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsByte_result()
    result.success = self._handler.SceneGetValueAsByte(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsByte", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsFloat(self, seqid, iprot, oprot):
    args = SceneGetValueAsFloat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsFloat_result()
    result.success = self._handler.SceneGetValueAsFloat(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsFloat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsInt(self, seqid, iprot, oprot):
    args = SceneGetValueAsInt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsInt_result()
    result.success = self._handler.SceneGetValueAsInt(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsInt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsShort(self, seqid, iprot, oprot):
    args = SceneGetValueAsShort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsShort_result()
    result.success = self._handler.SceneGetValueAsShort(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsShort", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsString(self, seqid, iprot, oprot):
    args = SceneGetValueAsString_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsString_result()
    result.success = self._handler.SceneGetValueAsString(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsString", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueListSelection_String(self, seqid, iprot, oprot):
    args = SceneGetValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueListSelection_String_result()
    result.success = self._handler.SceneGetValueListSelection_String(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueListSelection_Int32(self, seqid, iprot, oprot):
    args = SceneGetValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueListSelection_Int32_result()
    result.success = self._handler.SceneGetValueListSelection_Int32(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Bool(self, seqid, iprot, oprot):
    args = SetSceneValue_Bool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Bool_result()
    result.success = self._handler.SetSceneValue_Bool(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Bool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Uint8(self, seqid, iprot, oprot):
    args = SetSceneValue_Uint8_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Uint8_result()
    result.success = self._handler.SetSceneValue_Uint8(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Uint8", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Float(self, seqid, iprot, oprot):
    args = SetSceneValue_Float_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Float_result()
    result.success = self._handler.SetSceneValue_Float(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Float", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Int32(self, seqid, iprot, oprot):
    args = SetSceneValue_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Int32_result()
    result.success = self._handler.SetSceneValue_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Int16(self, seqid, iprot, oprot):
    args = SetSceneValue_Int16_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Int16_result()
    result.success = self._handler.SetSceneValue_Int16(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Int16", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_String(self, seqid, iprot, oprot):
    args = SetSceneValue_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_String_result()
    result.success = self._handler.SetSceneValue_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValueListSelection_String(self, seqid, iprot, oprot):
    args = SetSceneValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValueListSelection_String_result()
    result.success = self._handler.SetSceneValueListSelection_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValueListSelection_Int32(self, seqid, iprot, oprot):
    args = SetSceneValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValueListSelection_Int32_result()
    result.success = self._handler.SetSceneValueListSelection_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSceneLabel(self, seqid, iprot, oprot):
    args = GetSceneLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSceneLabel_result()
    result.success = self._handler.GetSceneLabel(args._sceneId)
    oprot.writeMessageBegin("GetSceneLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneLabel(self, seqid, iprot, oprot):
    args = SetSceneLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneLabel_result()
    self._handler.SetSceneLabel(args._sceneId, args._value)
    oprot.writeMessageBegin("SetSceneLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneExists(self, seqid, iprot, oprot):
    args = SceneExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneExists_result()
    result.success = self._handler.SceneExists(args._sceneId)
    oprot.writeMessageBegin("SceneExists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ActivateScene(self, seqid, iprot, oprot):
    args = ActivateScene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ActivateScene_result()
    result.success = self._handler.ActivateScene(args._sceneId)
    oprot.writeMessageBegin("ActivateScene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDriverStatistics(self, seqid, iprot, oprot):
    args = GetDriverStatistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDriverStatistics_result()
    result.success = self._handler.GetDriverStatistics(args._homeId)
    oprot.writeMessageBegin("GetDriverStatistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeStatistics(self, seqid, iprot, oprot):
    args = GetNodeStatistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeStatistics_result()
    result.success = self._handler.GetNodeStatistics(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeStatistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SendAllValues(self, seqid, iprot, oprot):
    args = SendAllValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SendAllValues_result()
    self._handler.SendAllValues()
    oprot.writeMessageBegin("SendAllValues", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class WriteConfig_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteConfig_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WriteConfig_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteConfig_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetControllerNodeId_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetControllerNodeId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetControllerNodeId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetControllerNodeId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSUCNodeId_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSUCNodeId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSUCNodeId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSUCNodeId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsPrimaryController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsPrimaryController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsPrimaryController_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsPrimaryController_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsStaticUpdateController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsStaticUpdateController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsStaticUpdateController_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsStaticUpdateController_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsBridgeController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsBridgeController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsBridgeController_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsBridgeController_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryVersion_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryVersion_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryVersion_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryTypeName_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryTypeName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryTypeName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryTypeName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSendQueueCount_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSendQueueCount_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSendQueueCount_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSendQueueCount_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogDriverStatistics_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogDriverStatistics_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogDriverStatistics_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogDriverStatistics_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetControllerPath_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetControllerPath_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetControllerPath_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetControllerPath_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPollInterval_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPollInterval_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPollInterval_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPollInterval_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPollInterval_args:
  """
  Attributes:
   - _milliseconds
   - _bIntervalBetweenPolls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_milliseconds', None, None, ), # 1
    (2, TType.BOOL, '_bIntervalBetweenPolls', None, None, ), # 2
  )

  def __init__(self, _milliseconds=None, _bIntervalBetweenPolls=None,):
    self._milliseconds = _milliseconds
    self._bIntervalBetweenPolls = _bIntervalBetweenPolls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._milliseconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self._bIntervalBetweenPolls = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPollInterval_args')
    if self._milliseconds is not None:
      oprot.writeFieldBegin('_milliseconds', TType.I32, 1)
      oprot.writeI32(self._milliseconds)
      oprot.writeFieldEnd()
    if self._bIntervalBetweenPolls is not None:
      oprot.writeFieldBegin('_bIntervalBetweenPolls', TType.BOOL, 2)
      oprot.writeBool(self._bIntervalBetweenPolls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPollInterval_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPollInterval_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnablePoll_args:
  """
  Attributes:
   - _valueId
   - _intensity
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_intensity', None, 1, ), # 2
  )

  def __init__(self, _valueId=None, _intensity=thrift_spec[2][4],):
    self._valueId = _valueId
    self._intensity = _intensity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._intensity = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnablePoll_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._intensity is not None:
      oprot.writeFieldBegin('_intensity', TType.BYTE, 2)
      oprot.writeByte(self._intensity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnablePoll_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnablePoll_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DisablePoll_args:
  """
  Attributes:
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _valueId=None,):
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DisablePoll_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DisablePoll_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DisablePoll_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPolled_args:
  """
  Attributes:
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _valueId=None,):
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPolled_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPolled_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPolled_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPollIntensity_args:
  """
  Attributes:
   - _valueId
   - _intensity
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_intensity', None, None, ), # 2
  )

  def __init__(self, _valueId=None, _intensity=None,):
    self._valueId = _valueId
    self._intensity = _intensity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._intensity = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPollIntensity_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._intensity is not None:
      oprot.writeFieldBegin('_intensity', TType.BYTE, 2)
      oprot.writeByte(self._intensity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPollIntensity_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPollIntensity_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RefreshNodeInfo_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RefreshNodeInfo_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RefreshNodeInfo_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RefreshNodeInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeState_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeState_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeState_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeDynamic_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeDynamic_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeDynamic_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeDynamic_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeListeningDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeListeningDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeListeningDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeListeningDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeFrequentListeningDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeFrequentListeningDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeFrequentListeningDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeFrequentListeningDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeBeamingDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeBeamingDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeBeamingDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeBeamingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeRoutingDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeRoutingDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeRoutingDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeRoutingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeSecurityDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeSecurityDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeSecurityDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeSecurityDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeMaxBaudRate_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeMaxBaudRate_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeMaxBaudRate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeMaxBaudRate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeVersion_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeVersion_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeVersion_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSecurity_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSecurity_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSecurity_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSecurity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeBasic_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeBasic_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeBasic_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeBasic_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeGeneric_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeGeneric_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeGeneric_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeGeneric_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSpecific_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSpecific_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSpecific_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSpecific_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeType_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeType_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeType_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeNeighbors_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeNeighbors_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeNeighbors_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UInt32_ListByte, UInt32_ListByte.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UInt32_ListByte()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeNeighbors_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeLocation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeLocation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeLocation_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeLocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerId_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductType_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductType_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductType_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductId_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeManufacturerName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _manufacturerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_manufacturerName', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _manufacturerName=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._manufacturerName = _manufacturerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._manufacturerName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeManufacturerName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._manufacturerName is not None:
      oprot.writeFieldBegin('_manufacturerName', TType.STRING, 3)
      oprot.writeString(self._manufacturerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeManufacturerName_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeManufacturerName_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeProductName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _productName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_productName', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _productName=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._productName = _productName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._productName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeProductName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._productName is not None:
      oprot.writeFieldBegin('_productName', TType.STRING, 3)
      oprot.writeString(self._productName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeProductName_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeProductName_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _nodeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_nodeName', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _nodeName=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._nodeName = _nodeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._nodeName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._nodeName is not None:
      oprot.writeFieldBegin('_nodeName', TType.STRING, 3)
      oprot.writeString(self._nodeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeName_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeName_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLocation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _location
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_location', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _location=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._location = _location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLocation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._location is not None:
      oprot.writeFieldBegin('_location', TType.STRING, 3)
      oprot.writeString(self._location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLocation_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLocation_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOn_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOn_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOn_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOn_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOff_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOff_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOff_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOff_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLevel_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _level
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_level', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _level=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._level = _level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._level = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLevel_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._level is not None:
      oprot.writeFieldBegin('_level', TType.BYTE, 3)
      oprot.writeByte(self._level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLevel_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLevel_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeInfoReceived_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeInfoReceived_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeInfoReceived_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeInfoReceived_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeClassInformation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _commandClassId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_commandClassId', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _commandClassId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._commandClassId = _commandClassId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._commandClassId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeClassInformation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._commandClassId is not None:
      oprot.writeFieldBegin('_commandClassId', TType.BYTE, 3)
      oprot.writeByte(self._commandClassId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeClassInformation_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_GetNodeClassInformation, Bool_GetNodeClassInformation.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_GetNodeClassInformation()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeClassInformation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeAwake_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeAwake_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeAwake_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeAwake_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeFailed_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeFailed_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeFailed_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeFailed_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeQueryStage_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeQueryStage_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeQueryStage_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeQueryStage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueLabel_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueLabel_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueLabel_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueLabel_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueLabel_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueLabel_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueLabel_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueUnits_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueUnits_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueUnits_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueUnits_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueUnits_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueUnits_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueUnits_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueUnits_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueHelp_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueHelp_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueHelp_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueHelp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueHelp_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueHelp_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueHelp_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueHelp_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMin_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMin_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMax_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMax_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMax_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMax_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueReadOnly_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueReadOnly_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueReadOnly_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueReadOnly_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueWriteOnly_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueWriteOnly_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueWriteOnly_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueWriteOnly_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueSet_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueSet_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueSet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueSet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValuePolled_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValuePolled_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValuePolled_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValuePolled_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsBool_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsBool_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsBool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Bool, Bool_Bool.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Bool()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsBool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsByte_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsByte_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsByte_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_UInt8, Bool_UInt8.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_UInt8()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsByte_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsFloat_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsFloat_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsFloat_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Float, Bool_Float.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Float()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsFloat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsInt_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsInt_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsInt_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsInt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsShort_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsShort_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsShort_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int16, Bool_Int16.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int16()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsShort_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsString_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsString_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsString_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsString_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_String_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_String_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_Int32_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_Int32_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListItems_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListItems_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListItems_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_ListString, Bool_ListString.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_ListString()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListItems_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueFloatPrecision_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueFloatPrecision_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueFloatPrecision_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_UInt8, Bool_UInt8.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_UInt8()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueFloatPrecision_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Bool_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BOOL, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self._value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Bool_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BOOL, 2)
      oprot.writeBool(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Bool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Bool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_UInt8_args:
  """
  Attributes:
   - _id
   - _value
   - _length
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_value', None, None, ), # 2
    (3, TType.BYTE, '_length', None, None, ), # 3
  )

  def __init__(self, _id=None, _value=None, _length=None,):
    self._id = _id
    self._value = _value
    self._length = _length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._value = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._length = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_UInt8_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BYTE, 2)
      oprot.writeByte(self._value)
      oprot.writeFieldEnd()
    if self._length is not None:
      oprot.writeFieldBegin('_length', TType.BYTE, 3)
      oprot.writeByte(self._length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_UInt8_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_UInt8_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Float_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.DOUBLE, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self._value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Float_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.DOUBLE, 2)
      oprot.writeDouble(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Float_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Float_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int32_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.I32, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int32_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 2)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int16_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.I16, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self._value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int16_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I16, 2)
      oprot.writeI16(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int16_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int16_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_String_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_String_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueListSelection_args:
  """
  Attributes:
   - _id
   - _selectedItem
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_selectedItem', None, None, ), # 2
  )

  def __init__(self, _id=None, _selectedItem=None,):
    self._id = _id
    self._selectedItem = _selectedItem

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._selectedItem = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueListSelection_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._selectedItem is not None:
      oprot.writeFieldBegin('_selectedItem', TType.STRING, 2)
      oprot.writeString(self._selectedItem)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueListSelection_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueListSelection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RefreshValue_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RefreshValue_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RefreshValue_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RefreshValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetChangeVerified_args:
  """
  Attributes:
   - _id
   - _verify
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BOOL, '_verify', None, None, ), # 2
  )

  def __init__(self, _id=None, _verify=None,):
    self._id = _id
    self._verify = _verify

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self._verify = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetChangeVerified_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._verify is not None:
      oprot.writeFieldBegin('_verify', TType.BOOL, 2)
      oprot.writeBool(self._verify)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetChangeVerified_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetChangeVerified_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PressButton_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PressButton_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PressButton_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PressButton_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReleaseButton_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReleaseButton_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReleaseButton_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReleaseButton_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumSwitchPoints_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumSwitchPoints_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumSwitchPoints_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumSwitchPoints_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSwitchPoint_args:
  """
  Attributes:
   - _id
   - _hours
   - _minutes
   - _setback
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_hours', None, None, ), # 2
    (3, TType.BYTE, '_minutes', None, None, ), # 3
    (4, TType.BYTE, '_setback', None, None, ), # 4
  )

  def __init__(self, _id=None, _hours=None, _minutes=None, _setback=None,):
    self._id = _id
    self._hours = _hours
    self._minutes = _minutes
    self._setback = _setback

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._hours = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._minutes = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._setback = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSwitchPoint_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._hours is not None:
      oprot.writeFieldBegin('_hours', TType.BYTE, 2)
      oprot.writeByte(self._hours)
      oprot.writeFieldEnd()
    if self._minutes is not None:
      oprot.writeFieldBegin('_minutes', TType.BYTE, 3)
      oprot.writeByte(self._minutes)
      oprot.writeFieldEnd()
    if self._setback is not None:
      oprot.writeFieldBegin('_setback', TType.BYTE, 4)
      oprot.writeByte(self._setback)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSwitchPoint_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSwitchPoint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSwitchPoint_args:
  """
  Attributes:
   - _id
   - _hours
   - _minutes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_hours', None, None, ), # 2
    (3, TType.BYTE, '_minutes', None, None, ), # 3
  )

  def __init__(self, _id=None, _hours=None, _minutes=None,):
    self._id = _id
    self._hours = _hours
    self._minutes = _minutes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._hours = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._minutes = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSwitchPoint_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._hours is not None:
      oprot.writeFieldBegin('_hours', TType.BYTE, 2)
      oprot.writeByte(self._hours)
      oprot.writeFieldEnd()
    if self._minutes is not None:
      oprot.writeFieldBegin('_minutes', TType.BYTE, 3)
      oprot.writeByte(self._minutes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSwitchPoint_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSwitchPoint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearSwitchPoints_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearSwitchPoints_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearSwitchPoints_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearSwitchPoints_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSwitchPoint_args:
  """
  Attributes:
   - _id
   - _idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_idx', None, None, ), # 2
  )

  def __init__(self, _id=None, _idx=None,):
    self._id = _id
    self._idx = _idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._idx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSwitchPoint_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._idx is not None:
      oprot.writeFieldBegin('_idx', TType.BYTE, 2)
      oprot.writeByte(self._idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSwitchPoint_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetSwitchPointReturnStruct, GetSwitchPointReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetSwitchPointReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSwitchPoint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOn_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOn_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOn_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOn_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOff_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOff_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOff_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOff_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetConfigParam_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _param
   - _value
   - _size
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_param', None, None, ), # 3
    (4, TType.I32, '_value', None, None, ), # 4
    (5, TType.BYTE, '_size', None, 2, ), # 5
  )

  def __init__(self, _homeId=None, _nodeId=None, _param=None, _value=None, _size=thrift_spec[5][4],):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._param = _param
    self._value = _value
    self._size = _size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._param = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self._size = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetConfigParam_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._param is not None:
      oprot.writeFieldBegin('_param', TType.BYTE, 3)
      oprot.writeByte(self._param)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 4)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    if self._size is not None:
      oprot.writeFieldBegin('_size', TType.BYTE, 5)
      oprot.writeByte(self._size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetConfigParam_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetConfigParam_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestConfigParam_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _param
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_param', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _param=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._param = _param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._param = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestConfigParam_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._param is not None:
      oprot.writeFieldBegin('_param', TType.BYTE, 3)
      oprot.writeByte(self._param)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestConfigParam_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestConfigParam_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestAllConfigParams_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestAllConfigParams_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestAllConfigParams_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestAllConfigParams_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumGroups_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumGroups_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumGroups_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAssociations_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAssociations_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAssociations_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAssociationsReturnStruct, GetAssociationsReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAssociationsReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAssociations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaxAssociations_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaxAssociations_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaxAssociations_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaxAssociations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetGroupLabel_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetGroupLabel_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetGroupLabel_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetGroupLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddAssociation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
   - _targetNodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
    (4, TType.BYTE, '_targetNodeId', None, None, ), # 4
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None, _targetNodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx
    self._targetNodeId = _targetNodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._targetNodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddAssociation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    if self._targetNodeId is not None:
      oprot.writeFieldBegin('_targetNodeId', TType.BYTE, 4)
      oprot.writeByte(self._targetNodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddAssociation_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddAssociation_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAssociation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
   - _targetNodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
    (4, TType.BYTE, '_targetNodeId', None, None, ), # 4
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None, _targetNodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx
    self._targetNodeId = _targetNodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._targetNodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAssociation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    if self._targetNodeId is not None:
      oprot.writeFieldBegin('_targetNodeId', TType.BYTE, 4)
      oprot.writeByte(self._targetNodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAssociation_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAssociation_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetController_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetController_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SoftReset_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SoftReset_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SoftReset_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SoftReset_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BeginControllerCommand_args:
  """
  Attributes:
   - _homeId
   - _command
   - _highPower
   - _nodeId
   - _arg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.I32, '_command', None, None, ), # 2
    (3, TType.BOOL, '_highPower', None, None, ), # 3
    (4, TType.BYTE, '_nodeId', None, None, ), # 4
    (5, TType.BYTE, '_arg', None, None, ), # 5
  )

  def __init__(self, _homeId=None, _command=None, _highPower=None, _nodeId=None, _arg=None,):
    self._homeId = _homeId
    self._command = _command
    self._highPower = _highPower
    self._nodeId = _nodeId
    self._arg = _arg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self._command = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._highPower = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self._arg = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BeginControllerCommand_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._command is not None:
      oprot.writeFieldBegin('_command', TType.I32, 2)
      oprot.writeI32(self._command)
      oprot.writeFieldEnd()
    if self._highPower is not None:
      oprot.writeFieldBegin('_highPower', TType.BOOL, 3)
      oprot.writeBool(self._highPower)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 4)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._arg is not None:
      oprot.writeFieldBegin('_arg', TType.BYTE, 5)
      oprot.writeByte(self._arg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BeginControllerCommand_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BeginControllerCommand_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelControllerCommand_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelControllerCommand_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelControllerCommand_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelControllerCommand_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestNetworkNode_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.I32, '_count', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _count=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._count = _count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestNetworkNode_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._count is not None:
      oprot.writeFieldBegin('_count', TType.I32, 3)
      oprot.writeI32(self._count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestNetworkNode_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestNetworkNode_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestNetwork_args:
  """
  Attributes:
   - _homeId
   - _count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.I32, '_count', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _count=None,):
    self._homeId = _homeId
    self._count = _count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self._count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestNetwork_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._count is not None:
      oprot.writeFieldBegin('_count', TType.I32, 2)
      oprot.writeI32(self._count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestNetwork_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestNetwork_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HealNetworkNode_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _doRR
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BOOL, '_doRR', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _doRR=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._doRR = _doRR

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._doRR = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HealNetworkNode_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._doRR is not None:
      oprot.writeFieldBegin('_doRR', TType.BOOL, 3)
      oprot.writeBool(self._doRR)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HealNetworkNode_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HealNetworkNode_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HealNetwork_args:
  """
  Attributes:
   - _homeId
   - _doRR
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BOOL, '_doRR', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _doRR=None,):
    self._homeId = _homeId
    self._doRR = _doRR

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self._doRR = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HealNetwork_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._doRR is not None:
      oprot.writeFieldBegin('_doRR', TType.BOOL, 2)
      oprot.writeBool(self._doRR)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HealNetwork_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HealNetwork_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumScenes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumScenes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumScenes_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumScenes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllScenes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllScenes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllScenes_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAllScenesReturnStruct, GetAllScenesReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAllScenesReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllScenes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAllScenes_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAllScenes_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAllScenes_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAllScenes_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateScene_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateScene_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateScene_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateScene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveScene_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveScene_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveScene_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveScene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Bool_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BOOL, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Bool_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BOOL, 3)
      oprot.writeBool(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Bool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Bool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Uint8_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BYTE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Uint8_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BYTE, 3)
      oprot.writeByte(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Uint8_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Uint8_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Float_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self._value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Float_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.DOUBLE, 3)
      oprot.writeDouble(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Float_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Float_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int16_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I16, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self._value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int16_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I16, 3)
      oprot.writeI16(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int16_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int16_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSceneValue_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSceneValue_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSceneValue_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSceneValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValues_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValues_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValues_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SceneGetValuesReturnStruct, SceneGetValuesReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SceneGetValuesReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsBool_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsBool_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsBool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Bool, Bool_Bool.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Bool()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsBool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsByte_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsByte_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsByte_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_UInt8, Bool_UInt8.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_UInt8()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsByte_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsFloat_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsFloat_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsFloat_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Float, Bool_Float.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Float()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsFloat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsInt_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsInt_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsInt_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsInt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsShort_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsShort_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsShort_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int16, Bool_Int16.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int16()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsShort_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsString_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsString_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsString_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsString_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Bool_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BOOL, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Bool_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BOOL, 3)
      oprot.writeBool(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Bool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Bool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Uint8_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BYTE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Uint8_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BYTE, 3)
      oprot.writeByte(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Uint8_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Uint8_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Float_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self._value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Float_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.DOUBLE, 3)
      oprot.writeDouble(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Float_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Float_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int16_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I16, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self._value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int16_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I16, 3)
      oprot.writeI16(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int16_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int16_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSceneLabel_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSceneLabel_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSceneLabel_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSceneLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneLabel_args:
  """
  Attributes:
   - _sceneId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _sceneId=None, _value=None,):
    self._sceneId = _sceneId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneLabel_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneLabel_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneLabel_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneExists_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneExists_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneExists_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ActivateScene_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ActivateScene_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ActivateScene_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ActivateScene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDriverStatistics_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDriverStatistics_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDriverStatistics_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetDriverStatisticsReturnStruct, GetDriverStatisticsReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetDriverStatisticsReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDriverStatistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeStatistics_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeStatistics_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeStatistics_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetNodeStatisticsReturnStruct, GetNodeStatisticsReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetNodeStatisticsReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeStatistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendAllValues_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendAllValues_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendAllValues_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendAllValues_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
