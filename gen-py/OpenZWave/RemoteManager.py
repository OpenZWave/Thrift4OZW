#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def WriteConfig(self, _homeId):
    """
    \name Configuration
    For saving the Z-Wave network configuration so that the entire network does not need to be
    polled every time the application starts.

    Parameters:
     - _homeId
    """
    pass

  def GetControllerNodeId(self, _homeId):
    """
    \name Drivers
    Methods for adding and removing drivers and obtaining basic controller information.

    Parameters:
     - _homeId
    """
    pass

  def IsPrimaryController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def IsStaticUpdateController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    pass

  def IsBridgeController(self, _homeId):
    """
    \brief Query if the controller is using the bridge controller library.
    A bridge controller is able to create virtual nodes that can be associated
    with other controllers to enable events to be passed on.
    \param _homeId The Home ID of the Z-Wave controller.
    \return true if it is a bridge controller, false if not.

    Parameters:
     - _homeId
    """
    pass

  def GetLibraryVersion(self, _homeId):
    """
    \brief Get the version of the Z-Wave API library used by a controller.
    \param _homeId The Home ID of the Z-Wave controller.
    \return a string containing the library version. For example, "Z-Wave 2.48".

    Parameters:
     - _homeId
    """
    pass

  def GetLibraryTypeName(self, _homeId):
    """
    \brief Get a string containing the Z-Wave API library type used by a controller.
    The possible library types are:
    - Static Controller
    - Controller
    - Enhanced Slave
    - Slave
    - Installer
    - Routing Slave
    - Bridge Controller
    - Device Under Test
    The controller should never return a slave library type.
    For a more efficient test of whether a controller is a Bridge Controller, use
    the IsBridgeController method.
    \param _homeId The Home ID of the Z-Wave controller.
    \return a string containing the library type.
    \see GetLibraryVersion, IsBridgeController

    Parameters:
     - _homeId
    """
    pass

  def GetSendQueueCount(self, _homeId):
    """
    \brief Get count of messages in the outgoing send queue.
    \param _homeId The Home ID of the Z-Wave controller.
    \return a integer message count

    Parameters:
     - _homeId
    """
    pass

  def GetPollInterval(self, ):
    """
    \brief Get the time period between polls of a node's state.
    """
    pass

  def SetPollInterval(self, _seconds):
    """
    \brief Set the time period between polls of a node's state.
    Due to patent concerns, some devices do not report state changes automatically to the controller.
    These devices need to have their state polled at regular intervals.  The length of the interval
    is the same for all devices.  To even out the Z-Wave network traffic generated by polling, OpenZWave
    divides the polling interval by the number of devices that have polling enabled, and polls each
    in turn.  It is recommended that if possible, the interval should not be set shorter than the
    number of polled devices in seconds (so that the network does not have to cope with more than one
    poll per second).
    \param _seconds The length of the polling interval in seconds.

    Parameters:
     - _seconds
    """
    pass

  def EnablePoll(self, _valueId):
    """
    \brief Enable the polling of a device's state.
    \param _valueId The ID of the value to start polling.
    \return True if polling was enabled.

    Parameters:
     - _valueId
    """
    pass

  def DisablePoll(self, _valueId):
    """
    \brief Disable the polling of a device's state.
    \param _valueId The ID of the value to stop polling.
    \return True if polling was disabled.

    Parameters:
     - _valueId
    """
    pass

  def isPolled(self, _valueId):
    """
    \brief Determine the polling of a device's state.
    \param _valueId The ID of the value to check polling.
    \return True if polling is active.

    Parameters:
     - _valueId
    """
    pass

  def RefreshNodeInfo(self, _homeId, _nodeId):
    """
    \brief Trigger the fetching of fixed data about a node.
    Causes the node's data to be obtained from the Z-Wave network in the same way as if it had just been added.
    This method would normally be called automatically by OpenZWave, but if you know that a node has been
    changed, calling this method will force a refresh of all of the data held by the library.  This can be especially
    useful for devices that were asleep when the application was first run. This is the
    same as the query state starting from the beginning.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the request was sent successfully.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def RequestNodeState(self, _homeId, _nodeId):
    """
    \brief Trigger the fetching of dynamic value data for a node.
    Causes the node's values to be requested from the Z-Wave network. This is the
    same as the query state starting from the associations state.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the request was sent successfully.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def RequestNodeDynamic(self, _homeId, _nodeId):
    """
    \brief Trigger the fetching of just the dynamic value data for a node.
    Causes the node's values to be requested from the Z-Wave network. This is the
    same as the query state starting from the dynamic state.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the request was sent successfully.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeListeningDevice(self, _homeId, _nodeId):
    """
    \brief Get whether the node is a listening device that does not go to sleep
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if it is a listening node.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def IsNodeRoutingDevice(self, _homeId, _nodeId):
    """
    \brief Get whether the node is a routing device that passes messages to other nodes
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the node is a routing device

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeMaxBaudRate(self, _homeId, _nodeId):
    """
    \brief Get the maximum baud rate of a node's communications
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the baud rate in bits per second.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeVersion(self, _homeId, _nodeId):
    """
    \brief Get the version number of a node
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's version number

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeSecurity(self, _homeId, _nodeId):
    """
    \brief Get the security byte for a node.  Bit meanings are still to be determined.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's security byte

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeBasic(self, _homeId, _nodeId):
    """
    \brief Get the basic type of a node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's basic type.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeGeneric(self, _homeId, _nodeId):
    """
    \brief Get the generic type of a node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's generic type.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeSpecific(self, _homeId, _nodeId):
    """
    \brief Get the specific type of a node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's specific type.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeType(self, _homeId, _nodeId):
    """
    \brief Get a human-readable label describing the node
    The label is taken from the Z-Wave specific, generic or basic type, depending on which of those values are specified by the node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the label text.

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeNeighbors(self, _homeId, _nodeId):
    """
    \brief Get the bitmap of this node's neighbors

    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _nodeNeighbors An array of 29 uint8s to hold the neighbor bitmap

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeManufacturerName(self, _homeId, _nodeId):
    """
    \brief Get the manufacturer name of a device
    The manufacturer name would normally be handled by the Manufacturer Specific commmand class,
    taking the manufacturer ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's manufacturer name.
    \see SetNodeManufacturerName, GetNodeProductName, SetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeProductName(self, _homeId, _nodeId):
    """
    \brief Get the product name of a device
    The product name would normally be handled by the Manufacturer Specific commmand class,
    taking the product Type and ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's product name.
    \see SetNodeProductName, GetNodeManufacturerName, SetNodeManufacturerName

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeName(self, _homeId, _nodeId):
    """
    \brief Get the name of a node
    The node name is a user-editable label for the node that would normally be handled by the
    Node Naming commmand class, but many devices do not support it.  So that a node can always
    be named, OpenZWave stores it with the node data, and provides access through this method
    and SetNodeName, rather than reporting it via a command class Value object.
    The maximum length of a node name is 16 characters.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's name.
    \see SetNodeName, GetNodeLocation, SetNodeLocation

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeLocation(self, _homeId, _nodeId):
    """
    \brief Get the location of a node
    The node location is a user-editable string that would normally be handled by the Node Naming
    commmand class, but many devices do not support it.  So that a node can always report its
    location, OpenZWave stores it with the node data, and provides access through this method
    and SetNodeLocation, rather than reporting it via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's location.
    \see SetNodeLocation, GetNodeName, SetNodeName

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeManufacturerId(self, _homeId, _nodeId):
    """
    \brief Get the manufacturer ID of a device
    The manufacturer ID is a four digit hex code and would normally be handled by the Manufacturer
    Specific commmand class, but not all devices support it.  Although the value reported by this
    method will be an empty string if the command class is not supported and cannot be set by the
    user, the manufacturer ID is still stored with the node data (rather than being reported via a
    command class Value object) to retain a consistent approach with the other manufacturer specific data.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's manufacturer ID, or an empty string if the manufactuer
    specific command class is not supported by the device.
    \see GetNodeProductType, GetNodeProductId, GetNodeManufacturerName, GetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeProductType(self, _homeId, _nodeId):
    """
    \brief Get the product type of a device
    The product type is a four digit hex code and would normally be handled by the Manufacturer Specific
    commmand class, but not all devices support it.  Although the value reported by this method will
    be an empty string if the command class is not supported and cannot be set by the user, the product
    type is still stored with the node data (rather than being reported via a command class Value object)
    to retain a consistent approach with the other manufacturer specific data.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's product type, or an empty string if the manufactuer
    specific command class is not supported by the device.
    \see GetNodeManufacturerId, GetNodeProductId, GetNodeManufacturerName, GetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeProductId(self, _homeId, _nodeId):
    """
    \brief Get the product ID of a device
    The product ID is a four digit hex code and would normally be handled by the Manufacturer Specific
    commmand class, but not all devices support it.  Although the value reported by this method will
    be an empty string if the command class is not supported and cannot be set by the user, the product
    ID is still stored with the node data (rather than being reported via a command class Value object)
    to retain a consistent approach with the other manufacturer specific data.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's product ID, or an empty string if the manufactuer
    specific command class is not supported by the device.
    \see GetNodeManufacturerId, GetNodeProductType, GetNodeManufacturerName, GetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SetNodeManufacturerName(self, _homeId, _nodeId, _manufacturerName):
    """
    \brief Set the manufacturer name of a device
    The manufacturer name would normally be handled by the Manufacturer Specific commmand class,
    taking the manufacturer ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _manufacturerName	A string containing the node's manufacturer name.
    \see GetNodeManufacturerName, GetNodeProductName, SetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
     - _manufacturerName
    """
    pass

  def SetNodeProductName(self, _homeId, _nodeId, _productName):
    """
    \brief Set the product name of a device
    The product name would normally be handled by the Manufacturer Specific commmand class,
    taking the product Type and ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _productName A string containing the node's product name.
    \see GetNodeProductName, GetNodeManufacturerName, SetNodeManufacturerName

    Parameters:
     - _homeId
     - _nodeId
     - _productName
    """
    pass

  def SetNodeName(self, _homeId, _nodeId, _nodeName):
    """
    \brief Set the name of a node
    The node name is a user-editable label for the node that would normally be handled by the
    Node Naming commmand class, but many devices do not support it.  So that a node can always
    be named, OpenZWave stores it with the node data, and provides access through this method
    and GetNodeName, rather than reporting it via a command class Value object.
    If the device does support the Node Naming command class, the new name will be sent to the node.
    The maximum length of a node name is 16 characters.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _nodeName A string containing the node's name.
    \see GetNodeName, GetNodeLocation, SetNodeLocation

    Parameters:
     - _homeId
     - _nodeId
     - _nodeName
    """
    pass

  def SetNodeLocation(self, _homeId, _nodeId, _location):
    """
    \brief Set the location of a node
    The node location is a user-editable string that would normally be handled by the Node Naming
    commmand class, but many devices do not support it.  So that a node can always report its
    location, OpenZWave stores it with the node data, and provides access through this method
    and GetNodeLocation, rather than reporting it via a command class Value object.
    If the device does support the Node Naming command class, the new location will be sent to the node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _location A string containing the node's location.
    \see GetNodeLocation, GetNodeName, SetNodeName

    Parameters:
     - _homeId
     - _nodeId
     - _location
    """
    pass

  def SetNodeOn(self, _homeId, _nodeId):
    """
    \brief Turns a node on
    This is a helper method to simplify basic control of a node.  It is the equivalent of
    changing the level reported by the node's Basic command class to 255, and will generate a
    ValueChanged notification from that class.  This command will turn on the device at its
    last known level, if supported by the device, otherwise it will turn	it on at 100%.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to be changed.
    \see SetNodeOff, SetNodeLevel

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SetNodeOff(self, _homeId, _nodeId):
    """
    \brief Turns a node off
    This is a helper method to simplify basic control of a node.  It is the equivalent of
    changing the level reported by the node's Basic command class to zero, and will generate
    a ValueChanged notification from that class.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to be changed.
    \see SetNodeOn, SetNodeLevel

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def SetNodeLevel(self, _homeId, _nodeId, _level):
    """
    \brief Sets the basic level of a node
    This is a helper method to simplify basic control of a node.  It is the equivalent of
    changing the value reported by the node's Basic command class and will generate a
    ValueChanged notification from that class.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to be changed.
    \param _level The level to set the node.  Valid values are 0-99 and 255.  Zero is off and
    99 is fully on.  255 will turn on the device at its last known level (if supported).
    \see SetNodeOn, SetNodeOff

    Parameters:
     - _homeId
     - _nodeId
     - _level
    """
    pass

  def IsNodeInfoReceived(self, _homeId, _nodeId):
    """
    \brief Get whether the node information has been received
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the node information has been received yet

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNodeClassInformation(self, _homeId, _nodeId, _commandClassId):
    """
    \brief Get whether the node has the defined class available or not
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _commandClassId Id of the class to test for
    \return True if the node does have the class instantiated, will return name & version

    Parameters:
     - _homeId
     - _nodeId
     - _commandClassId
    """
    pass

  def GetValueLabel(self, _id):
    """
    \brief Gets the user-friendly label for the value.
    \param _id The unique identifier of the value.
    \return The value label.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def SetValueLabel(self, _id, _value):
    """
    \brief Sets the user-friendly label for the value.
    \param _id The unique identifier of the value.
    \param _value The new value of the label.
    \see ValueID

    Parameters:
     - _id
     - _value
    """
    pass

  def GetValueUnits(self, _id):
    """
    \brief Gets the units that the value is measured in.
    \param _id The unique identifier of the value.
    \return The value units.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def SetValueUnits(self, _id, _value):
    """
    \brief Sets the units that the value is measured in.
    \param _id The unique identifier of the value.
    \param _value The new value of the units.
    \see ValueID

    Parameters:
     - _id
     - _value
    """
    pass

  def GetValueHelp(self, _id):
    """
    \brief Gets a help string describing the value's purpose and usage.
    \param _id The unique identifier of the value.
    \return The value help text.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def SetValueHelp(self, _id, _value):
    """
    \brief Sets a help string describing the value's purpose and usage.
    \param _id The unique identifier of the value.
    \param _value The new value of the help text.
    \see ValueID

    Parameters:
     - _id
     - _value
    """
    pass

  def GetValueMin(self, _id):
    """
    \brief Gets the minimum that this value may contain.
    \param _id The unique identifier of the value.
    \return The value minimum.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def GetValueMax(self, _id):
    """
    \brief Gets the maximum that this value may contain.
    \param _id The unique identifier of the value.
    \return The value maximum.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def IsValueReadOnly(self, _id):
    """
    \brief Test whether the value is read-only.
    \param _id The unique identifier of the value.
    \return true if the value cannot be changed by the user.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def IsValueWriteOnly(self, _id):
    """
    \brief Test whether the value is write-only.
    \param _id The unique identifier of the value.
    \return true if the value can only be written to and not read.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def IsValueSet(self, _id):
    """
    \brief Test whether the value has been set.
    \param _id The unique identifier of the value.
    \return true if the value has actually been set by a status message from the device, rather than simply being the default.
    \see ValueID

    Parameters:
     - _id
    """
    pass

  def GetValueAsBool(self, _id):
    """
    \brief Gets a value as a bool.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a bool that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Bool. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    pass

  def GetValueAsByte(self, _id):
    """
    \brief Gets a value as an 8-bit unsigned integer.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a uint8 that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Byte. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    pass

  def GetValueAsFloat(self, _id):
    """
    \brief Gets a value as a float.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a float that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    pass

  def GetValueAsInt(self, _id):
    """
    \brief Gets a value as a 32-bit signed integer.
    \param _id The unique identifier of the value.
    \param o_value Pointer to an int32 that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Int. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    pass

  def GetValueAsShort(self, _id):
    """
    \brief Gets a value as a 16-bit signed integer.
    \param _id The unique identifier of the value.
    \param o_value Pointer to an int16 that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Short. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsString, GetValueListSelection, GetValueListItems.

    Parameters:
     - _id
    """
    pass

  def GetValueAsString(self, _id):
    """
    \brief Gets a value as a string.
    Creates a string representation of a value, regardless of type.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a string that will be filled with the value.
    \return true if the value was obtained.</returns>
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueListSelection, GetValueListItems.

    Parameters:
     - _id
    """
    pass

  def GetValueListSelection_String(self, _id):
    """
    \brief Gets the selected item from a list (as a string).
    \param _id The unique identifier of the value.
    \param o_value Pointer to a string that will be filled with the selected item.
    \return True if the value was obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListItems.

    Parameters:
     - _id
    """
    pass

  def GetValueListSelection_Int32(self, _id):
    """
    \brief Gets the selected item from a list (as an integer).
    \param _id The unique identifier of the value.
    \param o_value Pointer to an integer that will be filled with the selected item.
    \return True if the value was obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListItems.

    Parameters:
     - _id
    """
    pass

  def GetValueListItems(self, _id):
    """
    \brief Gets the list of items from a list value.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a vector of strings that will be filled with list items. The vector will be cleared before the items are added.
    \return true if the list items were obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection.

    Parameters:
     - _id
    """
    pass

  def GetValueFloatPrecision(self, _id):
    """
    \brief Gets a float value's precision.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a uint8 that will be filled with the precision value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    pass

  def SetValue_Bool(self, _id, _value):
    """
    \brief Sets the state of a bool.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the bool value.
    \param _value The new value of the bool.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Bool. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_UInt8(self, _id, _value):
    """
    \brief Sets the value of a byte.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the byte value.
    \param _value The new value of the byte.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Byte. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_Float(self, _id, _value):
    """
    \brief Sets the value of a decimal.
    It is usually better to handle decimal values using strings rather than floats, to avoid floating point accuracy issues.
    Due to the possibility of a device being asleep, the command is assumed to succeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the decimal value.
    \param _value The new value of the decimal.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_Int32(self, _id, _value):
    """
    \brief Sets the value of a 32-bit signed integer.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the integer value.
    \param _value The new value of the integer.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Int. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_Int16(self, _id, _value):
    """
    \brief Sets the value of a 16-bit signed integer.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the integer value.
    \param _value The new value of the integer.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Short. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    pass

  def SetValue_String(self, _id, _value):
    """
    \brief Sets the value from a string, regardless of type.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the integer value.
    \param _value The new value of the string.
    \return true if the value was set.  Returns false if the value could not be parsed into the correct type for the value.

    Parameters:
     - _id
     - _value
    """
    pass

  def SetValueListSelection(self, _id, _selectedItem):
    """
    \brief Sets the selected item in a list.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the list value.
    \param _selectedItem A string matching the new selected item in the list.
    \return true if the value was set.  Returns false if the selection is not in the list, or if the value is not a ValueID::ValueType_List.
    The type can be tested with a call to ValueID::GetType

    Parameters:
     - _id
     - _selectedItem
    """
    pass

  def PressButton(self, _id):
    """
    \brief Starts an activity in a device.
    Since buttons are write-only values that do not report a state, no notification callbacks are sent.
    \param _id The unique identifier of the integer value.
    \return true if the activity was started.  Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
    """
    pass

  def ReleaseButton(self, _id):
    """
    \brief Stops an activity in a device.
    Since buttons are write-only values that do not report a state, no notification callbacks are sent.
    \param _id The unique identifier of the integer value.
    \return true if the activity was stopped.  Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
    """
    pass

  def GetNumSwitchPoints(self, _id):
    """
    \brief Get the number of switch points defined in a schedule.
    \param _id The unique identifier of the schedule value.
    \return the number of switch points defined in this schedule.  Returns zero if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
    """
    pass

  def SetSwitchPoint(self, _id, _hours, _minutes, _setback):
    """
    \brief Set a switch point in the schedule.
    Inserts a new switch point into the schedule, unless a switch point already exists at the specified
    time in which case that switch point is updated with the new setback value instead.
    A maximum of nine switch points can be set in the schedule.
    \param _id The unique identifier of the schedule value.
    \param _hours The hours part of the time when the switch point will trigger.  The time is set using
    the 24-hour clock, so this value must be between 0 and 23.
    \param _minutes The minutes part of the time when the switch point will trigger.  This value must be
    between 0 and 59.
    \param _setback The setback in tenths of a degree Celsius.  The setback value can range from -128 (-12.8C)
    to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and
    122 is used to set Energy Saving mode.
    \return true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.
    \see GetNumSwitchPoints, RemoveSwitchPoint, ClearSwitchPoints

    Parameters:
     - _id
     - _hours
     - _minutes
     - _setback
    """
    pass

  def RemoveSwitchPoint(self, _id, _hours, _minutes):
    """
    \brief Remove a switch point from the schedule.
    Removes the switch point at the specified time from the schedule.
    \param _id The unique identifier of the schedule value.
    \param _hours The hours part of the time when the switch point will trigger.  The time is set using
    the 24-hour clock, so this value must be between 0 and 23.
    \param _minutes The minutes part of the time when the switch point will trigger.  This value must be
    between 0 and 59.
    \return true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule or if there
    is not switch point with the specified time values. The type can be tested with a call to ValueID::GetType.
    \see GetNumSwitchPoints, SetSwitchPoint, ClearSwitchPoints

    Parameters:
     - _id
     - _hours
     - _minutes
    """
    pass

  def ClearSwitchPoints(self, _id):
    """
    \brief Clears all switch points from the schedule.
    \param _id The unique identifier of the schedule value.
    \see GetNumSwitchPoints, SetSwitchPoint, RemoveSwitchPoint

    Parameters:
     - _id
    """
    pass

  def GetSwitchPoint(self, _id, _idx):
    """
    \brief Gets switch point data from the schedule.
    Retrieves the time and setback values from a switch point in the schedule.
    \param _id The unique identifier of the schedule value.
    \param _idx The index of the switch point, between zero and one less than the value
    returned by GetNumSwitchPoints.
    \param o_hours a pointer to a uint8 that will be filled with the hours part of the switch point data.
    \param o_minutes a pointer to a uint8 that will be filled with the minutes part of the switch point data.
    \param o_setback a pointer to an int8 that will be filled with the setback value.  This can range from -128
    (-12.8C)to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and
    122 is used to set Energy Saving mode.
    \return true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.
    \see GetNumSwitchPoints

    Parameters:
     - _id
     - _idx
    """
    pass

  def SwitchAllOn(self, _homeId):
    """
    \brief Switch all devices on.
    All devices that support the SwitchAll command class will be turned on.

    Parameters:
     - _homeId
    """
    pass

  def SwitchAllOff(self, _homeId):
    """
    \brief Switch all devices off.
    All devices that support the SwitchAll command class will be turned off.

    Parameters:
     - _homeId
    """
    pass

  def SetConfigParam(self, _homeId, _nodeId, _param, _value, _size):
    """
    \brief Set the value of a configurable parameter in a device.
    Some devices have various parameters that can be configured to control the device behaviour.
    These are not reported by the device over the Z-Wave network, but can usually be found in
    the device's user manual.
    This method returns immediately, without waiting for confirmation from the device that the
    change has been made.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to configure.
    \param _param The index of the parameter.
    \param _value The value to which the parameter should be set.
    \param _size Is an optional number of bytes to be sent for the paramter _value. Defaults to 2.
    \return true if the a message setting the value was sent to the device.
    \see RequestConfigParam

    Parameters:
     - _homeId
     - _nodeId
     - _param
     - _value
     - _size
    """
    pass

  def RequestConfigParam(self, _homeId, _nodeId, _param):
    """
    \brief Request the value of a configurable parameter from a device.
    Some devices have various parameters that can be configured to control the device behaviour.
    These are not reported by the device over the Z-Wave network, but can usually be found in
    the device's user manual.
    This method requests the value of a parameter from the device, and then returns immediately,
    without waiting for a response.  If the parameter index is valid for this device, and the
    device is awake, the value will eventually be reported via a ValueChanged notification callback.
    The ValueID reported in the callback will have an index set the same as _param and a command class
    set to the same value as returned by a call to Configuration::StaticGetCommandClassId.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to configure.
    \param _param The index of the parameter.
    \see SetConfigParam, ValueID, Notification

    Parameters:
     - _homeId
     - _nodeId
     - _param
    """
    pass

  def RequestAllConfigParams(self, _homeId, _nodeId):
    """
    \brief Request the values of all known configurable parameters from a device.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to configure.
    \see SetConfigParam, ValueID, Notification

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetNumGroups(self, _homeId, _nodeId):
    """
    \brief Gets the number of association groups reported by this node
    In Z-Wave, groups are numbered starting from one.  For example, if a call to GetNumGroups returns 4, the _groupIdx
    value to use in calls to GetAssociations, AddAssociation and RemoveAssociation will be a number between 1 and 4.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose groups we are interested in.
    \return The number of groups.
    \see GetAssociations, GetMaxAssociations, AddAssociation, RemoveAssociation

    Parameters:
     - _homeId
     - _nodeId
    """
    pass

  def GetAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    \brief Gets the associations for a group.
    Makes a copy of the list of associated nodes in the group, and returns it in an array of uint8's.
    The caller is responsible for freeing the array memory with a call to delete [].
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations we are interested in.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \param o_associations If the number of associations returned is greater than zero, o_associations will be set to point to an array containing the IDs of the associated nodes.
    \return The number of nodes in the associations array.  If zero, the array will point to NULL, and does not need to be deleted.
    \see GetNumGroups, AddAssociation, RemoveAssociation, GetMaxAssociations

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    pass

  def GetMaxAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    \brief Gets the maximum number of associations for a group.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations we are interested in.
    \param _groupIdx one-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \return The maximum number of nodes that can be associated into the group.
    \see GetNumGroups, AddAssociation, RemoveAssociation, GetAssociations

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    pass

  def GetGroupLabel(self, _homeId, _nodeId, _groupIdx):
    """
    \brief Returns a label for the particular group of a node.
    This label is populated by the device specific configuration files.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations are to be changed.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \see GetNumGroups, GetAssociations, GetMaxAssociations, AddAssociation

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    pass

  def AddAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    \brief Adds a node to an association group.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the association data
    held in this class is updated directly.  This will be reverted by a future Association message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations are to be changed.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \param _targetNodeId Identifier for the node that will be added to the association group.
    \see GetNumGroups, GetAssociations, GetMaxAssociations, RemoveAssociation

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    pass

  def RemoveAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    \brief Removes a node from an association group.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the association data
    held in this class is updated directly.  This will be reverted by a future Association message from the device
    if the Z-Wave message actually failed to get through.   Notification callbacks will be sent in both cases.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations are to be changed.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \param _targetNodeId Identifier for the node that will be removed from the association group.
    \see GetNumGroups, GetAssociations, GetMaxAssociations, AddAssociation

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    pass

  def ResetController(self, _homeId):
    """
    \brief Hard Reset a PC Z-Wave Controller.
    Resets a controller and erases its network configuration settings.  The controller becomes a primary controller ready to add devices to a new network.
    \param _homeId The Home ID of the Z-Wave controller to be reset.
    \see SoftReset

    Parameters:
     - _homeId
    """
    pass

  def SoftReset(self, _homeId):
    """
    \brief Soft Reset a PC Z-Wave Controller.
    Resets a controller without erasing its network configuration settings.
    \param _homeId The Home ID of the Z-Wave controller to be reset.
    \see SoftReset

    Parameters:
     - _homeId
    """
    pass

  def BeginControllerCommand(self, _homeId, _command, _highPower, _nodeId):
    """
    * \brief Start a controller command process.
    * \param _homeId The Home ID of the Z-Wave controller.
    * \param _command The command to be sent to the controller.
    * \param _callback pointer to a function that will be called at various stages during the command process
    * \param _context pointer to user defined data that will be passed into to the callback function.  Defaults to NULL.
    * \param _highPower used only with the AddDevice, AddController, RemoveDevice and RemoveController commands.
    * Usually when adding or removing devices, the controller operates at low power so that the controller must
    * be physically close to the device for security reasons.  If _highPower is true, the controller will
    * operate at normal power levels instead.  Defaults to false.
    * \param _nodeId used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.
    * \return true if the command was accepted and has started.
    * \see CancelControllerCommand, HasNodeFailed, RemoveFailedNode, Driver::ControllerCommand, Driver::pfnControllerCallback_t,
    * to notify the user of progress or to request actions on the user's part.  Defaults to NULL.
    * <p> Commands
    * - Driver::ControllerCommand_AddController - Add a new secondary controller to the Z-Wave network.
    * - Driver::ControllerCommand_AddDevice - Add a new device (but not a controller) to the Z-Wave network.
    * - Driver::ControllerCommand_CreateNewPrimary (Not yet implemented)
    * - Driver::ControllerCommand_ReceiveConfiguration -
    * - Driver::ControllerCommand_RemoveController - remove a controller from the Z-Wave network.
    * - Driver::ControllerCommand_RemoveDevice - remove a device (but not a controller) from the Z-Wave network.
     * - Driver::ControllerCommand_RemoveFailedNode - move a node to the controller's list of failed nodes.  The node must actually
    * have failed or have been disabled since the command will fail if it responds.  A node must be in the controller's failed nodes list
    * for ControllerCommand_ReplaceFailedNode to work.
    * - Driver::ControllerCommand_HasNodeFailed - Check whether a node is in the controller's failed nodes list.
    * - Driver::ControllerCommand_ReplaceFailedNode - replace a failed device with another. If the node is not in
    * the controller's failed nodes list, or the node responds, this command will fail.
    * - Driver:: ControllerCommand_TransferPrimaryRole	(Not yet implemented) - Add a new controller to the network and
    * make it the primary.  The existing primary will become a secondary controller.
    * - Driver::ControllerCommand_RequestNetworkUpdate - Update the controller with network information from the SUC/SIS.
    * - Driver::ControllerCommand_RequestNodeNeighborUpdate - Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors afterwards.
    * - Driver::ControllerCommand_AssignReturnRoute - Assign a network return route to a device.
    * - Driver::ControllerCommand_DeleteAllReturnRoutes - Delete all network return routes from a device.
    * <p> Callbacks
    * - Driver::ControllerState_Waiting, the controller is waiting for a user action.  A notice should be displayed
    * to the user at this point, telling them what to do next.
    * For the add, remove, replace and transfer primary role commands, the user needs to be told to press the
    * inclusion button on the device that  is going to be added or removed.  For ControllerCommand_ReceiveConfiguration,
    * they must set their other controller to send its data, and for ControllerCommand_CreateNewPrimary, set the other
    * controller to learn new data.
    * - Driver::ControllerState_InProgress - the controller is in the process of adding or removing the chosen node.  It is now too late to cancel the command.
    * - Driver::ControllerState_Complete - the controller has finished adding or removing the node, and the command is complete.
    * - Driver::ControllerState_Failed - will be sent if the command fails for any reason.

    Parameters:
     - _homeId
     - _command
     - _highPower
     - _nodeId
    """
    pass

  def CancelControllerCommand(self, _homeId):
    """
    \brief Cancels any in-progress command running on a controller.
    \param _homeId The Home ID of the Z-Wave controller.
    \return true if a command was running and was cancelled.
    \see BeginControllerCommand

    Parameters:
     - _homeId
    """
    pass

  def GetNumScenes(self, ):
    """
    \brief Gets the number of scenes that have been defined.
    \return The number of scenes.
    \see GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
    """
    pass

  def GetAllScenes(self, ):
    """
    \brief Gets a list of all the SceneIds.
    \param _sceneIds is a pointer to an array of integers.
    \return The number of scenes. If zero, _sceneIds will be NULL and doesn't need to be freed.
    \see GetNumScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
    """
    pass

  def CreateScene(self, ):
    """
    \brief Create a new Scene passing in Scene ID
    \return uint8 Scene ID used to reference the scene. 0 is failure result.
    \see GetNumScenes, GetAllScenes, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    """
    pass

  def RemoveScene(self, _sceneId):
    """
    \brief Remove an existing Scene.
    \param _sceneId is an integer representing the unique Scene ID to be removed.
    \return true if scene was removed.
    \see GetNumScenes, GetAllScenes, CreateScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
    """
    pass

  def AddSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    \brief Add a bool Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the bool value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    \brief Add a byte Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the byte value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    \brief Add a decimal Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the float value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Add a 32-bit signed integer Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int32 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    \brief Add a 16-bit signed integer Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int16 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValue_String(self, _sceneId, _valueId, _value):
    """
    \brief Add a string Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    \brief Add the selected item list Value ID to an existing scene (as a string).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def AddSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Add the selected item list Value ID to an existing scene (as a integer).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the integer value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def RemoveSceneValue(self, _sceneId, _valueId):
    """
    \brief Remove the Value ID from an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be removed.
    \return true if Value ID was removed.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValues(self, _sceneId):
    """
    \brief Retrieves the scene's list of values.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param o_value Pointer to an array of ValueIDs if return is non-zero.
    \return The number of nodes in the o_value array. If zero, the array will point to NULL and does not need to be deleted.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
    """
    pass

  def SceneGetValueAsBool(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a bool.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a bool that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsByte(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as an 8-bit unsigned integer.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a uint8 that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsFloat(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a float.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a float that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsInt(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a 32-bit signed integer.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a int32 that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsShort(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a 16-bit signed integer.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a int16 that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueAsString(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a string.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a string that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueListSelection_String(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a list (as a string).
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a string that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SceneGetValueListSelection_Int32(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a list (as a integer).
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a integer that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    pass

  def SetSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    \brief Set a bool Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the bool value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    \brief Set a byte Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the byte value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    \brief Set a decimal Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the float value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Set a 32-bit signed integer Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int32 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    \brief Set a 16-bit integer Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int16 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValue_String(self, _sceneId, _valueId, _value):
    """
    \brief Set a string Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    \brief Set the list selected item Value ID to an existing scene's ValueID (as a string).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def SetSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Set the list selected item Value ID to an existing scene's ValueID (as a integer).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the integer value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    pass

  def GetSceneLabel(self, _sceneId):
    """
    \brief Returns a label for the particular scene.
    \param _sceneId The Scene ID
    \return The label string.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
    """
    pass

  def SetSceneLabel(self, _sceneId, _value):
    """
    \brief Sets a label for the particular scene.
    \param _sceneId The Scene ID
    \param _value The new value of the label.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _value
    """
    pass

  def SceneExists(self, _sceneId):
    """
    \brief Check if a Scene ID is defined.
    \param _sceneId The Scene ID.
    \return true if Scene ID exists.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, ActivateScene

    Parameters:
     - _sceneId
    """
    pass

  def ActivateScene(self, _sceneId):
    """
    \brief Activate given scene to perform all its actions.
    \param _sceneId The Scene ID.
    \return true if it is successful.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists

    Parameters:
     - _sceneId
    """
    pass

  def SendAllValues(self, ):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def WriteConfig(self, _homeId):
    """
    \name Configuration
    For saving the Z-Wave network configuration so that the entire network does not need to be
    polled every time the application starts.

    Parameters:
     - _homeId
    """
    self.send_WriteConfig(_homeId)
    self.recv_WriteConfig()

  def send_WriteConfig(self, _homeId):
    self._oprot.writeMessageBegin('WriteConfig', TMessageType.CALL, self._seqid)
    args = WriteConfig_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_WriteConfig(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = WriteConfig_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetControllerNodeId(self, _homeId):
    """
    \name Drivers
    Methods for adding and removing drivers and obtaining basic controller information.

    Parameters:
     - _homeId
    """
    self.send_GetControllerNodeId(_homeId)
    return self.recv_GetControllerNodeId()

  def send_GetControllerNodeId(self, _homeId):
    self._oprot.writeMessageBegin('GetControllerNodeId', TMessageType.CALL, self._seqid)
    args = GetControllerNodeId_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetControllerNodeId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetControllerNodeId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetControllerNodeId failed: unknown result");

  def IsPrimaryController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_IsPrimaryController(_homeId)
    return self.recv_IsPrimaryController()

  def send_IsPrimaryController(self, _homeId):
    self._oprot.writeMessageBegin('IsPrimaryController', TMessageType.CALL, self._seqid)
    args = IsPrimaryController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsPrimaryController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsPrimaryController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsPrimaryController failed: unknown result");

  def IsStaticUpdateController(self, _homeId):
    """
    Parameters:
     - _homeId
    """
    self.send_IsStaticUpdateController(_homeId)
    return self.recv_IsStaticUpdateController()

  def send_IsStaticUpdateController(self, _homeId):
    self._oprot.writeMessageBegin('IsStaticUpdateController', TMessageType.CALL, self._seqid)
    args = IsStaticUpdateController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsStaticUpdateController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsStaticUpdateController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsStaticUpdateController failed: unknown result");

  def IsBridgeController(self, _homeId):
    """
    \brief Query if the controller is using the bridge controller library.
    A bridge controller is able to create virtual nodes that can be associated
    with other controllers to enable events to be passed on.
    \param _homeId The Home ID of the Z-Wave controller.
    \return true if it is a bridge controller, false if not.

    Parameters:
     - _homeId
    """
    self.send_IsBridgeController(_homeId)
    return self.recv_IsBridgeController()

  def send_IsBridgeController(self, _homeId):
    self._oprot.writeMessageBegin('IsBridgeController', TMessageType.CALL, self._seqid)
    args = IsBridgeController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsBridgeController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsBridgeController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsBridgeController failed: unknown result");

  def GetLibraryVersion(self, _homeId):
    """
    \brief Get the version of the Z-Wave API library used by a controller.
    \param _homeId The Home ID of the Z-Wave controller.
    \return a string containing the library version. For example, "Z-Wave 2.48".

    Parameters:
     - _homeId
    """
    self.send_GetLibraryVersion(_homeId)
    return self.recv_GetLibraryVersion()

  def send_GetLibraryVersion(self, _homeId):
    self._oprot.writeMessageBegin('GetLibraryVersion', TMessageType.CALL, self._seqid)
    args = GetLibraryVersion_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLibraryVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetLibraryVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLibraryVersion failed: unknown result");

  def GetLibraryTypeName(self, _homeId):
    """
    \brief Get a string containing the Z-Wave API library type used by a controller.
    The possible library types are:
    - Static Controller
    - Controller
    - Enhanced Slave
    - Slave
    - Installer
    - Routing Slave
    - Bridge Controller
    - Device Under Test
    The controller should never return a slave library type.
    For a more efficient test of whether a controller is a Bridge Controller, use
    the IsBridgeController method.
    \param _homeId The Home ID of the Z-Wave controller.
    \return a string containing the library type.
    \see GetLibraryVersion, IsBridgeController

    Parameters:
     - _homeId
    """
    self.send_GetLibraryTypeName(_homeId)
    return self.recv_GetLibraryTypeName()

  def send_GetLibraryTypeName(self, _homeId):
    self._oprot.writeMessageBegin('GetLibraryTypeName', TMessageType.CALL, self._seqid)
    args = GetLibraryTypeName_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLibraryTypeName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetLibraryTypeName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLibraryTypeName failed: unknown result");

  def GetSendQueueCount(self, _homeId):
    """
    \brief Get count of messages in the outgoing send queue.
    \param _homeId The Home ID of the Z-Wave controller.
    \return a integer message count

    Parameters:
     - _homeId
    """
    self.send_GetSendQueueCount(_homeId)
    return self.recv_GetSendQueueCount()

  def send_GetSendQueueCount(self, _homeId):
    self._oprot.writeMessageBegin('GetSendQueueCount', TMessageType.CALL, self._seqid)
    args = GetSendQueueCount_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSendQueueCount(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSendQueueCount_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSendQueueCount failed: unknown result");

  def GetPollInterval(self, ):
    """
    \brief Get the time period between polls of a node's state.
    """
    self.send_GetPollInterval()
    return self.recv_GetPollInterval()

  def send_GetPollInterval(self, ):
    self._oprot.writeMessageBegin('GetPollInterval', TMessageType.CALL, self._seqid)
    args = GetPollInterval_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetPollInterval(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetPollInterval_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPollInterval failed: unknown result");

  def SetPollInterval(self, _seconds):
    """
    \brief Set the time period between polls of a node's state.
    Due to patent concerns, some devices do not report state changes automatically to the controller.
    These devices need to have their state polled at regular intervals.  The length of the interval
    is the same for all devices.  To even out the Z-Wave network traffic generated by polling, OpenZWave
    divides the polling interval by the number of devices that have polling enabled, and polls each
    in turn.  It is recommended that if possible, the interval should not be set shorter than the
    number of polled devices in seconds (so that the network does not have to cope with more than one
    poll per second).
    \param _seconds The length of the polling interval in seconds.

    Parameters:
     - _seconds
    """
    self.send_SetPollInterval(_seconds)
    self.recv_SetPollInterval()

  def send_SetPollInterval(self, _seconds):
    self._oprot.writeMessageBegin('SetPollInterval', TMessageType.CALL, self._seqid)
    args = SetPollInterval_args()
    args._seconds = _seconds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetPollInterval(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetPollInterval_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def EnablePoll(self, _valueId):
    """
    \brief Enable the polling of a device's state.
    \param _valueId The ID of the value to start polling.
    \return True if polling was enabled.

    Parameters:
     - _valueId
    """
    self.send_EnablePoll(_valueId)
    return self.recv_EnablePoll()

  def send_EnablePoll(self, _valueId):
    self._oprot.writeMessageBegin('EnablePoll', TMessageType.CALL, self._seqid)
    args = EnablePoll_args()
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_EnablePoll(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = EnablePoll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "EnablePoll failed: unknown result");

  def DisablePoll(self, _valueId):
    """
    \brief Disable the polling of a device's state.
    \param _valueId The ID of the value to stop polling.
    \return True if polling was disabled.

    Parameters:
     - _valueId
    """
    self.send_DisablePoll(_valueId)
    return self.recv_DisablePoll()

  def send_DisablePoll(self, _valueId):
    self._oprot.writeMessageBegin('DisablePoll', TMessageType.CALL, self._seqid)
    args = DisablePoll_args()
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DisablePoll(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = DisablePoll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "DisablePoll failed: unknown result");

  def isPolled(self, _valueId):
    """
    \brief Determine the polling of a device's state.
    \param _valueId The ID of the value to check polling.
    \return True if polling is active.

    Parameters:
     - _valueId
    """
    self.send_isPolled(_valueId)
    return self.recv_isPolled()

  def send_isPolled(self, _valueId):
    self._oprot.writeMessageBegin('isPolled', TMessageType.CALL, self._seqid)
    args = isPolled_args()
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPolled(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isPolled_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPolled failed: unknown result");

  def RefreshNodeInfo(self, _homeId, _nodeId):
    """
    \brief Trigger the fetching of fixed data about a node.
    Causes the node's data to be obtained from the Z-Wave network in the same way as if it had just been added.
    This method would normally be called automatically by OpenZWave, but if you know that a node has been
    changed, calling this method will force a refresh of all of the data held by the library.  This can be especially
    useful for devices that were asleep when the application was first run. This is the
    same as the query state starting from the beginning.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the request was sent successfully.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RefreshNodeInfo(_homeId, _nodeId)
    return self.recv_RefreshNodeInfo()

  def send_RefreshNodeInfo(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RefreshNodeInfo', TMessageType.CALL, self._seqid)
    args = RefreshNodeInfo_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RefreshNodeInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RefreshNodeInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RefreshNodeInfo failed: unknown result");

  def RequestNodeState(self, _homeId, _nodeId):
    """
    \brief Trigger the fetching of dynamic value data for a node.
    Causes the node's values to be requested from the Z-Wave network. This is the
    same as the query state starting from the associations state.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the request was sent successfully.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RequestNodeState(_homeId, _nodeId)
    return self.recv_RequestNodeState()

  def send_RequestNodeState(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RequestNodeState', TMessageType.CALL, self._seqid)
    args = RequestNodeState_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestNodeState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestNodeState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RequestNodeState failed: unknown result");

  def RequestNodeDynamic(self, _homeId, _nodeId):
    """
    \brief Trigger the fetching of just the dynamic value data for a node.
    Causes the node's values to be requested from the Z-Wave network. This is the
    same as the query state starting from the dynamic state.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the request was sent successfully.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RequestNodeDynamic(_homeId, _nodeId)
    return self.recv_RequestNodeDynamic()

  def send_RequestNodeDynamic(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RequestNodeDynamic', TMessageType.CALL, self._seqid)
    args = RequestNodeDynamic_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestNodeDynamic(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestNodeDynamic_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RequestNodeDynamic failed: unknown result");

  def IsNodeListeningDevice(self, _homeId, _nodeId):
    """
    \brief Get whether the node is a listening device that does not go to sleep
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if it is a listening node.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeListeningDevice(_homeId, _nodeId)
    return self.recv_IsNodeListeningDevice()

  def send_IsNodeListeningDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeListeningDevice', TMessageType.CALL, self._seqid)
    args = IsNodeListeningDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeListeningDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeListeningDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeListeningDevice failed: unknown result");

  def IsNodeRoutingDevice(self, _homeId, _nodeId):
    """
    \brief Get whether the node is a routing device that passes messages to other nodes
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the node is a routing device

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeRoutingDevice(_homeId, _nodeId)
    return self.recv_IsNodeRoutingDevice()

  def send_IsNodeRoutingDevice(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeRoutingDevice', TMessageType.CALL, self._seqid)
    args = IsNodeRoutingDevice_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeRoutingDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeRoutingDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeRoutingDevice failed: unknown result");

  def GetNodeMaxBaudRate(self, _homeId, _nodeId):
    """
    \brief Get the maximum baud rate of a node's communications
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the baud rate in bits per second.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeMaxBaudRate(_homeId, _nodeId)
    return self.recv_GetNodeMaxBaudRate()

  def send_GetNodeMaxBaudRate(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeMaxBaudRate', TMessageType.CALL, self._seqid)
    args = GetNodeMaxBaudRate_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeMaxBaudRate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeMaxBaudRate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeMaxBaudRate failed: unknown result");

  def GetNodeVersion(self, _homeId, _nodeId):
    """
    \brief Get the version number of a node
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's version number

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeVersion(_homeId, _nodeId)
    return self.recv_GetNodeVersion()

  def send_GetNodeVersion(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeVersion', TMessageType.CALL, self._seqid)
    args = GetNodeVersion_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeVersion failed: unknown result");

  def GetNodeSecurity(self, _homeId, _nodeId):
    """
    \brief Get the security byte for a node.  Bit meanings are still to be determined.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's security byte

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeSecurity(_homeId, _nodeId)
    return self.recv_GetNodeSecurity()

  def send_GetNodeSecurity(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeSecurity', TMessageType.CALL, self._seqid)
    args = GetNodeSecurity_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeSecurity(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeSecurity_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeSecurity failed: unknown result");

  def GetNodeBasic(self, _homeId, _nodeId):
    """
    \brief Get the basic type of a node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's basic type.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeBasic(_homeId, _nodeId)
    return self.recv_GetNodeBasic()

  def send_GetNodeBasic(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeBasic', TMessageType.CALL, self._seqid)
    args = GetNodeBasic_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeBasic(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeBasic_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeBasic failed: unknown result");

  def GetNodeGeneric(self, _homeId, _nodeId):
    """
    \brief Get the generic type of a node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's generic type.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeGeneric(_homeId, _nodeId)
    return self.recv_GetNodeGeneric()

  def send_GetNodeGeneric(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeGeneric', TMessageType.CALL, self._seqid)
    args = GetNodeGeneric_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeGeneric(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeGeneric_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeGeneric failed: unknown result");

  def GetNodeSpecific(self, _homeId, _nodeId):
    """
    \brief Get the specific type of a node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return the node's specific type.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeSpecific(_homeId, _nodeId)
    return self.recv_GetNodeSpecific()

  def send_GetNodeSpecific(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeSpecific', TMessageType.CALL, self._seqid)
    args = GetNodeSpecific_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeSpecific(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeSpecific_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeSpecific failed: unknown result");

  def GetNodeType(self, _homeId, _nodeId):
    """
    \brief Get a human-readable label describing the node
    The label is taken from the Z-Wave specific, generic or basic type, depending on which of those values are specified by the node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the label text.

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeType(_homeId, _nodeId)
    return self.recv_GetNodeType()

  def send_GetNodeType(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeType', TMessageType.CALL, self._seqid)
    args = GetNodeType_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeType(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeType_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeType failed: unknown result");

  def GetNodeNeighbors(self, _homeId, _nodeId):
    """
    \brief Get the bitmap of this node's neighbors

    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _nodeNeighbors An array of 29 uint8s to hold the neighbor bitmap

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeNeighbors(_homeId, _nodeId)
    return self.recv_GetNodeNeighbors()

  def send_GetNodeNeighbors(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeNeighbors', TMessageType.CALL, self._seqid)
    args = GetNodeNeighbors_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeNeighbors(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeNeighbors_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeNeighbors failed: unknown result");

  def GetNodeManufacturerName(self, _homeId, _nodeId):
    """
    \brief Get the manufacturer name of a device
    The manufacturer name would normally be handled by the Manufacturer Specific commmand class,
    taking the manufacturer ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's manufacturer name.
    \see SetNodeManufacturerName, GetNodeProductName, SetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeManufacturerName(_homeId, _nodeId)
    return self.recv_GetNodeManufacturerName()

  def send_GetNodeManufacturerName(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeManufacturerName', TMessageType.CALL, self._seqid)
    args = GetNodeManufacturerName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeManufacturerName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeManufacturerName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeManufacturerName failed: unknown result");

  def GetNodeProductName(self, _homeId, _nodeId):
    """
    \brief Get the product name of a device
    The product name would normally be handled by the Manufacturer Specific commmand class,
    taking the product Type and ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's product name.
    \see SetNodeProductName, GetNodeManufacturerName, SetNodeManufacturerName

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeProductName(_homeId, _nodeId)
    return self.recv_GetNodeProductName()

  def send_GetNodeProductName(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeProductName', TMessageType.CALL, self._seqid)
    args = GetNodeProductName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeProductName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeProductName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeProductName failed: unknown result");

  def GetNodeName(self, _homeId, _nodeId):
    """
    \brief Get the name of a node
    The node name is a user-editable label for the node that would normally be handled by the
    Node Naming commmand class, but many devices do not support it.  So that a node can always
    be named, OpenZWave stores it with the node data, and provides access through this method
    and SetNodeName, rather than reporting it via a command class Value object.
    The maximum length of a node name is 16 characters.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's name.
    \see SetNodeName, GetNodeLocation, SetNodeLocation

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeName(_homeId, _nodeId)
    return self.recv_GetNodeName()

  def send_GetNodeName(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeName', TMessageType.CALL, self._seqid)
    args = GetNodeName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeName failed: unknown result");

  def GetNodeLocation(self, _homeId, _nodeId):
    """
    \brief Get the location of a node
    The node location is a user-editable string that would normally be handled by the Node Naming
    commmand class, but many devices do not support it.  So that a node can always report its
    location, OpenZWave stores it with the node data, and provides access through this method
    and SetNodeLocation, rather than reporting it via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's location.
    \see SetNodeLocation, GetNodeName, SetNodeName

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeLocation(_homeId, _nodeId)
    return self.recv_GetNodeLocation()

  def send_GetNodeLocation(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeLocation', TMessageType.CALL, self._seqid)
    args = GetNodeLocation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeLocation failed: unknown result");

  def GetNodeManufacturerId(self, _homeId, _nodeId):
    """
    \brief Get the manufacturer ID of a device
    The manufacturer ID is a four digit hex code and would normally be handled by the Manufacturer
    Specific commmand class, but not all devices support it.  Although the value reported by this
    method will be an empty string if the command class is not supported and cannot be set by the
    user, the manufacturer ID is still stored with the node data (rather than being reported via a
    command class Value object) to retain a consistent approach with the other manufacturer specific data.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's manufacturer ID, or an empty string if the manufactuer
    specific command class is not supported by the device.
    \see GetNodeProductType, GetNodeProductId, GetNodeManufacturerName, GetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeManufacturerId(_homeId, _nodeId)
    return self.recv_GetNodeManufacturerId()

  def send_GetNodeManufacturerId(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeManufacturerId', TMessageType.CALL, self._seqid)
    args = GetNodeManufacturerId_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeManufacturerId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeManufacturerId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeManufacturerId failed: unknown result");

  def GetNodeProductType(self, _homeId, _nodeId):
    """
    \brief Get the product type of a device
    The product type is a four digit hex code and would normally be handled by the Manufacturer Specific
    commmand class, but not all devices support it.  Although the value reported by this method will
    be an empty string if the command class is not supported and cannot be set by the user, the product
    type is still stored with the node data (rather than being reported via a command class Value object)
    to retain a consistent approach with the other manufacturer specific data.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's product type, or an empty string if the manufactuer
    specific command class is not supported by the device.
    \see GetNodeManufacturerId, GetNodeProductId, GetNodeManufacturerName, GetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeProductType(_homeId, _nodeId)
    return self.recv_GetNodeProductType()

  def send_GetNodeProductType(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeProductType', TMessageType.CALL, self._seqid)
    args = GetNodeProductType_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeProductType(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeProductType_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeProductType failed: unknown result");

  def GetNodeProductId(self, _homeId, _nodeId):
    """
    \brief Get the product ID of a device
    The product ID is a four digit hex code and would normally be handled by the Manufacturer Specific
    commmand class, but not all devices support it.  Although the value reported by this method will
    be an empty string if the command class is not supported and cannot be set by the user, the product
    ID is still stored with the node data (rather than being reported via a command class Value object)
    to retain a consistent approach with the other manufacturer specific data.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return A string containing the node's product ID, or an empty string if the manufactuer
    specific command class is not supported by the device.
    \see GetNodeManufacturerId, GetNodeProductType, GetNodeManufacturerName, GetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNodeProductId(_homeId, _nodeId)
    return self.recv_GetNodeProductId()

  def send_GetNodeProductId(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNodeProductId', TMessageType.CALL, self._seqid)
    args = GetNodeProductId_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeProductId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeProductId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeProductId failed: unknown result");

  def SetNodeManufacturerName(self, _homeId, _nodeId, _manufacturerName):
    """
    \brief Set the manufacturer name of a device
    The manufacturer name would normally be handled by the Manufacturer Specific commmand class,
    taking the manufacturer ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _manufacturerName	A string containing the node's manufacturer name.
    \see GetNodeManufacturerName, GetNodeProductName, SetNodeProductName

    Parameters:
     - _homeId
     - _nodeId
     - _manufacturerName
    """
    self.send_SetNodeManufacturerName(_homeId, _nodeId, _manufacturerName)
    self.recv_SetNodeManufacturerName()

  def send_SetNodeManufacturerName(self, _homeId, _nodeId, _manufacturerName):
    self._oprot.writeMessageBegin('SetNodeManufacturerName', TMessageType.CALL, self._seqid)
    args = SetNodeManufacturerName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._manufacturerName = _manufacturerName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeManufacturerName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeManufacturerName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeProductName(self, _homeId, _nodeId, _productName):
    """
    \brief Set the product name of a device
    The product name would normally be handled by the Manufacturer Specific commmand class,
    taking the product Type and ID reported by the device and using it to look up the name from the
    manufacturer_specific.xml file in the OpenZWave config folder.
    However, there are some devices that do not support the command class, so to enable the user
    to manually set the name, it is stored with the node data and accessed via this method rather
    than being reported via a command class Value object.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _productName A string containing the node's product name.
    \see GetNodeProductName, GetNodeManufacturerName, SetNodeManufacturerName

    Parameters:
     - _homeId
     - _nodeId
     - _productName
    """
    self.send_SetNodeProductName(_homeId, _nodeId, _productName)
    self.recv_SetNodeProductName()

  def send_SetNodeProductName(self, _homeId, _nodeId, _productName):
    self._oprot.writeMessageBegin('SetNodeProductName', TMessageType.CALL, self._seqid)
    args = SetNodeProductName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._productName = _productName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeProductName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeProductName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeName(self, _homeId, _nodeId, _nodeName):
    """
    \brief Set the name of a node
    The node name is a user-editable label for the node that would normally be handled by the
    Node Naming commmand class, but many devices do not support it.  So that a node can always
    be named, OpenZWave stores it with the node data, and provides access through this method
    and GetNodeName, rather than reporting it via a command class Value object.
    If the device does support the Node Naming command class, the new name will be sent to the node.
    The maximum length of a node name is 16 characters.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _nodeName A string containing the node's name.
    \see GetNodeName, GetNodeLocation, SetNodeLocation

    Parameters:
     - _homeId
     - _nodeId
     - _nodeName
    """
    self.send_SetNodeName(_homeId, _nodeId, _nodeName)
    self.recv_SetNodeName()

  def send_SetNodeName(self, _homeId, _nodeId, _nodeName):
    self._oprot.writeMessageBegin('SetNodeName', TMessageType.CALL, self._seqid)
    args = SetNodeName_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._nodeName = _nodeName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeLocation(self, _homeId, _nodeId, _location):
    """
    \brief Set the location of a node
    The node location is a user-editable string that would normally be handled by the Node Naming
    commmand class, but many devices do not support it.  So that a node can always report its
    location, OpenZWave stores it with the node data, and provides access through this method
    and GetNodeLocation, rather than reporting it via a command class Value object.
    If the device does support the Node Naming command class, the new location will be sent to the node.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _location A string containing the node's location.
    \see GetNodeLocation, GetNodeName, SetNodeName

    Parameters:
     - _homeId
     - _nodeId
     - _location
    """
    self.send_SetNodeLocation(_homeId, _nodeId, _location)
    self.recv_SetNodeLocation()

  def send_SetNodeLocation(self, _homeId, _nodeId, _location):
    self._oprot.writeMessageBegin('SetNodeLocation', TMessageType.CALL, self._seqid)
    args = SetNodeLocation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._location = _location
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeOn(self, _homeId, _nodeId):
    """
    \brief Turns a node on
    This is a helper method to simplify basic control of a node.  It is the equivalent of
    changing the level reported by the node's Basic command class to 255, and will generate a
    ValueChanged notification from that class.  This command will turn on the device at its
    last known level, if supported by the device, otherwise it will turn	it on at 100%.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to be changed.
    \see SetNodeOff, SetNodeLevel

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_SetNodeOn(_homeId, _nodeId)
    self.recv_SetNodeOn()

  def send_SetNodeOn(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('SetNodeOn', TMessageType.CALL, self._seqid)
    args = SetNodeOn_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeOn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeOn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeOff(self, _homeId, _nodeId):
    """
    \brief Turns a node off
    This is a helper method to simplify basic control of a node.  It is the equivalent of
    changing the level reported by the node's Basic command class to zero, and will generate
    a ValueChanged notification from that class.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to be changed.
    \see SetNodeOn, SetNodeLevel

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_SetNodeOff(_homeId, _nodeId)
    self.recv_SetNodeOff()

  def send_SetNodeOff(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('SetNodeOff', TMessageType.CALL, self._seqid)
    args = SetNodeOff_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeOff(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeOff_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetNodeLevel(self, _homeId, _nodeId, _level):
    """
    \brief Sets the basic level of a node
    This is a helper method to simplify basic control of a node.  It is the equivalent of
    changing the value reported by the node's Basic command class and will generate a
    ValueChanged notification from that class.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to be changed.
    \param _level The level to set the node.  Valid values are 0-99 and 255.  Zero is off and
    99 is fully on.  255 will turn on the device at its last known level (if supported).
    \see SetNodeOn, SetNodeOff

    Parameters:
     - _homeId
     - _nodeId
     - _level
    """
    self.send_SetNodeLevel(_homeId, _nodeId, _level)
    self.recv_SetNodeLevel()

  def send_SetNodeLevel(self, _homeId, _nodeId, _level):
    self._oprot.writeMessageBegin('SetNodeLevel', TMessageType.CALL, self._seqid)
    args = SetNodeLevel_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._level = _level
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetNodeLevel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetNodeLevel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def IsNodeInfoReceived(self, _homeId, _nodeId):
    """
    \brief Get whether the node information has been received
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \return True if the node information has been received yet

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_IsNodeInfoReceived(_homeId, _nodeId)
    return self.recv_IsNodeInfoReceived()

  def send_IsNodeInfoReceived(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('IsNodeInfoReceived', TMessageType.CALL, self._seqid)
    args = IsNodeInfoReceived_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsNodeInfoReceived(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsNodeInfoReceived_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeInfoReceived failed: unknown result");

  def GetNodeClassInformation(self, _homeId, _nodeId, _commandClassId):
    """
    \brief Get whether the node has the defined class available or not
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to query.
    \param _commandClassId Id of the class to test for
    \return True if the node does have the class instantiated, will return name & version

    Parameters:
     - _homeId
     - _nodeId
     - _commandClassId
    """
    self.send_GetNodeClassInformation(_homeId, _nodeId, _commandClassId)
    return self.recv_GetNodeClassInformation()

  def send_GetNodeClassInformation(self, _homeId, _nodeId, _commandClassId):
    self._oprot.writeMessageBegin('GetNodeClassInformation', TMessageType.CALL, self._seqid)
    args = GetNodeClassInformation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._commandClassId = _commandClassId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNodeClassInformation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNodeClassInformation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeClassInformation failed: unknown result");

  def GetValueLabel(self, _id):
    """
    \brief Gets the user-friendly label for the value.
    \param _id The unique identifier of the value.
    \return The value label.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_GetValueLabel(_id)
    return self.recv_GetValueLabel()

  def send_GetValueLabel(self, _id):
    self._oprot.writeMessageBegin('GetValueLabel', TMessageType.CALL, self._seqid)
    args = GetValueLabel_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueLabel failed: unknown result");

  def SetValueLabel(self, _id, _value):
    """
    \brief Sets the user-friendly label for the value.
    \param _id The unique identifier of the value.
    \param _value The new value of the label.
    \see ValueID

    Parameters:
     - _id
     - _value
    """
    self.send_SetValueLabel(_id, _value)
    self.recv_SetValueLabel()

  def send_SetValueLabel(self, _id, _value):
    self._oprot.writeMessageBegin('SetValueLabel', TMessageType.CALL, self._seqid)
    args = SetValueLabel_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetValueUnits(self, _id):
    """
    \brief Gets the units that the value is measured in.
    \param _id The unique identifier of the value.
    \return The value units.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_GetValueUnits(_id)
    return self.recv_GetValueUnits()

  def send_GetValueUnits(self, _id):
    self._oprot.writeMessageBegin('GetValueUnits', TMessageType.CALL, self._seqid)
    args = GetValueUnits_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueUnits(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueUnits_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueUnits failed: unknown result");

  def SetValueUnits(self, _id, _value):
    """
    \brief Sets the units that the value is measured in.
    \param _id The unique identifier of the value.
    \param _value The new value of the units.
    \see ValueID

    Parameters:
     - _id
     - _value
    """
    self.send_SetValueUnits(_id, _value)
    self.recv_SetValueUnits()

  def send_SetValueUnits(self, _id, _value):
    self._oprot.writeMessageBegin('SetValueUnits', TMessageType.CALL, self._seqid)
    args = SetValueUnits_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueUnits(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueUnits_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetValueHelp(self, _id):
    """
    \brief Gets a help string describing the value's purpose and usage.
    \param _id The unique identifier of the value.
    \return The value help text.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_GetValueHelp(_id)
    return self.recv_GetValueHelp()

  def send_GetValueHelp(self, _id):
    self._oprot.writeMessageBegin('GetValueHelp', TMessageType.CALL, self._seqid)
    args = GetValueHelp_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueHelp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueHelp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueHelp failed: unknown result");

  def SetValueHelp(self, _id, _value):
    """
    \brief Sets a help string describing the value's purpose and usage.
    \param _id The unique identifier of the value.
    \param _value The new value of the help text.
    \see ValueID

    Parameters:
     - _id
     - _value
    """
    self.send_SetValueHelp(_id, _value)
    self.recv_SetValueHelp()

  def send_SetValueHelp(self, _id, _value):
    self._oprot.writeMessageBegin('SetValueHelp', TMessageType.CALL, self._seqid)
    args = SetValueHelp_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueHelp(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueHelp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetValueMin(self, _id):
    """
    \brief Gets the minimum that this value may contain.
    \param _id The unique identifier of the value.
    \return The value minimum.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_GetValueMin(_id)
    return self.recv_GetValueMin()

  def send_GetValueMin(self, _id):
    self._oprot.writeMessageBegin('GetValueMin', TMessageType.CALL, self._seqid)
    args = GetValueMin_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueMin(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueMin_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueMin failed: unknown result");

  def GetValueMax(self, _id):
    """
    \brief Gets the maximum that this value may contain.
    \param _id The unique identifier of the value.
    \return The value maximum.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_GetValueMax(_id)
    return self.recv_GetValueMax()

  def send_GetValueMax(self, _id):
    self._oprot.writeMessageBegin('GetValueMax', TMessageType.CALL, self._seqid)
    args = GetValueMax_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueMax(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueMax_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueMax failed: unknown result");

  def IsValueReadOnly(self, _id):
    """
    \brief Test whether the value is read-only.
    \param _id The unique identifier of the value.
    \return true if the value cannot be changed by the user.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_IsValueReadOnly(_id)
    return self.recv_IsValueReadOnly()

  def send_IsValueReadOnly(self, _id):
    self._oprot.writeMessageBegin('IsValueReadOnly', TMessageType.CALL, self._seqid)
    args = IsValueReadOnly_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValueReadOnly(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValueReadOnly_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValueReadOnly failed: unknown result");

  def IsValueWriteOnly(self, _id):
    """
    \brief Test whether the value is write-only.
    \param _id The unique identifier of the value.
    \return true if the value can only be written to and not read.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_IsValueWriteOnly(_id)
    return self.recv_IsValueWriteOnly()

  def send_IsValueWriteOnly(self, _id):
    self._oprot.writeMessageBegin('IsValueWriteOnly', TMessageType.CALL, self._seqid)
    args = IsValueWriteOnly_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValueWriteOnly(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValueWriteOnly_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValueWriteOnly failed: unknown result");

  def IsValueSet(self, _id):
    """
    \brief Test whether the value has been set.
    \param _id The unique identifier of the value.
    \return true if the value has actually been set by a status message from the device, rather than simply being the default.
    \see ValueID

    Parameters:
     - _id
    """
    self.send_IsValueSet(_id)
    return self.recv_IsValueSet()

  def send_IsValueSet(self, _id):
    self._oprot.writeMessageBegin('IsValueSet', TMessageType.CALL, self._seqid)
    args = IsValueSet_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsValueSet(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = IsValueSet_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsValueSet failed: unknown result");

  def GetValueAsBool(self, _id):
    """
    \brief Gets a value as a bool.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a bool that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Bool. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    self.send_GetValueAsBool(_id)
    return self.recv_GetValueAsBool()

  def send_GetValueAsBool(self, _id):
    self._oprot.writeMessageBegin('GetValueAsBool', TMessageType.CALL, self._seqid)
    args = GetValueAsBool_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsBool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsBool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsBool failed: unknown result");

  def GetValueAsByte(self, _id):
    """
    \brief Gets a value as an 8-bit unsigned integer.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a uint8 that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Byte. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    self.send_GetValueAsByte(_id)
    return self.recv_GetValueAsByte()

  def send_GetValueAsByte(self, _id):
    self._oprot.writeMessageBegin('GetValueAsByte', TMessageType.CALL, self._seqid)
    args = GetValueAsByte_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsByte(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsByte_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsByte failed: unknown result");

  def GetValueAsFloat(self, _id):
    """
    \brief Gets a value as a float.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a float that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    self.send_GetValueAsFloat(_id)
    return self.recv_GetValueAsFloat()

  def send_GetValueAsFloat(self, _id):
    self._oprot.writeMessageBegin('GetValueAsFloat', TMessageType.CALL, self._seqid)
    args = GetValueAsFloat_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsFloat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsFloat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsFloat failed: unknown result");

  def GetValueAsInt(self, _id):
    """
    \brief Gets a value as a 32-bit signed integer.
    \param _id The unique identifier of the value.
    \param o_value Pointer to an int32 that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Int. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    self.send_GetValueAsInt(_id)
    return self.recv_GetValueAsInt()

  def send_GetValueAsInt(self, _id):
    self._oprot.writeMessageBegin('GetValueAsInt', TMessageType.CALL, self._seqid)
    args = GetValueAsInt_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsInt(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsInt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsInt failed: unknown result");

  def GetValueAsShort(self, _id):
    """
    \brief Gets a value as a 16-bit signed integer.
    \param _id The unique identifier of the value.
    \param o_value Pointer to an int16 that will be filled with the value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Short. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsString, GetValueListSelection, GetValueListItems.

    Parameters:
     - _id
    """
    self.send_GetValueAsShort(_id)
    return self.recv_GetValueAsShort()

  def send_GetValueAsShort(self, _id):
    self._oprot.writeMessageBegin('GetValueAsShort', TMessageType.CALL, self._seqid)
    args = GetValueAsShort_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsShort(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsShort_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsShort failed: unknown result");

  def GetValueAsString(self, _id):
    """
    \brief Gets a value as a string.
    Creates a string representation of a value, regardless of type.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a string that will be filled with the value.
    \return true if the value was obtained.</returns>
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueListSelection, GetValueListItems.

    Parameters:
     - _id
    """
    self.send_GetValueAsString(_id)
    return self.recv_GetValueAsString()

  def send_GetValueAsString(self, _id):
    self._oprot.writeMessageBegin('GetValueAsString', TMessageType.CALL, self._seqid)
    args = GetValueAsString_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueAsString(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueAsString_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueAsString failed: unknown result");

  def GetValueListSelection_String(self, _id):
    """
    \brief Gets the selected item from a list (as a string).
    \param _id The unique identifier of the value.
    \param o_value Pointer to a string that will be filled with the selected item.
    \return True if the value was obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListItems.

    Parameters:
     - _id
    """
    self.send_GetValueListSelection_String(_id)
    return self.recv_GetValueListSelection_String()

  def send_GetValueListSelection_String(self, _id):
    self._oprot.writeMessageBegin('GetValueListSelection_String', TMessageType.CALL, self._seqid)
    args = GetValueListSelection_String_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueListSelection_String failed: unknown result");

  def GetValueListSelection_Int32(self, _id):
    """
    \brief Gets the selected item from a list (as an integer).
    \param _id The unique identifier of the value.
    \param o_value Pointer to an integer that will be filled with the selected item.
    \return True if the value was obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListItems.

    Parameters:
     - _id
    """
    self.send_GetValueListSelection_Int32(_id)
    return self.recv_GetValueListSelection_Int32()

  def send_GetValueListSelection_Int32(self, _id):
    self._oprot.writeMessageBegin('GetValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = GetValueListSelection_Int32_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueListSelection_Int32 failed: unknown result");

  def GetValueListItems(self, _id):
    """
    \brief Gets the list of items from a list value.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a vector of strings that will be filled with list items. The vector will be cleared before the items are added.
    \return true if the list items were obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection.

    Parameters:
     - _id
    """
    self.send_GetValueListItems(_id)
    return self.recv_GetValueListItems()

  def send_GetValueListItems(self, _id):
    self._oprot.writeMessageBegin('GetValueListItems', TMessageType.CALL, self._seqid)
    args = GetValueListItems_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueListItems(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueListItems_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueListItems failed: unknown result");

  def GetValueFloatPrecision(self, _id):
    """
    \brief Gets a float value's precision.
    \param _id The unique identifier of the value.
    \param o_value Pointer to a uint8 that will be filled with the precision value.
    \return true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType
    \see ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems

    Parameters:
     - _id
    """
    self.send_GetValueFloatPrecision(_id)
    return self.recv_GetValueFloatPrecision()

  def send_GetValueFloatPrecision(self, _id):
    self._oprot.writeMessageBegin('GetValueFloatPrecision', TMessageType.CALL, self._seqid)
    args = GetValueFloatPrecision_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetValueFloatPrecision(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetValueFloatPrecision_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetValueFloatPrecision failed: unknown result");

  def SetValue_Bool(self, _id, _value):
    """
    \brief Sets the state of a bool.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the bool value.
    \param _value The new value of the bool.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Bool. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Bool(_id, _value)
    return self.recv_SetValue_Bool()

  def send_SetValue_Bool(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Bool', TMessageType.CALL, self._seqid)
    args = SetValue_Bool_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Bool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Bool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Bool failed: unknown result");

  def SetValue_UInt8(self, _id, _value):
    """
    \brief Sets the value of a byte.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the byte value.
    \param _value The new value of the byte.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Byte. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_UInt8(_id, _value)
    return self.recv_SetValue_UInt8()

  def send_SetValue_UInt8(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_UInt8', TMessageType.CALL, self._seqid)
    args = SetValue_UInt8_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_UInt8(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_UInt8_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_UInt8 failed: unknown result");

  def SetValue_Float(self, _id, _value):
    """
    \brief Sets the value of a decimal.
    It is usually better to handle decimal values using strings rather than floats, to avoid floating point accuracy issues.
    Due to the possibility of a device being asleep, the command is assumed to succeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the decimal value.
    \param _value The new value of the decimal.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Float(_id, _value)
    return self.recv_SetValue_Float()

  def send_SetValue_Float(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Float', TMessageType.CALL, self._seqid)
    args = SetValue_Float_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Float(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Float_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Float failed: unknown result");

  def SetValue_Int32(self, _id, _value):
    """
    \brief Sets the value of a 32-bit signed integer.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the integer value.
    \param _value The new value of the integer.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Int. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Int32(_id, _value)
    return self.recv_SetValue_Int32()

  def send_SetValue_Int32(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Int32', TMessageType.CALL, self._seqid)
    args = SetValue_Int32_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Int32 failed: unknown result");

  def SetValue_Int16(self, _id, _value):
    """
    \brief Sets the value of a 16-bit signed integer.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the integer value.
    \param _value The new value of the integer.
    \return true if the value was set.  Returns false if the value is not a ValueID::ValueType_Short. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_Int16(_id, _value)
    return self.recv_SetValue_Int16()

  def send_SetValue_Int16(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_Int16', TMessageType.CALL, self._seqid)
    args = SetValue_Int16_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_Int16(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_Int16_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_Int16 failed: unknown result");

  def SetValue_String(self, _id, _value):
    """
    \brief Sets the value from a string, regardless of type.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the integer value.
    \param _value The new value of the string.
    \return true if the value was set.  Returns false if the value could not be parsed into the correct type for the value.

    Parameters:
     - _id
     - _value
    """
    self.send_SetValue_String(_id, _value)
    return self.recv_SetValue_String()

  def send_SetValue_String(self, _id, _value):
    self._oprot.writeMessageBegin('SetValue_String', TMessageType.CALL, self._seqid)
    args = SetValue_String_args()
    args._id = _id
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValue_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValue_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValue_String failed: unknown result");

  def SetValueListSelection(self, _id, _selectedItem):
    """
    \brief Sets the selected item in a list.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
    held by the node is updated directly.  This will be reverted by a future status message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _id The unique identifier of the list value.
    \param _selectedItem A string matching the new selected item in the list.
    \return true if the value was set.  Returns false if the selection is not in the list, or if the value is not a ValueID::ValueType_List.
    The type can be tested with a call to ValueID::GetType

    Parameters:
     - _id
     - _selectedItem
    """
    self.send_SetValueListSelection(_id, _selectedItem)
    return self.recv_SetValueListSelection()

  def send_SetValueListSelection(self, _id, _selectedItem):
    self._oprot.writeMessageBegin('SetValueListSelection', TMessageType.CALL, self._seqid)
    args = SetValueListSelection_args()
    args._id = _id
    args._selectedItem = _selectedItem
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetValueListSelection(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetValueListSelection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetValueListSelection failed: unknown result");

  def PressButton(self, _id):
    """
    \brief Starts an activity in a device.
    Since buttons are write-only values that do not report a state, no notification callbacks are sent.
    \param _id The unique identifier of the integer value.
    \return true if the activity was started.  Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
    """
    self.send_PressButton(_id)
    return self.recv_PressButton()

  def send_PressButton(self, _id):
    self._oprot.writeMessageBegin('PressButton', TMessageType.CALL, self._seqid)
    args = PressButton_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_PressButton(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = PressButton_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "PressButton failed: unknown result");

  def ReleaseButton(self, _id):
    """
    \brief Stops an activity in a device.
    Since buttons are write-only values that do not report a state, no notification callbacks are sent.
    \param _id The unique identifier of the integer value.
    \return true if the activity was stopped.  Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
    """
    self.send_ReleaseButton(_id)
    return self.recv_ReleaseButton()

  def send_ReleaseButton(self, _id):
    self._oprot.writeMessageBegin('ReleaseButton', TMessageType.CALL, self._seqid)
    args = ReleaseButton_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ReleaseButton(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ReleaseButton_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ReleaseButton failed: unknown result");

  def GetNumSwitchPoints(self, _id):
    """
    \brief Get the number of switch points defined in a schedule.
    \param _id The unique identifier of the schedule value.
    \return the number of switch points defined in this schedule.  Returns zero if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.

    Parameters:
     - _id
    """
    self.send_GetNumSwitchPoints(_id)
    return self.recv_GetNumSwitchPoints()

  def send_GetNumSwitchPoints(self, _id):
    self._oprot.writeMessageBegin('GetNumSwitchPoints', TMessageType.CALL, self._seqid)
    args = GetNumSwitchPoints_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNumSwitchPoints(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNumSwitchPoints_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumSwitchPoints failed: unknown result");

  def SetSwitchPoint(self, _id, _hours, _minutes, _setback):
    """
    \brief Set a switch point in the schedule.
    Inserts a new switch point into the schedule, unless a switch point already exists at the specified
    time in which case that switch point is updated with the new setback value instead.
    A maximum of nine switch points can be set in the schedule.
    \param _id The unique identifier of the schedule value.
    \param _hours The hours part of the time when the switch point will trigger.  The time is set using
    the 24-hour clock, so this value must be between 0 and 23.
    \param _minutes The minutes part of the time when the switch point will trigger.  This value must be
    between 0 and 59.
    \param _setback The setback in tenths of a degree Celsius.  The setback value can range from -128 (-12.8C)
    to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and
    122 is used to set Energy Saving mode.
    \return true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.
    \see GetNumSwitchPoints, RemoveSwitchPoint, ClearSwitchPoints

    Parameters:
     - _id
     - _hours
     - _minutes
     - _setback
    """
    self.send_SetSwitchPoint(_id, _hours, _minutes, _setback)
    return self.recv_SetSwitchPoint()

  def send_SetSwitchPoint(self, _id, _hours, _minutes, _setback):
    self._oprot.writeMessageBegin('SetSwitchPoint', TMessageType.CALL, self._seqid)
    args = SetSwitchPoint_args()
    args._id = _id
    args._hours = _hours
    args._minutes = _minutes
    args._setback = _setback
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSwitchPoint(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSwitchPoint_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSwitchPoint failed: unknown result");

  def RemoveSwitchPoint(self, _id, _hours, _minutes):
    """
    \brief Remove a switch point from the schedule.
    Removes the switch point at the specified time from the schedule.
    \param _id The unique identifier of the schedule value.
    \param _hours The hours part of the time when the switch point will trigger.  The time is set using
    the 24-hour clock, so this value must be between 0 and 23.
    \param _minutes The minutes part of the time when the switch point will trigger.  This value must be
    between 0 and 59.
    \return true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule or if there
    is not switch point with the specified time values. The type can be tested with a call to ValueID::GetType.
    \see GetNumSwitchPoints, SetSwitchPoint, ClearSwitchPoints

    Parameters:
     - _id
     - _hours
     - _minutes
    """
    self.send_RemoveSwitchPoint(_id, _hours, _minutes)
    return self.recv_RemoveSwitchPoint()

  def send_RemoveSwitchPoint(self, _id, _hours, _minutes):
    self._oprot.writeMessageBegin('RemoveSwitchPoint', TMessageType.CALL, self._seqid)
    args = RemoveSwitchPoint_args()
    args._id = _id
    args._hours = _hours
    args._minutes = _minutes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveSwitchPoint(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveSwitchPoint_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveSwitchPoint failed: unknown result");

  def ClearSwitchPoints(self, _id):
    """
    \brief Clears all switch points from the schedule.
    \param _id The unique identifier of the schedule value.
    \see GetNumSwitchPoints, SetSwitchPoint, RemoveSwitchPoint

    Parameters:
     - _id
    """
    self.send_ClearSwitchPoints(_id)
    self.recv_ClearSwitchPoints()

  def send_ClearSwitchPoints(self, _id):
    self._oprot.writeMessageBegin('ClearSwitchPoints', TMessageType.CALL, self._seqid)
    args = ClearSwitchPoints_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ClearSwitchPoints(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ClearSwitchPoints_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetSwitchPoint(self, _id, _idx):
    """
    \brief Gets switch point data from the schedule.
    Retrieves the time and setback values from a switch point in the schedule.
    \param _id The unique identifier of the schedule value.
    \param _idx The index of the switch point, between zero and one less than the value
    returned by GetNumSwitchPoints.
    \param o_hours a pointer to a uint8 that will be filled with the hours part of the switch point data.
    \param o_minutes a pointer to a uint8 that will be filled with the minutes part of the switch point data.
    \param o_setback a pointer to an int8 that will be filled with the setback value.  This can range from -128
    (-12.8C)to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and
    122 is used to set Energy Saving mode.
    \return true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.
    \see GetNumSwitchPoints

    Parameters:
     - _id
     - _idx
    """
    self.send_GetSwitchPoint(_id, _idx)
    return self.recv_GetSwitchPoint()

  def send_GetSwitchPoint(self, _id, _idx):
    self._oprot.writeMessageBegin('GetSwitchPoint', TMessageType.CALL, self._seqid)
    args = GetSwitchPoint_args()
    args._id = _id
    args._idx = _idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSwitchPoint(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSwitchPoint_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSwitchPoint failed: unknown result");

  def SwitchAllOn(self, _homeId):
    """
    \brief Switch all devices on.
    All devices that support the SwitchAll command class will be turned on.

    Parameters:
     - _homeId
    """
    self.send_SwitchAllOn(_homeId)
    self.recv_SwitchAllOn()

  def send_SwitchAllOn(self, _homeId):
    self._oprot.writeMessageBegin('SwitchAllOn', TMessageType.CALL, self._seqid)
    args = SwitchAllOn_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SwitchAllOn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SwitchAllOn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SwitchAllOff(self, _homeId):
    """
    \brief Switch all devices off.
    All devices that support the SwitchAll command class will be turned off.

    Parameters:
     - _homeId
    """
    self.send_SwitchAllOff(_homeId)
    self.recv_SwitchAllOff()

  def send_SwitchAllOff(self, _homeId):
    self._oprot.writeMessageBegin('SwitchAllOff', TMessageType.CALL, self._seqid)
    args = SwitchAllOff_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SwitchAllOff(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SwitchAllOff_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SetConfigParam(self, _homeId, _nodeId, _param, _value, _size):
    """
    \brief Set the value of a configurable parameter in a device.
    Some devices have various parameters that can be configured to control the device behaviour.
    These are not reported by the device over the Z-Wave network, but can usually be found in
    the device's user manual.
    This method returns immediately, without waiting for confirmation from the device that the
    change has been made.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to configure.
    \param _param The index of the parameter.
    \param _value The value to which the parameter should be set.
    \param _size Is an optional number of bytes to be sent for the paramter _value. Defaults to 2.
    \return true if the a message setting the value was sent to the device.
    \see RequestConfigParam

    Parameters:
     - _homeId
     - _nodeId
     - _param
     - _value
     - _size
    """
    self.send_SetConfigParam(_homeId, _nodeId, _param, _value, _size)
    return self.recv_SetConfigParam()

  def send_SetConfigParam(self, _homeId, _nodeId, _param, _value, _size):
    self._oprot.writeMessageBegin('SetConfigParam', TMessageType.CALL, self._seqid)
    args = SetConfigParam_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._param = _param
    args._value = _value
    args._size = _size
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetConfigParam(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetConfigParam_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetConfigParam failed: unknown result");

  def RequestConfigParam(self, _homeId, _nodeId, _param):
    """
    \brief Request the value of a configurable parameter from a device.
    Some devices have various parameters that can be configured to control the device behaviour.
    These are not reported by the device over the Z-Wave network, but can usually be found in
    the device's user manual.
    This method requests the value of a parameter from the device, and then returns immediately,
    without waiting for a response.  If the parameter index is valid for this device, and the
    device is awake, the value will eventually be reported via a ValueChanged notification callback.
    The ValueID reported in the callback will have an index set the same as _param and a command class
    set to the same value as returned by a call to Configuration::StaticGetCommandClassId.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to configure.
    \param _param The index of the parameter.
    \see SetConfigParam, ValueID, Notification

    Parameters:
     - _homeId
     - _nodeId
     - _param
    """
    self.send_RequestConfigParam(_homeId, _nodeId, _param)
    self.recv_RequestConfigParam()

  def send_RequestConfigParam(self, _homeId, _nodeId, _param):
    self._oprot.writeMessageBegin('RequestConfigParam', TMessageType.CALL, self._seqid)
    args = RequestConfigParam_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._param = _param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestConfigParam(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestConfigParam_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RequestAllConfigParams(self, _homeId, _nodeId):
    """
    \brief Request the values of all known configurable parameters from a device.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node to configure.
    \see SetConfigParam, ValueID, Notification

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_RequestAllConfigParams(_homeId, _nodeId)
    self.recv_RequestAllConfigParams()

  def send_RequestAllConfigParams(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('RequestAllConfigParams', TMessageType.CALL, self._seqid)
    args = RequestAllConfigParams_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RequestAllConfigParams(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RequestAllConfigParams_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def GetNumGroups(self, _homeId, _nodeId):
    """
    \brief Gets the number of association groups reported by this node
    In Z-Wave, groups are numbered starting from one.  For example, if a call to GetNumGroups returns 4, the _groupIdx
    value to use in calls to GetAssociations, AddAssociation and RemoveAssociation will be a number between 1 and 4.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose groups we are interested in.
    \return The number of groups.
    \see GetAssociations, GetMaxAssociations, AddAssociation, RemoveAssociation

    Parameters:
     - _homeId
     - _nodeId
    """
    self.send_GetNumGroups(_homeId, _nodeId)
    return self.recv_GetNumGroups()

  def send_GetNumGroups(self, _homeId, _nodeId):
    self._oprot.writeMessageBegin('GetNumGroups', TMessageType.CALL, self._seqid)
    args = GetNumGroups_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNumGroups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNumGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumGroups failed: unknown result");

  def GetAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    \brief Gets the associations for a group.
    Makes a copy of the list of associated nodes in the group, and returns it in an array of uint8's.
    The caller is responsible for freeing the array memory with a call to delete [].
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations we are interested in.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \param o_associations If the number of associations returned is greater than zero, o_associations will be set to point to an array containing the IDs of the associated nodes.
    \return The number of nodes in the associations array.  If zero, the array will point to NULL, and does not need to be deleted.
    \see GetNumGroups, AddAssociation, RemoveAssociation, GetMaxAssociations

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    self.send_GetAssociations(_homeId, _nodeId, _groupIdx)
    return self.recv_GetAssociations()

  def send_GetAssociations(self, _homeId, _nodeId, _groupIdx):
    self._oprot.writeMessageBegin('GetAssociations', TMessageType.CALL, self._seqid)
    args = GetAssociations_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAssociations(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetAssociations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAssociations failed: unknown result");

  def GetMaxAssociations(self, _homeId, _nodeId, _groupIdx):
    """
    \brief Gets the maximum number of associations for a group.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations we are interested in.
    \param _groupIdx one-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \return The maximum number of nodes that can be associated into the group.
    \see GetNumGroups, AddAssociation, RemoveAssociation, GetAssociations

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    self.send_GetMaxAssociations(_homeId, _nodeId, _groupIdx)
    return self.recv_GetMaxAssociations()

  def send_GetMaxAssociations(self, _homeId, _nodeId, _groupIdx):
    self._oprot.writeMessageBegin('GetMaxAssociations', TMessageType.CALL, self._seqid)
    args = GetMaxAssociations_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetMaxAssociations(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetMaxAssociations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMaxAssociations failed: unknown result");

  def GetGroupLabel(self, _homeId, _nodeId, _groupIdx):
    """
    \brief Returns a label for the particular group of a node.
    This label is populated by the device specific configuration files.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations are to be changed.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \see GetNumGroups, GetAssociations, GetMaxAssociations, AddAssociation

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
    """
    self.send_GetGroupLabel(_homeId, _nodeId, _groupIdx)
    return self.recv_GetGroupLabel()

  def send_GetGroupLabel(self, _homeId, _nodeId, _groupIdx):
    self._oprot.writeMessageBegin('GetGroupLabel', TMessageType.CALL, self._seqid)
    args = GetGroupLabel_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetGroupLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetGroupLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupLabel failed: unknown result");

  def AddAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    \brief Adds a node to an association group.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the association data
    held in this class is updated directly.  This will be reverted by a future Association message from the device
    if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations are to be changed.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \param _targetNodeId Identifier for the node that will be added to the association group.
    \see GetNumGroups, GetAssociations, GetMaxAssociations, RemoveAssociation

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    self.send_AddAssociation(_homeId, _nodeId, _groupIdx, _targetNodeId)
    self.recv_AddAssociation()

  def send_AddAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    self._oprot.writeMessageBegin('AddAssociation', TMessageType.CALL, self._seqid)
    args = AddAssociation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args._targetNodeId = _targetNodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddAssociation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddAssociation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RemoveAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    """
    \brief Removes a node from an association group.
    Due to the possibility of a device being asleep, the command is assumed to suceeed, and the association data
    held in this class is updated directly.  This will be reverted by a future Association message from the device
    if the Z-Wave message actually failed to get through.   Notification callbacks will be sent in both cases.
    \param _homeId The Home ID of the Z-Wave controller that manages the node.
    \param _nodeId The ID of the node whose associations are to be changed.
    \param _groupIdx One-based index of the group (because Z-Wave product manuals use one-based group numbering).
    \param _targetNodeId Identifier for the node that will be removed from the association group.
    \see GetNumGroups, GetAssociations, GetMaxAssociations, AddAssociation

    Parameters:
     - _homeId
     - _nodeId
     - _groupIdx
     - _targetNodeId
    """
    self.send_RemoveAssociation(_homeId, _nodeId, _groupIdx, _targetNodeId)
    self.recv_RemoveAssociation()

  def send_RemoveAssociation(self, _homeId, _nodeId, _groupIdx, _targetNodeId):
    self._oprot.writeMessageBegin('RemoveAssociation', TMessageType.CALL, self._seqid)
    args = RemoveAssociation_args()
    args._homeId = _homeId
    args._nodeId = _nodeId
    args._groupIdx = _groupIdx
    args._targetNodeId = _targetNodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveAssociation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveAssociation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def ResetController(self, _homeId):
    """
    \brief Hard Reset a PC Z-Wave Controller.
    Resets a controller and erases its network configuration settings.  The controller becomes a primary controller ready to add devices to a new network.
    \param _homeId The Home ID of the Z-Wave controller to be reset.
    \see SoftReset

    Parameters:
     - _homeId
    """
    self.send_ResetController(_homeId)
    self.recv_ResetController()

  def send_ResetController(self, _homeId):
    self._oprot.writeMessageBegin('ResetController', TMessageType.CALL, self._seqid)
    args = ResetController_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ResetController(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ResetController_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SoftReset(self, _homeId):
    """
    \brief Soft Reset a PC Z-Wave Controller.
    Resets a controller without erasing its network configuration settings.
    \param _homeId The Home ID of the Z-Wave controller to be reset.
    \see SoftReset

    Parameters:
     - _homeId
    """
    self.send_SoftReset(_homeId)
    self.recv_SoftReset()

  def send_SoftReset(self, _homeId):
    self._oprot.writeMessageBegin('SoftReset', TMessageType.CALL, self._seqid)
    args = SoftReset_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SoftReset(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SoftReset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def BeginControllerCommand(self, _homeId, _command, _highPower, _nodeId):
    """
    * \brief Start a controller command process.
    * \param _homeId The Home ID of the Z-Wave controller.
    * \param _command The command to be sent to the controller.
    * \param _callback pointer to a function that will be called at various stages during the command process
    * \param _context pointer to user defined data that will be passed into to the callback function.  Defaults to NULL.
    * \param _highPower used only with the AddDevice, AddController, RemoveDevice and RemoveController commands.
    * Usually when adding or removing devices, the controller operates at low power so that the controller must
    * be physically close to the device for security reasons.  If _highPower is true, the controller will
    * operate at normal power levels instead.  Defaults to false.
    * \param _nodeId used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.
    * \return true if the command was accepted and has started.
    * \see CancelControllerCommand, HasNodeFailed, RemoveFailedNode, Driver::ControllerCommand, Driver::pfnControllerCallback_t,
    * to notify the user of progress or to request actions on the user's part.  Defaults to NULL.
    * <p> Commands
    * - Driver::ControllerCommand_AddController - Add a new secondary controller to the Z-Wave network.
    * - Driver::ControllerCommand_AddDevice - Add a new device (but not a controller) to the Z-Wave network.
    * - Driver::ControllerCommand_CreateNewPrimary (Not yet implemented)
    * - Driver::ControllerCommand_ReceiveConfiguration -
    * - Driver::ControllerCommand_RemoveController - remove a controller from the Z-Wave network.
    * - Driver::ControllerCommand_RemoveDevice - remove a device (but not a controller) from the Z-Wave network.
     * - Driver::ControllerCommand_RemoveFailedNode - move a node to the controller's list of failed nodes.  The node must actually
    * have failed or have been disabled since the command will fail if it responds.  A node must be in the controller's failed nodes list
    * for ControllerCommand_ReplaceFailedNode to work.
    * - Driver::ControllerCommand_HasNodeFailed - Check whether a node is in the controller's failed nodes list.
    * - Driver::ControllerCommand_ReplaceFailedNode - replace a failed device with another. If the node is not in
    * the controller's failed nodes list, or the node responds, this command will fail.
    * - Driver:: ControllerCommand_TransferPrimaryRole	(Not yet implemented) - Add a new controller to the network and
    * make it the primary.  The existing primary will become a secondary controller.
    * - Driver::ControllerCommand_RequestNetworkUpdate - Update the controller with network information from the SUC/SIS.
    * - Driver::ControllerCommand_RequestNodeNeighborUpdate - Get a node to rebuild its neighbour list.  This method also does ControllerCommand_RequestNodeNeighbors afterwards.
    * - Driver::ControllerCommand_AssignReturnRoute - Assign a network return route to a device.
    * - Driver::ControllerCommand_DeleteAllReturnRoutes - Delete all network return routes from a device.
    * <p> Callbacks
    * - Driver::ControllerState_Waiting, the controller is waiting for a user action.  A notice should be displayed
    * to the user at this point, telling them what to do next.
    * For the add, remove, replace and transfer primary role commands, the user needs to be told to press the
    * inclusion button on the device that  is going to be added or removed.  For ControllerCommand_ReceiveConfiguration,
    * they must set their other controller to send its data, and for ControllerCommand_CreateNewPrimary, set the other
    * controller to learn new data.
    * - Driver::ControllerState_InProgress - the controller is in the process of adding or removing the chosen node.  It is now too late to cancel the command.
    * - Driver::ControllerState_Complete - the controller has finished adding or removing the node, and the command is complete.
    * - Driver::ControllerState_Failed - will be sent if the command fails for any reason.

    Parameters:
     - _homeId
     - _command
     - _highPower
     - _nodeId
    """
    self.send_BeginControllerCommand(_homeId, _command, _highPower, _nodeId)
    return self.recv_BeginControllerCommand()

  def send_BeginControllerCommand(self, _homeId, _command, _highPower, _nodeId):
    self._oprot.writeMessageBegin('BeginControllerCommand', TMessageType.CALL, self._seqid)
    args = BeginControllerCommand_args()
    args._homeId = _homeId
    args._command = _command
    args._highPower = _highPower
    args._nodeId = _nodeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_BeginControllerCommand(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = BeginControllerCommand_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "BeginControllerCommand failed: unknown result");

  def CancelControllerCommand(self, _homeId):
    """
    \brief Cancels any in-progress command running on a controller.
    \param _homeId The Home ID of the Z-Wave controller.
    \return true if a command was running and was cancelled.
    \see BeginControllerCommand

    Parameters:
     - _homeId
    """
    self.send_CancelControllerCommand(_homeId)
    return self.recv_CancelControllerCommand()

  def send_CancelControllerCommand(self, _homeId):
    self._oprot.writeMessageBegin('CancelControllerCommand', TMessageType.CALL, self._seqid)
    args = CancelControllerCommand_args()
    args._homeId = _homeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CancelControllerCommand(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = CancelControllerCommand_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CancelControllerCommand failed: unknown result");

  def GetNumScenes(self, ):
    """
    \brief Gets the number of scenes that have been defined.
    \return The number of scenes.
    \see GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
    """
    self.send_GetNumScenes()
    return self.recv_GetNumScenes()

  def send_GetNumScenes(self, ):
    self._oprot.writeMessageBegin('GetNumScenes', TMessageType.CALL, self._seqid)
    args = GetNumScenes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetNumScenes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetNumScenes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumScenes failed: unknown result");

  def GetAllScenes(self, ):
    """
    \brief Gets a list of all the SceneIds.
    \param _sceneIds is a pointer to an array of integers.
    \return The number of scenes. If zero, _sceneIds will be NULL and doesn't need to be freed.
    \see GetNumScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene
    """
    self.send_GetAllScenes()
    return self.recv_GetAllScenes()

  def send_GetAllScenes(self, ):
    self._oprot.writeMessageBegin('GetAllScenes', TMessageType.CALL, self._seqid)
    args = GetAllScenes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAllScenes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetAllScenes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAllScenes failed: unknown result");

  def CreateScene(self, ):
    """
    \brief Create a new Scene passing in Scene ID
    \return uint8 Scene ID used to reference the scene. 0 is failure result.
    \see GetNumScenes, GetAllScenes, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    """
    self.send_CreateScene()
    return self.recv_CreateScene()

  def send_CreateScene(self, ):
    self._oprot.writeMessageBegin('CreateScene', TMessageType.CALL, self._seqid)
    args = CreateScene_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CreateScene(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = CreateScene_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateScene failed: unknown result");

  def RemoveScene(self, _sceneId):
    """
    \brief Remove an existing Scene.
    \param _sceneId is an integer representing the unique Scene ID to be removed.
    \return true if scene was removed.
    \see GetNumScenes, GetAllScenes, CreateScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
    """
    self.send_RemoveScene(_sceneId)
    return self.recv_RemoveScene()

  def send_RemoveScene(self, _sceneId):
    self._oprot.writeMessageBegin('RemoveScene', TMessageType.CALL, self._seqid)
    args = RemoveScene_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveScene(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveScene_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveScene failed: unknown result");

  def AddSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    \brief Add a bool Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the bool value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Bool(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Bool()

  def send_AddSceneValue_Bool(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Bool', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Bool_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Bool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Bool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Bool failed: unknown result");

  def AddSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    \brief Add a byte Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the byte value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Uint8(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Uint8()

  def send_AddSceneValue_Uint8(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Uint8', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Uint8_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Uint8(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Uint8_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Uint8 failed: unknown result");

  def AddSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    \brief Add a decimal Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the float value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Float(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Float()

  def send_AddSceneValue_Float(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Float', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Float_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Float(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Float_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Float failed: unknown result");

  def AddSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Add a 32-bit signed integer Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int32 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Int32(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Int32()

  def send_AddSceneValue_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Int32', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Int32 failed: unknown result");

  def AddSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    \brief Add a 16-bit signed integer Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int16 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_Int16(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_Int16()

  def send_AddSceneValue_Int16(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_Int16', TMessageType.CALL, self._seqid)
    args = AddSceneValue_Int16_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_Int16(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_Int16_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_Int16 failed: unknown result");

  def AddSceneValue_String(self, _sceneId, _valueId, _value):
    """
    \brief Add a string Value ID to an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValue_String(_sceneId, _valueId, _value)
    return self.recv_AddSceneValue_String()

  def send_AddSceneValue_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValue_String', TMessageType.CALL, self._seqid)
    args = AddSceneValue_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValue_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValue_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValue_String failed: unknown result");

  def AddSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    \brief Add the selected item list Value ID to an existing scene (as a string).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValueListSelection_String(_sceneId, _valueId, _value)
    return self.recv_AddSceneValueListSelection_String()

  def send_AddSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValueListSelection_String', TMessageType.CALL, self._seqid)
    args = AddSceneValueListSelection_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValueListSelection_String failed: unknown result");

  def AddSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Add the selected item list Value ID to an existing scene (as a integer).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the integer value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_AddSceneValueListSelection_Int32(_sceneId, _valueId, _value)
    return self.recv_AddSceneValueListSelection_Int32()

  def send_AddSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('AddSceneValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = AddSceneValueListSelection_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddSceneValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddSceneValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AddSceneValueListSelection_Int32 failed: unknown result");

  def RemoveSceneValue(self, _sceneId, _valueId):
    """
    \brief Remove the Value ID from an existing scene.
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be removed.
    \return true if Value ID was removed.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_RemoveSceneValue(_sceneId, _valueId)
    return self.recv_RemoveSceneValue()

  def send_RemoveSceneValue(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('RemoveSceneValue', TMessageType.CALL, self._seqid)
    args = RemoveSceneValue_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveSceneValue(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveSceneValue_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveSceneValue failed: unknown result");

  def SceneGetValues(self, _sceneId):
    """
    \brief Retrieves the scene's list of values.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param o_value Pointer to an array of ValueIDs if return is non-zero.
    \return The number of nodes in the o_value array. If zero, the array will point to NULL and does not need to be deleted.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
    """
    self.send_SceneGetValues(_sceneId)
    return self.recv_SceneGetValues()

  def send_SceneGetValues(self, _sceneId):
    self._oprot.writeMessageBegin('SceneGetValues', TMessageType.CALL, self._seqid)
    args = SceneGetValues_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValues(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValues_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValues failed: unknown result");

  def SceneGetValueAsBool(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a bool.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a bool that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsBool(_sceneId, _valueId)
    return self.recv_SceneGetValueAsBool()

  def send_SceneGetValueAsBool(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsBool', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsBool_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsBool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsBool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsBool failed: unknown result");

  def SceneGetValueAsByte(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as an 8-bit unsigned integer.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a uint8 that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsByte(_sceneId, _valueId)
    return self.recv_SceneGetValueAsByte()

  def send_SceneGetValueAsByte(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsByte', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsByte_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsByte(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsByte_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsByte failed: unknown result");

  def SceneGetValueAsFloat(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a float.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a float that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsFloat(_sceneId, _valueId)
    return self.recv_SceneGetValueAsFloat()

  def send_SceneGetValueAsFloat(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsFloat', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsFloat_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsFloat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsFloat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsFloat failed: unknown result");

  def SceneGetValueAsInt(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a 32-bit signed integer.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a int32 that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsInt(_sceneId, _valueId)
    return self.recv_SceneGetValueAsInt()

  def send_SceneGetValueAsInt(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsInt', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsInt_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsInt(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsInt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsInt failed: unknown result");

  def SceneGetValueAsShort(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a 16-bit signed integer.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a int16 that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsShort(_sceneId, _valueId)
    return self.recv_SceneGetValueAsShort()

  def send_SceneGetValueAsShort(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsShort', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsShort_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsShort(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsShort_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsShort failed: unknown result");

  def SceneGetValueAsString(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a string.
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a string that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueAsString(_sceneId, _valueId)
    return self.recv_SceneGetValueAsString()

  def send_SceneGetValueAsString(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueAsString', TMessageType.CALL, self._seqid)
    args = SceneGetValueAsString_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueAsString(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueAsString_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueAsString failed: unknown result");

  def SceneGetValueListSelection_String(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a list (as a string).
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a string that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueListSelection_String(_sceneId, _valueId)
    return self.recv_SceneGetValueListSelection_String()

  def send_SceneGetValueListSelection_String(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueListSelection_String', TMessageType.CALL, self._seqid)
    args = SceneGetValueListSelection_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueListSelection_String failed: unknown result");

  def SceneGetValueListSelection_Int32(self, _sceneId, _valueId):
    """
    \brief Retrieves a scene's value as a list (as a integer).
    \param _sceneId The Scene ID of the scene to retrieve the value from.
    \param _valueId The Value ID of the value to retrieve.
    \param o_value Pointer to a integer that will be filled with the returned value.
    \return true if the value was obtained.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
    """
    self.send_SceneGetValueListSelection_Int32(_sceneId, _valueId)
    return self.recv_SceneGetValueListSelection_Int32()

  def send_SceneGetValueListSelection_Int32(self, _sceneId, _valueId):
    self._oprot.writeMessageBegin('SceneGetValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = SceneGetValueListSelection_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneGetValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneGetValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneGetValueListSelection_Int32 failed: unknown result");

  def SetSceneValue_Bool(self, _sceneId, _valueId, _value):
    """
    \brief Set a bool Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the bool value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Bool(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Bool()

  def send_SetSceneValue_Bool(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Bool', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Bool_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Bool(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Bool_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Bool failed: unknown result");

  def SetSceneValue_Uint8(self, _sceneId, _valueId, _value):
    """
    \brief Set a byte Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the byte value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Uint8(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Uint8()

  def send_SetSceneValue_Uint8(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Uint8', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Uint8_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Uint8(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Uint8_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Uint8 failed: unknown result");

  def SetSceneValue_Float(self, _sceneId, _valueId, _value):
    """
    \brief Set a decimal Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the float value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Float(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Float()

  def send_SetSceneValue_Float(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Float', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Float_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Float(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Float_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Float failed: unknown result");

  def SetSceneValue_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Set a 32-bit signed integer Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int32 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Int32(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Int32()

  def send_SetSceneValue_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Int32', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Int32 failed: unknown result");

  def SetSceneValue_Int16(self, _sceneId, _valueId, _value):
    """
    \brief Set a 16-bit integer Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the int16 value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_Int16(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_Int16()

  def send_SetSceneValue_Int16(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_Int16', TMessageType.CALL, self._seqid)
    args = SetSceneValue_Int16_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_Int16(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_Int16_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_Int16 failed: unknown result");

  def SetSceneValue_String(self, _sceneId, _valueId, _value):
    """
    \brief Set a string Value ID to an existing scene's ValueID
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValue_String(_sceneId, _valueId, _value)
    return self.recv_SetSceneValue_String()

  def send_SetSceneValue_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValue_String', TMessageType.CALL, self._seqid)
    args = SetSceneValue_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValue_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValue_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValue_String failed: unknown result");

  def SetSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    """
    \brief Set the list selected item Value ID to an existing scene's ValueID (as a string).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the string value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValueListSelection_String(_sceneId, _valueId, _value)
    return self.recv_SetSceneValueListSelection_String()

  def send_SetSceneValueListSelection_String(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValueListSelection_String', TMessageType.CALL, self._seqid)
    args = SetSceneValueListSelection_String_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValueListSelection_String(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValueListSelection_String_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValueListSelection_String failed: unknown result");

  def SetSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    """
    \brief Set the list selected item Value ID to an existing scene's ValueID (as a integer).
    \param _sceneId is an integer representing the unique Scene ID.
    \param _valueId is the Value ID to be added.
    \param _value is the integer value to be saved.
    \return true if Value ID was added.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _valueId
     - _value
    """
    self.send_SetSceneValueListSelection_Int32(_sceneId, _valueId, _value)
    return self.recv_SetSceneValueListSelection_Int32()

  def send_SetSceneValueListSelection_Int32(self, _sceneId, _valueId, _value):
    self._oprot.writeMessageBegin('SetSceneValueListSelection_Int32', TMessageType.CALL, self._seqid)
    args = SetSceneValueListSelection_Int32_args()
    args._sceneId = _sceneId
    args._valueId = _valueId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneValueListSelection_Int32(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneValueListSelection_Int32_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSceneValueListSelection_Int32 failed: unknown result");

  def GetSceneLabel(self, _sceneId):
    """
    \brief Returns a label for the particular scene.
    \param _sceneId The Scene ID
    \return The label string.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, SetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
    """
    self.send_GetSceneLabel(_sceneId)
    return self.recv_GetSceneLabel()

  def send_GetSceneLabel(self, _sceneId):
    self._oprot.writeMessageBegin('GetSceneLabel', TMessageType.CALL, self._seqid)
    args = GetSceneLabel_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSceneLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetSceneLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSceneLabel failed: unknown result");

  def SetSceneLabel(self, _sceneId, _value):
    """
    \brief Sets a label for the particular scene.
    \param _sceneId The Scene ID
    \param _value The new value of the label.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SceneExists, ActivateScene

    Parameters:
     - _sceneId
     - _value
    """
    self.send_SetSceneLabel(_sceneId, _value)
    self.recv_SetSceneLabel()

  def send_SetSceneLabel(self, _sceneId, _value):
    self._oprot.writeMessageBegin('SetSceneLabel', TMessageType.CALL, self._seqid)
    args = SetSceneLabel_args()
    args._sceneId = _sceneId
    args._value = _value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSceneLabel(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetSceneLabel_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def SceneExists(self, _sceneId):
    """
    \brief Check if a Scene ID is defined.
    \param _sceneId The Scene ID.
    \return true if Scene ID exists.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, ActivateScene

    Parameters:
     - _sceneId
    """
    self.send_SceneExists(_sceneId)
    return self.recv_SceneExists()

  def send_SceneExists(self, _sceneId):
    self._oprot.writeMessageBegin('SceneExists', TMessageType.CALL, self._seqid)
    args = SceneExists_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SceneExists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SceneExists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "SceneExists failed: unknown result");

  def ActivateScene(self, _sceneId):
    """
    \brief Activate given scene to perform all its actions.
    \param _sceneId The Scene ID.
    \return true if it is successful.
    \see GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists

    Parameters:
     - _sceneId
    """
    self.send_ActivateScene(_sceneId)
    return self.recv_ActivateScene()

  def send_ActivateScene(self, _sceneId):
    self._oprot.writeMessageBegin('ActivateScene', TMessageType.CALL, self._seqid)
    args = ActivateScene_args()
    args._sceneId = _sceneId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ActivateScene(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ActivateScene_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ActivateScene failed: unknown result");

  def SendAllValues(self, ):
    self.send_SendAllValues()
    self.recv_SendAllValues()

  def send_SendAllValues(self, ):
    self._oprot.writeMessageBegin('SendAllValues', TMessageType.CALL, self._seqid)
    args = SendAllValues_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SendAllValues(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SendAllValues_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["WriteConfig"] = Processor.process_WriteConfig
    self._processMap["GetControllerNodeId"] = Processor.process_GetControllerNodeId
    self._processMap["IsPrimaryController"] = Processor.process_IsPrimaryController
    self._processMap["IsStaticUpdateController"] = Processor.process_IsStaticUpdateController
    self._processMap["IsBridgeController"] = Processor.process_IsBridgeController
    self._processMap["GetLibraryVersion"] = Processor.process_GetLibraryVersion
    self._processMap["GetLibraryTypeName"] = Processor.process_GetLibraryTypeName
    self._processMap["GetSendQueueCount"] = Processor.process_GetSendQueueCount
    self._processMap["GetPollInterval"] = Processor.process_GetPollInterval
    self._processMap["SetPollInterval"] = Processor.process_SetPollInterval
    self._processMap["EnablePoll"] = Processor.process_EnablePoll
    self._processMap["DisablePoll"] = Processor.process_DisablePoll
    self._processMap["isPolled"] = Processor.process_isPolled
    self._processMap["RefreshNodeInfo"] = Processor.process_RefreshNodeInfo
    self._processMap["RequestNodeState"] = Processor.process_RequestNodeState
    self._processMap["RequestNodeDynamic"] = Processor.process_RequestNodeDynamic
    self._processMap["IsNodeListeningDevice"] = Processor.process_IsNodeListeningDevice
    self._processMap["IsNodeRoutingDevice"] = Processor.process_IsNodeRoutingDevice
    self._processMap["GetNodeMaxBaudRate"] = Processor.process_GetNodeMaxBaudRate
    self._processMap["GetNodeVersion"] = Processor.process_GetNodeVersion
    self._processMap["GetNodeSecurity"] = Processor.process_GetNodeSecurity
    self._processMap["GetNodeBasic"] = Processor.process_GetNodeBasic
    self._processMap["GetNodeGeneric"] = Processor.process_GetNodeGeneric
    self._processMap["GetNodeSpecific"] = Processor.process_GetNodeSpecific
    self._processMap["GetNodeType"] = Processor.process_GetNodeType
    self._processMap["GetNodeNeighbors"] = Processor.process_GetNodeNeighbors
    self._processMap["GetNodeManufacturerName"] = Processor.process_GetNodeManufacturerName
    self._processMap["GetNodeProductName"] = Processor.process_GetNodeProductName
    self._processMap["GetNodeName"] = Processor.process_GetNodeName
    self._processMap["GetNodeLocation"] = Processor.process_GetNodeLocation
    self._processMap["GetNodeManufacturerId"] = Processor.process_GetNodeManufacturerId
    self._processMap["GetNodeProductType"] = Processor.process_GetNodeProductType
    self._processMap["GetNodeProductId"] = Processor.process_GetNodeProductId
    self._processMap["SetNodeManufacturerName"] = Processor.process_SetNodeManufacturerName
    self._processMap["SetNodeProductName"] = Processor.process_SetNodeProductName
    self._processMap["SetNodeName"] = Processor.process_SetNodeName
    self._processMap["SetNodeLocation"] = Processor.process_SetNodeLocation
    self._processMap["SetNodeOn"] = Processor.process_SetNodeOn
    self._processMap["SetNodeOff"] = Processor.process_SetNodeOff
    self._processMap["SetNodeLevel"] = Processor.process_SetNodeLevel
    self._processMap["IsNodeInfoReceived"] = Processor.process_IsNodeInfoReceived
    self._processMap["GetNodeClassInformation"] = Processor.process_GetNodeClassInformation
    self._processMap["GetValueLabel"] = Processor.process_GetValueLabel
    self._processMap["SetValueLabel"] = Processor.process_SetValueLabel
    self._processMap["GetValueUnits"] = Processor.process_GetValueUnits
    self._processMap["SetValueUnits"] = Processor.process_SetValueUnits
    self._processMap["GetValueHelp"] = Processor.process_GetValueHelp
    self._processMap["SetValueHelp"] = Processor.process_SetValueHelp
    self._processMap["GetValueMin"] = Processor.process_GetValueMin
    self._processMap["GetValueMax"] = Processor.process_GetValueMax
    self._processMap["IsValueReadOnly"] = Processor.process_IsValueReadOnly
    self._processMap["IsValueWriteOnly"] = Processor.process_IsValueWriteOnly
    self._processMap["IsValueSet"] = Processor.process_IsValueSet
    self._processMap["GetValueAsBool"] = Processor.process_GetValueAsBool
    self._processMap["GetValueAsByte"] = Processor.process_GetValueAsByte
    self._processMap["GetValueAsFloat"] = Processor.process_GetValueAsFloat
    self._processMap["GetValueAsInt"] = Processor.process_GetValueAsInt
    self._processMap["GetValueAsShort"] = Processor.process_GetValueAsShort
    self._processMap["GetValueAsString"] = Processor.process_GetValueAsString
    self._processMap["GetValueListSelection_String"] = Processor.process_GetValueListSelection_String
    self._processMap["GetValueListSelection_Int32"] = Processor.process_GetValueListSelection_Int32
    self._processMap["GetValueListItems"] = Processor.process_GetValueListItems
    self._processMap["GetValueFloatPrecision"] = Processor.process_GetValueFloatPrecision
    self._processMap["SetValue_Bool"] = Processor.process_SetValue_Bool
    self._processMap["SetValue_UInt8"] = Processor.process_SetValue_UInt8
    self._processMap["SetValue_Float"] = Processor.process_SetValue_Float
    self._processMap["SetValue_Int32"] = Processor.process_SetValue_Int32
    self._processMap["SetValue_Int16"] = Processor.process_SetValue_Int16
    self._processMap["SetValue_String"] = Processor.process_SetValue_String
    self._processMap["SetValueListSelection"] = Processor.process_SetValueListSelection
    self._processMap["PressButton"] = Processor.process_PressButton
    self._processMap["ReleaseButton"] = Processor.process_ReleaseButton
    self._processMap["GetNumSwitchPoints"] = Processor.process_GetNumSwitchPoints
    self._processMap["SetSwitchPoint"] = Processor.process_SetSwitchPoint
    self._processMap["RemoveSwitchPoint"] = Processor.process_RemoveSwitchPoint
    self._processMap["ClearSwitchPoints"] = Processor.process_ClearSwitchPoints
    self._processMap["GetSwitchPoint"] = Processor.process_GetSwitchPoint
    self._processMap["SwitchAllOn"] = Processor.process_SwitchAllOn
    self._processMap["SwitchAllOff"] = Processor.process_SwitchAllOff
    self._processMap["SetConfigParam"] = Processor.process_SetConfigParam
    self._processMap["RequestConfigParam"] = Processor.process_RequestConfigParam
    self._processMap["RequestAllConfigParams"] = Processor.process_RequestAllConfigParams
    self._processMap["GetNumGroups"] = Processor.process_GetNumGroups
    self._processMap["GetAssociations"] = Processor.process_GetAssociations
    self._processMap["GetMaxAssociations"] = Processor.process_GetMaxAssociations
    self._processMap["GetGroupLabel"] = Processor.process_GetGroupLabel
    self._processMap["AddAssociation"] = Processor.process_AddAssociation
    self._processMap["RemoveAssociation"] = Processor.process_RemoveAssociation
    self._processMap["ResetController"] = Processor.process_ResetController
    self._processMap["SoftReset"] = Processor.process_SoftReset
    self._processMap["BeginControllerCommand"] = Processor.process_BeginControllerCommand
    self._processMap["CancelControllerCommand"] = Processor.process_CancelControllerCommand
    self._processMap["GetNumScenes"] = Processor.process_GetNumScenes
    self._processMap["GetAllScenes"] = Processor.process_GetAllScenes
    self._processMap["CreateScene"] = Processor.process_CreateScene
    self._processMap["RemoveScene"] = Processor.process_RemoveScene
    self._processMap["AddSceneValue_Bool"] = Processor.process_AddSceneValue_Bool
    self._processMap["AddSceneValue_Uint8"] = Processor.process_AddSceneValue_Uint8
    self._processMap["AddSceneValue_Float"] = Processor.process_AddSceneValue_Float
    self._processMap["AddSceneValue_Int32"] = Processor.process_AddSceneValue_Int32
    self._processMap["AddSceneValue_Int16"] = Processor.process_AddSceneValue_Int16
    self._processMap["AddSceneValue_String"] = Processor.process_AddSceneValue_String
    self._processMap["AddSceneValueListSelection_String"] = Processor.process_AddSceneValueListSelection_String
    self._processMap["AddSceneValueListSelection_Int32"] = Processor.process_AddSceneValueListSelection_Int32
    self._processMap["RemoveSceneValue"] = Processor.process_RemoveSceneValue
    self._processMap["SceneGetValues"] = Processor.process_SceneGetValues
    self._processMap["SceneGetValueAsBool"] = Processor.process_SceneGetValueAsBool
    self._processMap["SceneGetValueAsByte"] = Processor.process_SceneGetValueAsByte
    self._processMap["SceneGetValueAsFloat"] = Processor.process_SceneGetValueAsFloat
    self._processMap["SceneGetValueAsInt"] = Processor.process_SceneGetValueAsInt
    self._processMap["SceneGetValueAsShort"] = Processor.process_SceneGetValueAsShort
    self._processMap["SceneGetValueAsString"] = Processor.process_SceneGetValueAsString
    self._processMap["SceneGetValueListSelection_String"] = Processor.process_SceneGetValueListSelection_String
    self._processMap["SceneGetValueListSelection_Int32"] = Processor.process_SceneGetValueListSelection_Int32
    self._processMap["SetSceneValue_Bool"] = Processor.process_SetSceneValue_Bool
    self._processMap["SetSceneValue_Uint8"] = Processor.process_SetSceneValue_Uint8
    self._processMap["SetSceneValue_Float"] = Processor.process_SetSceneValue_Float
    self._processMap["SetSceneValue_Int32"] = Processor.process_SetSceneValue_Int32
    self._processMap["SetSceneValue_Int16"] = Processor.process_SetSceneValue_Int16
    self._processMap["SetSceneValue_String"] = Processor.process_SetSceneValue_String
    self._processMap["SetSceneValueListSelection_String"] = Processor.process_SetSceneValueListSelection_String
    self._processMap["SetSceneValueListSelection_Int32"] = Processor.process_SetSceneValueListSelection_Int32
    self._processMap["GetSceneLabel"] = Processor.process_GetSceneLabel
    self._processMap["SetSceneLabel"] = Processor.process_SetSceneLabel
    self._processMap["SceneExists"] = Processor.process_SceneExists
    self._processMap["ActivateScene"] = Processor.process_ActivateScene
    self._processMap["SendAllValues"] = Processor.process_SendAllValues

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_WriteConfig(self, seqid, iprot, oprot):
    args = WriteConfig_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = WriteConfig_result()
    self._handler.WriteConfig(args._homeId)
    oprot.writeMessageBegin("WriteConfig", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetControllerNodeId(self, seqid, iprot, oprot):
    args = GetControllerNodeId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetControllerNodeId_result()
    result.success = self._handler.GetControllerNodeId(args._homeId)
    oprot.writeMessageBegin("GetControllerNodeId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsPrimaryController(self, seqid, iprot, oprot):
    args = IsPrimaryController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsPrimaryController_result()
    result.success = self._handler.IsPrimaryController(args._homeId)
    oprot.writeMessageBegin("IsPrimaryController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsStaticUpdateController(self, seqid, iprot, oprot):
    args = IsStaticUpdateController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsStaticUpdateController_result()
    result.success = self._handler.IsStaticUpdateController(args._homeId)
    oprot.writeMessageBegin("IsStaticUpdateController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsBridgeController(self, seqid, iprot, oprot):
    args = IsBridgeController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsBridgeController_result()
    result.success = self._handler.IsBridgeController(args._homeId)
    oprot.writeMessageBegin("IsBridgeController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLibraryVersion(self, seqid, iprot, oprot):
    args = GetLibraryVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLibraryVersion_result()
    result.success = self._handler.GetLibraryVersion(args._homeId)
    oprot.writeMessageBegin("GetLibraryVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLibraryTypeName(self, seqid, iprot, oprot):
    args = GetLibraryTypeName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLibraryTypeName_result()
    result.success = self._handler.GetLibraryTypeName(args._homeId)
    oprot.writeMessageBegin("GetLibraryTypeName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSendQueueCount(self, seqid, iprot, oprot):
    args = GetSendQueueCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSendQueueCount_result()
    result.success = self._handler.GetSendQueueCount(args._homeId)
    oprot.writeMessageBegin("GetSendQueueCount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetPollInterval(self, seqid, iprot, oprot):
    args = GetPollInterval_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetPollInterval_result()
    result.success = self._handler.GetPollInterval()
    oprot.writeMessageBegin("GetPollInterval", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetPollInterval(self, seqid, iprot, oprot):
    args = SetPollInterval_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetPollInterval_result()
    self._handler.SetPollInterval(args._seconds)
    oprot.writeMessageBegin("SetPollInterval", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_EnablePoll(self, seqid, iprot, oprot):
    args = EnablePoll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = EnablePoll_result()
    result.success = self._handler.EnablePoll(args._valueId)
    oprot.writeMessageBegin("EnablePoll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DisablePoll(self, seqid, iprot, oprot):
    args = DisablePoll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DisablePoll_result()
    result.success = self._handler.DisablePoll(args._valueId)
    oprot.writeMessageBegin("DisablePoll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPolled(self, seqid, iprot, oprot):
    args = isPolled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPolled_result()
    result.success = self._handler.isPolled(args._valueId)
    oprot.writeMessageBegin("isPolled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RefreshNodeInfo(self, seqid, iprot, oprot):
    args = RefreshNodeInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RefreshNodeInfo_result()
    result.success = self._handler.RefreshNodeInfo(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RefreshNodeInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestNodeState(self, seqid, iprot, oprot):
    args = RequestNodeState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestNodeState_result()
    result.success = self._handler.RequestNodeState(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RequestNodeState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestNodeDynamic(self, seqid, iprot, oprot):
    args = RequestNodeDynamic_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestNodeDynamic_result()
    result.success = self._handler.RequestNodeDynamic(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RequestNodeDynamic", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeListeningDevice(self, seqid, iprot, oprot):
    args = IsNodeListeningDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeListeningDevice_result()
    result.success = self._handler.IsNodeListeningDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeListeningDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeRoutingDevice(self, seqid, iprot, oprot):
    args = IsNodeRoutingDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeRoutingDevice_result()
    result.success = self._handler.IsNodeRoutingDevice(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeRoutingDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeMaxBaudRate(self, seqid, iprot, oprot):
    args = GetNodeMaxBaudRate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeMaxBaudRate_result()
    result.success = self._handler.GetNodeMaxBaudRate(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeMaxBaudRate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeVersion(self, seqid, iprot, oprot):
    args = GetNodeVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeVersion_result()
    result.success = self._handler.GetNodeVersion(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeSecurity(self, seqid, iprot, oprot):
    args = GetNodeSecurity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeSecurity_result()
    result.success = self._handler.GetNodeSecurity(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeSecurity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeBasic(self, seqid, iprot, oprot):
    args = GetNodeBasic_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeBasic_result()
    result.success = self._handler.GetNodeBasic(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeBasic", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeGeneric(self, seqid, iprot, oprot):
    args = GetNodeGeneric_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeGeneric_result()
    result.success = self._handler.GetNodeGeneric(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeGeneric", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeSpecific(self, seqid, iprot, oprot):
    args = GetNodeSpecific_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeSpecific_result()
    result.success = self._handler.GetNodeSpecific(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeSpecific", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeType(self, seqid, iprot, oprot):
    args = GetNodeType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeType_result()
    result.success = self._handler.GetNodeType(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeType", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeNeighbors(self, seqid, iprot, oprot):
    args = GetNodeNeighbors_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeNeighbors_result()
    result.success = self._handler.GetNodeNeighbors(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeNeighbors", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeManufacturerName(self, seqid, iprot, oprot):
    args = GetNodeManufacturerName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeManufacturerName_result()
    result.success = self._handler.GetNodeManufacturerName(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeManufacturerName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeProductName(self, seqid, iprot, oprot):
    args = GetNodeProductName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeProductName_result()
    result.success = self._handler.GetNodeProductName(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeProductName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeName(self, seqid, iprot, oprot):
    args = GetNodeName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeName_result()
    result.success = self._handler.GetNodeName(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeLocation(self, seqid, iprot, oprot):
    args = GetNodeLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeLocation_result()
    result.success = self._handler.GetNodeLocation(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeManufacturerId(self, seqid, iprot, oprot):
    args = GetNodeManufacturerId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeManufacturerId_result()
    result.success = self._handler.GetNodeManufacturerId(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeManufacturerId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeProductType(self, seqid, iprot, oprot):
    args = GetNodeProductType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeProductType_result()
    result.success = self._handler.GetNodeProductType(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeProductType", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeProductId(self, seqid, iprot, oprot):
    args = GetNodeProductId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeProductId_result()
    result.success = self._handler.GetNodeProductId(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNodeProductId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeManufacturerName(self, seqid, iprot, oprot):
    args = SetNodeManufacturerName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeManufacturerName_result()
    self._handler.SetNodeManufacturerName(args._homeId, args._nodeId, args._manufacturerName)
    oprot.writeMessageBegin("SetNodeManufacturerName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeProductName(self, seqid, iprot, oprot):
    args = SetNodeProductName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeProductName_result()
    self._handler.SetNodeProductName(args._homeId, args._nodeId, args._productName)
    oprot.writeMessageBegin("SetNodeProductName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeName(self, seqid, iprot, oprot):
    args = SetNodeName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeName_result()
    self._handler.SetNodeName(args._homeId, args._nodeId, args._nodeName)
    oprot.writeMessageBegin("SetNodeName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeLocation(self, seqid, iprot, oprot):
    args = SetNodeLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeLocation_result()
    self._handler.SetNodeLocation(args._homeId, args._nodeId, args._location)
    oprot.writeMessageBegin("SetNodeLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeOn(self, seqid, iprot, oprot):
    args = SetNodeOn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeOn_result()
    self._handler.SetNodeOn(args._homeId, args._nodeId)
    oprot.writeMessageBegin("SetNodeOn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeOff(self, seqid, iprot, oprot):
    args = SetNodeOff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeOff_result()
    self._handler.SetNodeOff(args._homeId, args._nodeId)
    oprot.writeMessageBegin("SetNodeOff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetNodeLevel(self, seqid, iprot, oprot):
    args = SetNodeLevel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetNodeLevel_result()
    self._handler.SetNodeLevel(args._homeId, args._nodeId, args._level)
    oprot.writeMessageBegin("SetNodeLevel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsNodeInfoReceived(self, seqid, iprot, oprot):
    args = IsNodeInfoReceived_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsNodeInfoReceived_result()
    result.success = self._handler.IsNodeInfoReceived(args._homeId, args._nodeId)
    oprot.writeMessageBegin("IsNodeInfoReceived", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNodeClassInformation(self, seqid, iprot, oprot):
    args = GetNodeClassInformation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNodeClassInformation_result()
    result.success = self._handler.GetNodeClassInformation(args._homeId, args._nodeId, args._commandClassId)
    oprot.writeMessageBegin("GetNodeClassInformation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueLabel(self, seqid, iprot, oprot):
    args = GetValueLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueLabel_result()
    result.success = self._handler.GetValueLabel(args._id)
    oprot.writeMessageBegin("GetValueLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueLabel(self, seqid, iprot, oprot):
    args = SetValueLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueLabel_result()
    self._handler.SetValueLabel(args._id, args._value)
    oprot.writeMessageBegin("SetValueLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueUnits(self, seqid, iprot, oprot):
    args = GetValueUnits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueUnits_result()
    result.success = self._handler.GetValueUnits(args._id)
    oprot.writeMessageBegin("GetValueUnits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueUnits(self, seqid, iprot, oprot):
    args = SetValueUnits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueUnits_result()
    self._handler.SetValueUnits(args._id, args._value)
    oprot.writeMessageBegin("SetValueUnits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueHelp(self, seqid, iprot, oprot):
    args = GetValueHelp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueHelp_result()
    result.success = self._handler.GetValueHelp(args._id)
    oprot.writeMessageBegin("GetValueHelp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueHelp(self, seqid, iprot, oprot):
    args = SetValueHelp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueHelp_result()
    self._handler.SetValueHelp(args._id, args._value)
    oprot.writeMessageBegin("SetValueHelp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueMin(self, seqid, iprot, oprot):
    args = GetValueMin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueMin_result()
    result.success = self._handler.GetValueMin(args._id)
    oprot.writeMessageBegin("GetValueMin", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueMax(self, seqid, iprot, oprot):
    args = GetValueMax_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueMax_result()
    result.success = self._handler.GetValueMax(args._id)
    oprot.writeMessageBegin("GetValueMax", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValueReadOnly(self, seqid, iprot, oprot):
    args = IsValueReadOnly_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValueReadOnly_result()
    result.success = self._handler.IsValueReadOnly(args._id)
    oprot.writeMessageBegin("IsValueReadOnly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValueWriteOnly(self, seqid, iprot, oprot):
    args = IsValueWriteOnly_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValueWriteOnly_result()
    result.success = self._handler.IsValueWriteOnly(args._id)
    oprot.writeMessageBegin("IsValueWriteOnly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsValueSet(self, seqid, iprot, oprot):
    args = IsValueSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsValueSet_result()
    result.success = self._handler.IsValueSet(args._id)
    oprot.writeMessageBegin("IsValueSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsBool(self, seqid, iprot, oprot):
    args = GetValueAsBool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsBool_result()
    result.success = self._handler.GetValueAsBool(args._id)
    oprot.writeMessageBegin("GetValueAsBool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsByte(self, seqid, iprot, oprot):
    args = GetValueAsByte_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsByte_result()
    result.success = self._handler.GetValueAsByte(args._id)
    oprot.writeMessageBegin("GetValueAsByte", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsFloat(self, seqid, iprot, oprot):
    args = GetValueAsFloat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsFloat_result()
    result.success = self._handler.GetValueAsFloat(args._id)
    oprot.writeMessageBegin("GetValueAsFloat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsInt(self, seqid, iprot, oprot):
    args = GetValueAsInt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsInt_result()
    result.success = self._handler.GetValueAsInt(args._id)
    oprot.writeMessageBegin("GetValueAsInt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsShort(self, seqid, iprot, oprot):
    args = GetValueAsShort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsShort_result()
    result.success = self._handler.GetValueAsShort(args._id)
    oprot.writeMessageBegin("GetValueAsShort", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueAsString(self, seqid, iprot, oprot):
    args = GetValueAsString_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueAsString_result()
    result.success = self._handler.GetValueAsString(args._id)
    oprot.writeMessageBegin("GetValueAsString", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueListSelection_String(self, seqid, iprot, oprot):
    args = GetValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueListSelection_String_result()
    result.success = self._handler.GetValueListSelection_String(args._id)
    oprot.writeMessageBegin("GetValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueListSelection_Int32(self, seqid, iprot, oprot):
    args = GetValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueListSelection_Int32_result()
    result.success = self._handler.GetValueListSelection_Int32(args._id)
    oprot.writeMessageBegin("GetValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueListItems(self, seqid, iprot, oprot):
    args = GetValueListItems_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueListItems_result()
    result.success = self._handler.GetValueListItems(args._id)
    oprot.writeMessageBegin("GetValueListItems", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetValueFloatPrecision(self, seqid, iprot, oprot):
    args = GetValueFloatPrecision_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetValueFloatPrecision_result()
    result.success = self._handler.GetValueFloatPrecision(args._id)
    oprot.writeMessageBegin("GetValueFloatPrecision", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Bool(self, seqid, iprot, oprot):
    args = SetValue_Bool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Bool_result()
    result.success = self._handler.SetValue_Bool(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Bool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_UInt8(self, seqid, iprot, oprot):
    args = SetValue_UInt8_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_UInt8_result()
    result.success = self._handler.SetValue_UInt8(args._id, args._value)
    oprot.writeMessageBegin("SetValue_UInt8", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Float(self, seqid, iprot, oprot):
    args = SetValue_Float_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Float_result()
    result.success = self._handler.SetValue_Float(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Float", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Int32(self, seqid, iprot, oprot):
    args = SetValue_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Int32_result()
    result.success = self._handler.SetValue_Int32(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_Int16(self, seqid, iprot, oprot):
    args = SetValue_Int16_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_Int16_result()
    result.success = self._handler.SetValue_Int16(args._id, args._value)
    oprot.writeMessageBegin("SetValue_Int16", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValue_String(self, seqid, iprot, oprot):
    args = SetValue_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValue_String_result()
    result.success = self._handler.SetValue_String(args._id, args._value)
    oprot.writeMessageBegin("SetValue_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetValueListSelection(self, seqid, iprot, oprot):
    args = SetValueListSelection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetValueListSelection_result()
    result.success = self._handler.SetValueListSelection(args._id, args._selectedItem)
    oprot.writeMessageBegin("SetValueListSelection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PressButton(self, seqid, iprot, oprot):
    args = PressButton_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PressButton_result()
    result.success = self._handler.PressButton(args._id)
    oprot.writeMessageBegin("PressButton", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ReleaseButton(self, seqid, iprot, oprot):
    args = ReleaseButton_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ReleaseButton_result()
    result.success = self._handler.ReleaseButton(args._id)
    oprot.writeMessageBegin("ReleaseButton", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNumSwitchPoints(self, seqid, iprot, oprot):
    args = GetNumSwitchPoints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNumSwitchPoints_result()
    result.success = self._handler.GetNumSwitchPoints(args._id)
    oprot.writeMessageBegin("GetNumSwitchPoints", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSwitchPoint(self, seqid, iprot, oprot):
    args = SetSwitchPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSwitchPoint_result()
    result.success = self._handler.SetSwitchPoint(args._id, args._hours, args._minutes, args._setback)
    oprot.writeMessageBegin("SetSwitchPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveSwitchPoint(self, seqid, iprot, oprot):
    args = RemoveSwitchPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveSwitchPoint_result()
    result.success = self._handler.RemoveSwitchPoint(args._id, args._hours, args._minutes)
    oprot.writeMessageBegin("RemoveSwitchPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ClearSwitchPoints(self, seqid, iprot, oprot):
    args = ClearSwitchPoints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ClearSwitchPoints_result()
    self._handler.ClearSwitchPoints(args._id)
    oprot.writeMessageBegin("ClearSwitchPoints", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSwitchPoint(self, seqid, iprot, oprot):
    args = GetSwitchPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSwitchPoint_result()
    result.success = self._handler.GetSwitchPoint(args._id, args._idx)
    oprot.writeMessageBegin("GetSwitchPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SwitchAllOn(self, seqid, iprot, oprot):
    args = SwitchAllOn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SwitchAllOn_result()
    self._handler.SwitchAllOn(args._homeId)
    oprot.writeMessageBegin("SwitchAllOn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SwitchAllOff(self, seqid, iprot, oprot):
    args = SwitchAllOff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SwitchAllOff_result()
    self._handler.SwitchAllOff(args._homeId)
    oprot.writeMessageBegin("SwitchAllOff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetConfigParam(self, seqid, iprot, oprot):
    args = SetConfigParam_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetConfigParam_result()
    result.success = self._handler.SetConfigParam(args._homeId, args._nodeId, args._param, args._value, args._size)
    oprot.writeMessageBegin("SetConfigParam", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestConfigParam(self, seqid, iprot, oprot):
    args = RequestConfigParam_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestConfigParam_result()
    self._handler.RequestConfigParam(args._homeId, args._nodeId, args._param)
    oprot.writeMessageBegin("RequestConfigParam", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RequestAllConfigParams(self, seqid, iprot, oprot):
    args = RequestAllConfigParams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RequestAllConfigParams_result()
    self._handler.RequestAllConfigParams(args._homeId, args._nodeId)
    oprot.writeMessageBegin("RequestAllConfigParams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNumGroups(self, seqid, iprot, oprot):
    args = GetNumGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNumGroups_result()
    result.success = self._handler.GetNumGroups(args._homeId, args._nodeId)
    oprot.writeMessageBegin("GetNumGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAssociations(self, seqid, iprot, oprot):
    args = GetAssociations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAssociations_result()
    result.success = self._handler.GetAssociations(args._homeId, args._nodeId, args._groupIdx)
    oprot.writeMessageBegin("GetAssociations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetMaxAssociations(self, seqid, iprot, oprot):
    args = GetMaxAssociations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetMaxAssociations_result()
    result.success = self._handler.GetMaxAssociations(args._homeId, args._nodeId, args._groupIdx)
    oprot.writeMessageBegin("GetMaxAssociations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetGroupLabel(self, seqid, iprot, oprot):
    args = GetGroupLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetGroupLabel_result()
    result.success = self._handler.GetGroupLabel(args._homeId, args._nodeId, args._groupIdx)
    oprot.writeMessageBegin("GetGroupLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddAssociation(self, seqid, iprot, oprot):
    args = AddAssociation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddAssociation_result()
    self._handler.AddAssociation(args._homeId, args._nodeId, args._groupIdx, args._targetNodeId)
    oprot.writeMessageBegin("AddAssociation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveAssociation(self, seqid, iprot, oprot):
    args = RemoveAssociation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveAssociation_result()
    self._handler.RemoveAssociation(args._homeId, args._nodeId, args._groupIdx, args._targetNodeId)
    oprot.writeMessageBegin("RemoveAssociation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ResetController(self, seqid, iprot, oprot):
    args = ResetController_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ResetController_result()
    self._handler.ResetController(args._homeId)
    oprot.writeMessageBegin("ResetController", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SoftReset(self, seqid, iprot, oprot):
    args = SoftReset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SoftReset_result()
    self._handler.SoftReset(args._homeId)
    oprot.writeMessageBegin("SoftReset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_BeginControllerCommand(self, seqid, iprot, oprot):
    args = BeginControllerCommand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = BeginControllerCommand_result()
    result.success = self._handler.BeginControllerCommand(args._homeId, args._command, args._highPower, args._nodeId)
    oprot.writeMessageBegin("BeginControllerCommand", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CancelControllerCommand(self, seqid, iprot, oprot):
    args = CancelControllerCommand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CancelControllerCommand_result()
    result.success = self._handler.CancelControllerCommand(args._homeId)
    oprot.writeMessageBegin("CancelControllerCommand", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetNumScenes(self, seqid, iprot, oprot):
    args = GetNumScenes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetNumScenes_result()
    result.success = self._handler.GetNumScenes()
    oprot.writeMessageBegin("GetNumScenes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAllScenes(self, seqid, iprot, oprot):
    args = GetAllScenes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAllScenes_result()
    result.success = self._handler.GetAllScenes()
    oprot.writeMessageBegin("GetAllScenes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CreateScene(self, seqid, iprot, oprot):
    args = CreateScene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateScene_result()
    result.success = self._handler.CreateScene()
    oprot.writeMessageBegin("CreateScene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveScene(self, seqid, iprot, oprot):
    args = RemoveScene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveScene_result()
    result.success = self._handler.RemoveScene(args._sceneId)
    oprot.writeMessageBegin("RemoveScene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Bool(self, seqid, iprot, oprot):
    args = AddSceneValue_Bool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Bool_result()
    result.success = self._handler.AddSceneValue_Bool(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Bool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Uint8(self, seqid, iprot, oprot):
    args = AddSceneValue_Uint8_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Uint8_result()
    result.success = self._handler.AddSceneValue_Uint8(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Uint8", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Float(self, seqid, iprot, oprot):
    args = AddSceneValue_Float_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Float_result()
    result.success = self._handler.AddSceneValue_Float(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Float", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Int32(self, seqid, iprot, oprot):
    args = AddSceneValue_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Int32_result()
    result.success = self._handler.AddSceneValue_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_Int16(self, seqid, iprot, oprot):
    args = AddSceneValue_Int16_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_Int16_result()
    result.success = self._handler.AddSceneValue_Int16(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_Int16", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValue_String(self, seqid, iprot, oprot):
    args = AddSceneValue_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValue_String_result()
    result.success = self._handler.AddSceneValue_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValue_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValueListSelection_String(self, seqid, iprot, oprot):
    args = AddSceneValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValueListSelection_String_result()
    result.success = self._handler.AddSceneValueListSelection_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddSceneValueListSelection_Int32(self, seqid, iprot, oprot):
    args = AddSceneValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddSceneValueListSelection_Int32_result()
    result.success = self._handler.AddSceneValueListSelection_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("AddSceneValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveSceneValue(self, seqid, iprot, oprot):
    args = RemoveSceneValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveSceneValue_result()
    result.success = self._handler.RemoveSceneValue(args._sceneId, args._valueId)
    oprot.writeMessageBegin("RemoveSceneValue", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValues(self, seqid, iprot, oprot):
    args = SceneGetValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValues_result()
    result.success = self._handler.SceneGetValues(args._sceneId)
    oprot.writeMessageBegin("SceneGetValues", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsBool(self, seqid, iprot, oprot):
    args = SceneGetValueAsBool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsBool_result()
    result.success = self._handler.SceneGetValueAsBool(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsBool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsByte(self, seqid, iprot, oprot):
    args = SceneGetValueAsByte_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsByte_result()
    result.success = self._handler.SceneGetValueAsByte(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsByte", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsFloat(self, seqid, iprot, oprot):
    args = SceneGetValueAsFloat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsFloat_result()
    result.success = self._handler.SceneGetValueAsFloat(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsFloat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsInt(self, seqid, iprot, oprot):
    args = SceneGetValueAsInt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsInt_result()
    result.success = self._handler.SceneGetValueAsInt(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsInt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsShort(self, seqid, iprot, oprot):
    args = SceneGetValueAsShort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsShort_result()
    result.success = self._handler.SceneGetValueAsShort(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsShort", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueAsString(self, seqid, iprot, oprot):
    args = SceneGetValueAsString_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueAsString_result()
    result.success = self._handler.SceneGetValueAsString(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueAsString", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueListSelection_String(self, seqid, iprot, oprot):
    args = SceneGetValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueListSelection_String_result()
    result.success = self._handler.SceneGetValueListSelection_String(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneGetValueListSelection_Int32(self, seqid, iprot, oprot):
    args = SceneGetValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneGetValueListSelection_Int32_result()
    result.success = self._handler.SceneGetValueListSelection_Int32(args._sceneId, args._valueId)
    oprot.writeMessageBegin("SceneGetValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Bool(self, seqid, iprot, oprot):
    args = SetSceneValue_Bool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Bool_result()
    result.success = self._handler.SetSceneValue_Bool(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Bool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Uint8(self, seqid, iprot, oprot):
    args = SetSceneValue_Uint8_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Uint8_result()
    result.success = self._handler.SetSceneValue_Uint8(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Uint8", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Float(self, seqid, iprot, oprot):
    args = SetSceneValue_Float_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Float_result()
    result.success = self._handler.SetSceneValue_Float(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Float", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Int32(self, seqid, iprot, oprot):
    args = SetSceneValue_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Int32_result()
    result.success = self._handler.SetSceneValue_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_Int16(self, seqid, iprot, oprot):
    args = SetSceneValue_Int16_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_Int16_result()
    result.success = self._handler.SetSceneValue_Int16(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_Int16", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValue_String(self, seqid, iprot, oprot):
    args = SetSceneValue_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValue_String_result()
    result.success = self._handler.SetSceneValue_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValue_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValueListSelection_String(self, seqid, iprot, oprot):
    args = SetSceneValueListSelection_String_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValueListSelection_String_result()
    result.success = self._handler.SetSceneValueListSelection_String(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValueListSelection_String", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneValueListSelection_Int32(self, seqid, iprot, oprot):
    args = SetSceneValueListSelection_Int32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneValueListSelection_Int32_result()
    result.success = self._handler.SetSceneValueListSelection_Int32(args._sceneId, args._valueId, args._value)
    oprot.writeMessageBegin("SetSceneValueListSelection_Int32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSceneLabel(self, seqid, iprot, oprot):
    args = GetSceneLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSceneLabel_result()
    result.success = self._handler.GetSceneLabel(args._sceneId)
    oprot.writeMessageBegin("GetSceneLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSceneLabel(self, seqid, iprot, oprot):
    args = SetSceneLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSceneLabel_result()
    self._handler.SetSceneLabel(args._sceneId, args._value)
    oprot.writeMessageBegin("SetSceneLabel", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SceneExists(self, seqid, iprot, oprot):
    args = SceneExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SceneExists_result()
    result.success = self._handler.SceneExists(args._sceneId)
    oprot.writeMessageBegin("SceneExists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ActivateScene(self, seqid, iprot, oprot):
    args = ActivateScene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ActivateScene_result()
    result.success = self._handler.ActivateScene(args._sceneId)
    oprot.writeMessageBegin("ActivateScene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SendAllValues(self, seqid, iprot, oprot):
    args = SendAllValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SendAllValues_result()
    self._handler.SendAllValues()
    oprot.writeMessageBegin("SendAllValues", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class WriteConfig_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteConfig_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WriteConfig_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriteConfig_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetControllerNodeId_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetControllerNodeId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetControllerNodeId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetControllerNodeId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsPrimaryController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsPrimaryController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsPrimaryController_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsPrimaryController_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsStaticUpdateController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsStaticUpdateController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsStaticUpdateController_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsStaticUpdateController_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsBridgeController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsBridgeController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsBridgeController_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsBridgeController_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryVersion_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryVersion_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryVersion_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryTypeName_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryTypeName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLibraryTypeName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLibraryTypeName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSendQueueCount_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSendQueueCount_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSendQueueCount_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSendQueueCount_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPollInterval_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPollInterval_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPollInterval_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPollInterval_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPollInterval_args:
  """
  Attributes:
   - _seconds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_seconds', None, None, ), # 1
  )

  def __init__(self, _seconds=None,):
    self._seconds = _seconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._seconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPollInterval_args')
    if self._seconds is not None:
      oprot.writeFieldBegin('_seconds', TType.I32, 1)
      oprot.writeI32(self._seconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPollInterval_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPollInterval_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnablePoll_args:
  """
  Attributes:
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _valueId=None,):
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnablePoll_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnablePoll_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnablePoll_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DisablePoll_args:
  """
  Attributes:
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _valueId=None,):
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DisablePoll_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DisablePoll_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DisablePoll_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPolled_args:
  """
  Attributes:
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _valueId=None,):
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPolled_args')
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 1)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPolled_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPolled_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RefreshNodeInfo_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RefreshNodeInfo_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RefreshNodeInfo_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RefreshNodeInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeState_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeState_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeState_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeDynamic_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeDynamic_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestNodeDynamic_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestNodeDynamic_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeListeningDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeListeningDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeListeningDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeListeningDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeRoutingDevice_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeRoutingDevice_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeRoutingDevice_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeRoutingDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeMaxBaudRate_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeMaxBaudRate_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeMaxBaudRate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeMaxBaudRate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeVersion_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeVersion_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeVersion_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSecurity_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSecurity_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSecurity_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSecurity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeBasic_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeBasic_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeBasic_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeBasic_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeGeneric_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeGeneric_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeGeneric_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeGeneric_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSpecific_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSpecific_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeSpecific_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeSpecific_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeType_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeType_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeType_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeNeighbors_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeNeighbors_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeNeighbors_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UInt32_ListByte, UInt32_ListByte.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UInt32_ListByte()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeNeighbors_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeLocation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeLocation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeLocation_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeLocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerId_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeManufacturerId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeManufacturerId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductType_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductType_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductType_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductId_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductId_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeProductId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeProductId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeManufacturerName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _manufacturerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_manufacturerName', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _manufacturerName=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._manufacturerName = _manufacturerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._manufacturerName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeManufacturerName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._manufacturerName is not None:
      oprot.writeFieldBegin('_manufacturerName', TType.STRING, 3)
      oprot.writeString(self._manufacturerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeManufacturerName_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeManufacturerName_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeProductName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _productName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_productName', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _productName=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._productName = _productName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._productName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeProductName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._productName is not None:
      oprot.writeFieldBegin('_productName', TType.STRING, 3)
      oprot.writeString(self._productName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeProductName_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeProductName_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeName_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _nodeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_nodeName', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _nodeName=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._nodeName = _nodeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._nodeName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeName_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._nodeName is not None:
      oprot.writeFieldBegin('_nodeName', TType.STRING, 3)
      oprot.writeString(self._nodeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeName_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeName_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLocation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _location
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.STRING, '_location', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _location=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._location = _location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLocation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._location is not None:
      oprot.writeFieldBegin('_location', TType.STRING, 3)
      oprot.writeString(self._location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLocation_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLocation_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOn_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOn_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOn_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOn_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOff_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOff_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeOff_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeOff_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLevel_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _level
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_level', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _level=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._level = _level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._level = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLevel_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._level is not None:
      oprot.writeFieldBegin('_level', TType.BYTE, 3)
      oprot.writeByte(self._level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetNodeLevel_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetNodeLevel_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeInfoReceived_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeInfoReceived_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsNodeInfoReceived_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsNodeInfoReceived_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeClassInformation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _commandClassId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_commandClassId', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _commandClassId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._commandClassId = _commandClassId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._commandClassId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeClassInformation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._commandClassId is not None:
      oprot.writeFieldBegin('_commandClassId', TType.BYTE, 3)
      oprot.writeByte(self._commandClassId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNodeClassInformation_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_GetNodeClassInformation, Bool_GetNodeClassInformation.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_GetNodeClassInformation()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNodeClassInformation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueLabel_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueLabel_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueLabel_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueLabel_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueLabel_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueLabel_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueLabel_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueUnits_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueUnits_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueUnits_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueUnits_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueUnits_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueUnits_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueUnits_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueUnits_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueHelp_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueHelp_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueHelp_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueHelp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueHelp_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueHelp_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueHelp_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueHelp_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMin_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMin_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMax_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMax_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueMax_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueMax_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueReadOnly_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueReadOnly_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueReadOnly_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueReadOnly_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueWriteOnly_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueWriteOnly_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueWriteOnly_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueWriteOnly_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueSet_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueSet_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsValueSet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsValueSet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsBool_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsBool_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsBool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Bool, Bool_Bool.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Bool()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsBool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsByte_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsByte_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsByte_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_UInt8, Bool_UInt8.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_UInt8()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsByte_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsFloat_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsFloat_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsFloat_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Float, Bool_Float.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Float()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsFloat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsInt_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsInt_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsInt_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsInt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsShort_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsShort_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsShort_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int16, Bool_Int16.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int16()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsShort_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsString_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsString_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueAsString_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueAsString_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_String_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_String_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_Int32_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_Int32_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListItems_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListItems_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueListItems_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_ListString, Bool_ListString.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_ListString()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueListItems_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueFloatPrecision_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueFloatPrecision_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValueFloatPrecision_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_UInt8, Bool_UInt8.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_UInt8()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValueFloatPrecision_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Bool_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BOOL, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self._value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Bool_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BOOL, 2)
      oprot.writeBool(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Bool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Bool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_UInt8_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_UInt8_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BYTE, 2)
      oprot.writeByte(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_UInt8_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_UInt8_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Float_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.DOUBLE, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self._value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Float_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.DOUBLE, 2)
      oprot.writeDouble(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Float_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Float_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int32_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.I32, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int32_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 2)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int16_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.I16, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self._value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int16_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I16, 2)
      oprot.writeI16(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_Int16_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_Int16_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_String_args:
  """
  Attributes:
   - _id
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _id=None, _value=None,):
    self._id = _id
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_String_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValue_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValue_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueListSelection_args:
  """
  Attributes:
   - _id
   - _selectedItem
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.STRING, '_selectedItem', None, None, ), # 2
  )

  def __init__(self, _id=None, _selectedItem=None,):
    self._id = _id
    self._selectedItem = _selectedItem

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._selectedItem = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueListSelection_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._selectedItem is not None:
      oprot.writeFieldBegin('_selectedItem', TType.STRING, 2)
      oprot.writeString(self._selectedItem)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetValueListSelection_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetValueListSelection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PressButton_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PressButton_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PressButton_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PressButton_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReleaseButton_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReleaseButton_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReleaseButton_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReleaseButton_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumSwitchPoints_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumSwitchPoints_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumSwitchPoints_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumSwitchPoints_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSwitchPoint_args:
  """
  Attributes:
   - _id
   - _hours
   - _minutes
   - _setback
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_hours', None, None, ), # 2
    (3, TType.BYTE, '_minutes', None, None, ), # 3
    (4, TType.BYTE, '_setback', None, None, ), # 4
  )

  def __init__(self, _id=None, _hours=None, _minutes=None, _setback=None,):
    self._id = _id
    self._hours = _hours
    self._minutes = _minutes
    self._setback = _setback

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._hours = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._minutes = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._setback = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSwitchPoint_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._hours is not None:
      oprot.writeFieldBegin('_hours', TType.BYTE, 2)
      oprot.writeByte(self._hours)
      oprot.writeFieldEnd()
    if self._minutes is not None:
      oprot.writeFieldBegin('_minutes', TType.BYTE, 3)
      oprot.writeByte(self._minutes)
      oprot.writeFieldEnd()
    if self._setback is not None:
      oprot.writeFieldBegin('_setback', TType.BYTE, 4)
      oprot.writeByte(self._setback)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSwitchPoint_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSwitchPoint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSwitchPoint_args:
  """
  Attributes:
   - _id
   - _hours
   - _minutes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_hours', None, None, ), # 2
    (3, TType.BYTE, '_minutes', None, None, ), # 3
  )

  def __init__(self, _id=None, _hours=None, _minutes=None,):
    self._id = _id
    self._hours = _hours
    self._minutes = _minutes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._hours = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._minutes = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSwitchPoint_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._hours is not None:
      oprot.writeFieldBegin('_hours', TType.BYTE, 2)
      oprot.writeByte(self._hours)
      oprot.writeFieldEnd()
    if self._minutes is not None:
      oprot.writeFieldBegin('_minutes', TType.BYTE, 3)
      oprot.writeByte(self._minutes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSwitchPoint_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSwitchPoint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearSwitchPoints_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearSwitchPoints_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearSwitchPoints_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearSwitchPoints_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSwitchPoint_args:
  """
  Attributes:
   - _id
   - _idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, '_id', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 1
    (2, TType.BYTE, '_idx', None, None, ), # 2
  )

  def __init__(self, _id=None, _idx=None,):
    self._id = _id
    self._idx = _idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self._id = RemoteValueID()
          self._id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._idx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSwitchPoint_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRUCT, 1)
      self._id.write(oprot)
      oprot.writeFieldEnd()
    if self._idx is not None:
      oprot.writeFieldBegin('_idx', TType.BYTE, 2)
      oprot.writeByte(self._idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSwitchPoint_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetSwitchPointReturnStruct, GetSwitchPointReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetSwitchPointReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSwitchPoint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOn_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOn_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOn_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOn_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOff_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOff_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchAllOff_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchAllOff_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetConfigParam_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _param
   - _value
   - _size
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_param', None, None, ), # 3
    (4, TType.I32, '_value', None, None, ), # 4
    (5, TType.BYTE, '_size', None, 2, ), # 5
  )

  def __init__(self, _homeId=None, _nodeId=None, _param=None, _value=None, _size=thrift_spec[5][4],):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._param = _param
    self._value = _value
    self._size = _size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._param = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self._size = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetConfigParam_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._param is not None:
      oprot.writeFieldBegin('_param', TType.BYTE, 3)
      oprot.writeByte(self._param)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 4)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    if self._size is not None:
      oprot.writeFieldBegin('_size', TType.BYTE, 5)
      oprot.writeByte(self._size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetConfigParam_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetConfigParam_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestConfigParam_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _param
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_param', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _param=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._param = _param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._param = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestConfigParam_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._param is not None:
      oprot.writeFieldBegin('_param', TType.BYTE, 3)
      oprot.writeByte(self._param)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestConfigParam_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestConfigParam_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestAllConfigParams_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestAllConfigParams_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestAllConfigParams_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestAllConfigParams_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumGroups_args:
  """
  Attributes:
   - _homeId
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
  )

  def __init__(self, _homeId=None, _nodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumGroups_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumGroups_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAssociations_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAssociations_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAssociations_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAssociationsReturnStruct, GetAssociationsReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAssociationsReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAssociations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaxAssociations_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaxAssociations_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaxAssociations_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaxAssociations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetGroupLabel_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetGroupLabel_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetGroupLabel_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetGroupLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddAssociation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
   - _targetNodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
    (4, TType.BYTE, '_targetNodeId', None, None, ), # 4
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None, _targetNodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx
    self._targetNodeId = _targetNodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._targetNodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddAssociation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    if self._targetNodeId is not None:
      oprot.writeFieldBegin('_targetNodeId', TType.BYTE, 4)
      oprot.writeByte(self._targetNodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddAssociation_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddAssociation_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAssociation_args:
  """
  Attributes:
   - _homeId
   - _nodeId
   - _groupIdx
   - _targetNodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.BYTE, '_nodeId', None, None, ), # 2
    (3, TType.BYTE, '_groupIdx', None, None, ), # 3
    (4, TType.BYTE, '_targetNodeId', None, None, ), # 4
  )

  def __init__(self, _homeId=None, _nodeId=None, _groupIdx=None, _targetNodeId=None,):
    self._homeId = _homeId
    self._nodeId = _nodeId
    self._groupIdx = _groupIdx
    self._targetNodeId = _targetNodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._groupIdx = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._targetNodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAssociation_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 2)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    if self._groupIdx is not None:
      oprot.writeFieldBegin('_groupIdx', TType.BYTE, 3)
      oprot.writeByte(self._groupIdx)
      oprot.writeFieldEnd()
    if self._targetNodeId is not None:
      oprot.writeFieldBegin('_targetNodeId', TType.BYTE, 4)
      oprot.writeByte(self._targetNodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAssociation_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAssociation_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetController_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetController_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetController_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetController_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SoftReset_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SoftReset_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SoftReset_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SoftReset_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BeginControllerCommand_args:
  """
  Attributes:
   - _homeId
   - _command
   - _highPower
   - _nodeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
    (2, TType.I32, '_command', None, None, ), # 2
    (3, TType.BOOL, '_highPower', None, None, ), # 3
    (4, TType.BYTE, '_nodeId', None, None, ), # 4
  )

  def __init__(self, _homeId=None, _command=None, _highPower=None, _nodeId=None,):
    self._homeId = _homeId
    self._command = _command
    self._highPower = _highPower
    self._nodeId = _nodeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self._command = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._highPower = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self._nodeId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BeginControllerCommand_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    if self._command is not None:
      oprot.writeFieldBegin('_command', TType.I32, 2)
      oprot.writeI32(self._command)
      oprot.writeFieldEnd()
    if self._highPower is not None:
      oprot.writeFieldBegin('_highPower', TType.BOOL, 3)
      oprot.writeBool(self._highPower)
      oprot.writeFieldEnd()
    if self._nodeId is not None:
      oprot.writeFieldBegin('_nodeId', TType.BYTE, 4)
      oprot.writeByte(self._nodeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BeginControllerCommand_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BeginControllerCommand_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelControllerCommand_args:
  """
  Attributes:
   - _homeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, '_homeId', None, None, ), # 1
  )

  def __init__(self, _homeId=None,):
    self._homeId = _homeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self._homeId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelControllerCommand_args')
    if self._homeId is not None:
      oprot.writeFieldBegin('_homeId', TType.I32, 1)
      oprot.writeI32(self._homeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelControllerCommand_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelControllerCommand_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumScenes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumScenes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetNumScenes_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetNumScenes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllScenes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllScenes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllScenes_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAllScenesReturnStruct, GetAllScenesReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAllScenesReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllScenes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateScene_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateScene_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateScene_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateScene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveScene_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveScene_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveScene_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveScene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Bool_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BOOL, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Bool_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BOOL, 3)
      oprot.writeBool(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Bool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Bool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Uint8_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BYTE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Uint8_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BYTE, 3)
      oprot.writeByte(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Uint8_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Uint8_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Float_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self._value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Float_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.DOUBLE, 3)
      oprot.writeDouble(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Float_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Float_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int16_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I16, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self._value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int16_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I16, 3)
      oprot.writeI16(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_Int16_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_Int16_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValue_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValue_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddSceneValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddSceneValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSceneValue_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSceneValue_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveSceneValue_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveSceneValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValues_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValues_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValues_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SceneGetValuesReturnStruct, SceneGetValuesReturnStruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SceneGetValuesReturnStruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsBool_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsBool_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsBool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Bool, Bool_Bool.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Bool()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsBool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsByte_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsByte_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsByte_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_UInt8, Bool_UInt8.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_UInt8()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsByte_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsFloat_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsFloat_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsFloat_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Float, Bool_Float.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Float()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsFloat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsInt_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsInt_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsInt_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsInt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsShort_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsShort_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsShort_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int16, Bool_Int16.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int16()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsShort_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsString_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsString_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueAsString_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueAsString_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_String, Bool_String.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_String()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
  )

  def __init__(self, _sceneId=None, _valueId=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneGetValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Bool_Int, Bool_Int.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Bool_Int()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneGetValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Bool_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BOOL, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self._value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Bool_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BOOL, 3)
      oprot.writeBool(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Bool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Bool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Uint8_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.BYTE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self._value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Uint8_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.BYTE, 3)
      oprot.writeByte(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Uint8_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Uint8_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Float_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self._value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Float_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.DOUBLE, 3)
      oprot.writeDouble(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Float_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Float_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int16_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I16, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self._value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int16_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I16, 3)
      oprot.writeI16(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_Int16_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_Int16_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValue_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValue_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_String_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.STRING, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_String_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 3)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_String_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_String_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_Int32_args:
  """
  Attributes:
   - _sceneId
   - _valueId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRUCT, '_valueId', (RemoteValueID, RemoteValueID.thrift_spec), None, ), # 2
    (3, TType.I32, '_value', None, None, ), # 3
  )

  def __init__(self, _sceneId=None, _valueId=None, _value=None,):
    self._sceneId = _sceneId
    self._valueId = _valueId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self._valueId = RemoteValueID()
          self._valueId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self._value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_Int32_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._valueId is not None:
      oprot.writeFieldBegin('_valueId', TType.STRUCT, 2)
      self._valueId.write(oprot)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.I32, 3)
      oprot.writeI32(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneValueListSelection_Int32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneValueListSelection_Int32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSceneLabel_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSceneLabel_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSceneLabel_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSceneLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneLabel_args:
  """
  Attributes:
   - _sceneId
   - _value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
    (2, TType.STRING, '_value', None, None, ), # 2
  )

  def __init__(self, _sceneId=None, _value=None,):
    self._sceneId = _sceneId
    self._value = _value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneLabel_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    if self._value is not None:
      oprot.writeFieldBegin('_value', TType.STRING, 2)
      oprot.writeString(self._value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSceneLabel_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSceneLabel_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneExists_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneExists_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SceneExists_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SceneExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ActivateScene_args:
  """
  Attributes:
   - _sceneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, '_sceneId', None, None, ), # 1
  )

  def __init__(self, _sceneId=None,):
    self._sceneId = _sceneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self._sceneId = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ActivateScene_args')
    if self._sceneId is not None:
      oprot.writeFieldBegin('_sceneId', TType.BYTE, 1)
      oprot.writeByte(self._sceneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ActivateScene_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ActivateScene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendAllValues_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendAllValues_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendAllValues_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendAllValues_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
