/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : Stomp_sm.sm
 */


//-----------------------------------------------------------------------------
//
//	Project: STOMP for OpenZWave
//
//	a simple STOMP (Simple Text Oriented Messaging Protocol) client 
//  for more info on the protocol, see URL: http://stomp.github.com/
//
//      1) subscribes to STOMP queues to pass ZWave commands to OpenZWave
//      2) sends to STOMP queues ZWave notifications by OpenZWave's Notification mechanism
//
//	Copyright (c) 2011 Elias Karakoulakis
//
//	SOFTWARE NOTICE AND LICENSE
//
//	This file is part of Thrift4OZW.
//
//	Thrift4OZW is free software: you can redistribute it and/or modify
//	it under the terms of the GNU Lesser General Public License as published
//	by the Free Software Foundation, either version 3 of the License,
//	or (at your option) any later version.
//
//	Thrift4OZW is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU Lesser General Public License for more details.
//
//	You should have received a copy of the GNU Lesser General Public License
//	along with Thrift4OZW.  If not, see <http://www.gnu.org/licenses/>.
//
//-----------------------------------------------------------------------------


#include "PocoStomp.h"
#include "PocoStomp.h"
#include "Stomp_sm.h"

using namespace statemap;

namespace STOMP
{
    // Static class declarations.
    StompFSM_map_Disconnected StompFSM_map::Disconnected("StompFSM_map::Disconnected", 0);
    StompFSM_map_SocketConnected StompFSM_map::SocketConnected("StompFSM_map::SocketConnected", 1);
    StompFSM_map_Ready StompFSM_map::Ready("StompFSM_map::Ready", 2);
    StompFSM_map_SendingAck StompFSM_map::SendingAck("StompFSM_map::SendingAck", 3);
    StompFSM_map_Disconnecting StompFSM_map::Disconnecting("StompFSM_map::Disconnecting", 4);

    void PocoStompState::ack_received(StompContext& context, PFrame _frame)
    {
        Default(context);
        return;
    }

    void PocoStompState::receive_frame(StompContext& context, PFrame _frame)
    {
        Default(context);
        return;
    }

    void PocoStompState::send_frame(StompContext& context, PFrame _frame)
    {
        Default(context);
        return;
    }

    void PocoStompState::socket_connected(StompContext& context)
    {
        Default(context);
        return;
    }

    void PocoStompState::socket_disconnected(StompContext& context)
    {
        Default(context);
        return;
    }

    void PocoStompState::timeout(StompContext& context)
    {
        Default(context);
        return;
    }

    void PocoStompState::timeout(StompContext& context, PocoStompState* waitingfor)
    {
        Default(context);
        return;
    }

    void PocoStompState::Default(StompContext& context)
    {
        throw (
            TransitionUndefinedException(
                context.getState().getName(),
                context.getTransition()));

        return;
    }

    void StompFSM_map_Disconnected::socket_connected(StompContext& context)
    {
        PocoStomp& ctxt(context.getOwner());

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.debug_print("socket connected!\n");
            context.setState(StompFSM_map::SocketConnected);
        }
        catch (...)
        {
            context.setState(StompFSM_map::SocketConnected);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void StompFSM_map_Disconnected::socket_disconnected(StompContext& context)
    {
        PocoStomp& ctxt(context.getOwner());

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.debug_print("STOMP server disconnected! retrying connection...");
            context.setState(StompFSM_map::Disconnected);
        }
        catch (...)
        {
            context.setState(StompFSM_map::Disconnected);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void StompFSM_map_SocketConnected::send_frame(StompContext& context, PFrame _frame)
    {
        PocoStomp& ctxt(context.getOwner());

        if (
        (_frame->command.compare("CONNECT") == 0)
    )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.initialized();
                ctxt.debug_print("CONNECT");
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else
        {
             StompFSM_map_Default::send_frame(context, _frame);
        }

        return;
    }

    void StompFSM_map_SocketConnected::socket_disconnected(StompContext& context)
    {
        PocoStomp& ctxt(context.getOwner());

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.debug_print("STOMP server disconnected! retrying connection...");
            context.setState(StompFSM_map::Disconnected);
        }
        catch (...)
        {
            context.setState(StompFSM_map::Disconnected);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void StompFSM_map_Ready::receive_frame(StompContext& context, PFrame _frame)
    {
        PocoStomp& ctxt(context.getOwner());

        if (
        (_frame->command.compare("CONNECTED") == 0)
    )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("CONNECTED!\n");
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if (
        (_frame->command.compare("MESSAGE") == 0)
            &&
        (ctxt.get_ackmode() == ACK_AUTO)   
    )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("MESSAGE frame from STOMP server!\n");
                ctxt.notify_callbacks(_frame);
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if (
        (_frame->command.compare("MESSAGE") == 0)
            &&
        (ctxt.get_ackmode() == ACK_CLIENT)   
    )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("MESSAGE frame from STOMP server!\n");
                ctxt.notify_callbacks(_frame);
                context.setState(StompFSM_map::SendingAck);
            }
            catch (...)
            {
                context.setState(StompFSM_map::SendingAck);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if (
        (_frame->command.compare("RECEIPT") == 0)
            &&
        (ctxt.get_ackmode() == ACK_AUTO)
    )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("RECEIPT, ack:AUTO\n");
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if (
        (_frame->command.compare("RECEIPT") == 0)
            &&
        (ctxt.get_ackmode() == ACK_CLIENT)
    )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("RECEIPT, ack:CLIENT\n");
                context.setState(StompFSM_map::SendingAck);
            }
            catch (...)
            {
                context.setState(StompFSM_map::SendingAck);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if (
        (_frame->command.compare("ERROR") == 0)
    )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("ERROR frame from STOMP server!\n");
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }        else
        {
             StompFSM_map_Default::receive_frame(context, _frame);
        }

        return;
    }

    void StompFSM_map_Ready::send_frame(StompContext& context, PFrame _frame)
    {
        PocoStomp& ctxt(context.getOwner());

        if (
        (_frame->command.compare("DISCONNECT") == 0)
    )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.start_timer(&StompFSM_map::Disconnecting);
                ctxt.debug_print("Disconnecting...\n");
                context.setState(StompFSM_map::Disconnecting);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Disconnecting);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if (
        (_frame->command.compare("SUBSCRIBE") == 0)
    )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("SUBSCRIBE");
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("StompClient: send_frame\n");
                context.setState(StompFSM_map::Ready);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Ready);
                throw;
            }
            (context.getState()).Entry(context);
        }

        return;
    }

    void StompFSM_map_Ready::socket_disconnected(StompContext& context)
    {
        PocoStomp& ctxt(context.getOwner());

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.socket_shutdown();
            ctxt.debug_print("STOMP server disconnected! retrying connection...");
            context.setState(StompFSM_map::Disconnected);
        }
        catch (...)
        {
            context.setState(StompFSM_map::Disconnected);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void StompFSM_map_Ready::timeout(StompContext& context)
    {
        PocoStomp& ctxt(context.getOwner());

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.debug_print("timeout waiting for full STOMP frame!");
            context.setState(StompFSM_map::Ready);
        }
        catch (...)
        {
            context.setState(StompFSM_map::Ready);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void StompFSM_map_SendingAck::send_frame(StompContext& context, PFrame _frame)
    {
        PocoStomp& ctxt(context.getOwner());

        if (
        (_frame->command.compare("ACK") == 0)
            &&
        (ctxt.get_ackmode() == ACK_CLIENT)
    )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(StompFSM_map::Ready);
            (context.getState()).Entry(context);
        }
        else
        {
             StompFSM_map_Default::send_frame(context, _frame);
        }

        return;
    }

    void StompFSM_map_Disconnecting::ack_received(StompContext& context, PFrame _frame)
    {
        PocoStomp& ctxt(context.getOwner());

        if (
        _frame->command.compare("DISCONNECT")==0
    )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.stop_timer();
                ctxt.debug_print("ACK received!");
                context.setState(StompFSM_map::Disconnected);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Disconnected);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else
        {
             StompFSM_map_Default::ack_received(context, _frame);
        }

        return;
    }

    void StompFSM_map_Disconnecting::timeout(StompContext& context, PocoStompState* waitingfor)
    {
        PocoStomp& ctxt(context.getOwner());

        if (
        strcmp(waitingfor->getName(), "Disconnecting")==0
    )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.debug_print("ooops, timed out disconnecting!!");
                context.setState(StompFSM_map::Disconnected);
            }
            catch (...)
            {
                context.setState(StompFSM_map::Disconnected);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else
        {
             StompFSM_map_Default::timeout(context, waitingfor);
        }

        return;
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
